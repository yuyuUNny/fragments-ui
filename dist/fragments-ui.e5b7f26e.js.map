{"mappings":"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","sources":["<anon>","node_modules/crypto-js/core.js","node_modules/@parcel/node-resolver-core/lib/_empty.js","node_modules/crypto-js/sha256.js","node_modules/crypto-js/enc-base64.js","node_modules/crypto-js/enc-utf8.js","node_modules/jwt-decode/build/jwt-decode.esm.js","node_modules/jwt-decode/lib/atob.js","node_modules/jwt-decode/lib/base64_url_decode.js","node_modules/jwt-decode/lib/index.js","src/app.js","src/auth.js","node_modules/oidc-client-ts/dist/umd/oidc-client-ts.js","node_modules/oidc-client-ts/src/index.ts","node_modules/oidc-client-ts/src/utils/CryptoUtils.ts","node_modules/oidc-client-ts/src/utils/Logger.ts","node_modules/oidc-client-ts/src/utils/Event.ts","node_modules/oidc-client-ts/src/utils/JwtUtils.ts","node_modules/oidc-client-ts/src/utils/PopupUtils.ts","node_modules/oidc-client-ts/src/utils/Timer.ts","node_modules/oidc-client-ts/src/utils/UrlUtils.ts","node_modules/oidc-client-ts/src/errors/ErrorResponse.ts","node_modules/oidc-client-ts/src/errors/ErrorTimeout.ts","node_modules/oidc-client-ts/src/AccessTokenEvents.ts","node_modules/oidc-client-ts/src/CheckSessionIFrame.ts","node_modules/oidc-client-ts/src/InMemoryWebStorage.ts","node_modules/oidc-client-ts/src/JsonService.ts","node_modules/oidc-client-ts/src/MetadataService.ts","node_modules/oidc-client-ts/src/WebStorageStateStore.ts","node_modules/oidc-client-ts/src/OidcClientSettings.ts","node_modules/oidc-client-ts/src/UserInfoService.ts","node_modules/oidc-client-ts/src/TokenClient.ts","node_modules/oidc-client-ts/src/ResponseValidator.ts","node_modules/oidc-client-ts/src/State.ts","node_modules/oidc-client-ts/src/SigninState.ts","node_modules/oidc-client-ts/src/SigninRequest.ts","node_modules/oidc-client-ts/src/SigninResponse.ts","node_modules/oidc-client-ts/src/SignoutRequest.ts","node_modules/oidc-client-ts/src/SignoutResponse.ts","node_modules/oidc-client-ts/src/ClaimsService.ts","node_modules/oidc-client-ts/src/OidcClient.ts","node_modules/oidc-client-ts/src/SessionMonitor.ts","node_modules/oidc-client-ts/src/User.ts","node_modules/oidc-client-ts/src/navigators/AbstractChildWindow.ts","node_modules/oidc-client-ts/src/UserManagerSettings.ts","node_modules/oidc-client-ts/src/navigators/IFrameWindow.ts","node_modules/oidc-client-ts/src/navigators/IFrameNavigator.ts","node_modules/oidc-client-ts/src/navigators/PopupWindow.ts","node_modules/oidc-client-ts/src/navigators/PopupNavigator.ts","node_modules/oidc-client-ts/src/navigators/RedirectNavigator.ts","node_modules/oidc-client-ts/src/UserManagerEvents.ts","node_modules/oidc-client-ts/src/SilentRenewService.ts","node_modules/oidc-client-ts/src/RefreshState.ts","node_modules/oidc-client-ts/src/UserManager.ts","node_modules/oidc-client-ts/package.json","node_modules/oidc-client-ts/src/Version.ts","src/api.js"],"sourcesContent":["\n      var $parcel$global = globalThis;\n    \nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true, configurable: true});\n}\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequirec284\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequirec284\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"3OBZa\", function(module, exports) {\n\n(function(root, factory) {\n    // CommonJS\n    module.exports = exports = factory();\n})(this, function() {\n    /*globals window, global, require*/ /**\n\t * CryptoJS core components.\n\t */ var CryptoJS = CryptoJS || function(Math1, undefined) {\n        var crypto;\n        // Native crypto from window (Browser)\n        if (typeof window !== 'undefined' && window.crypto) crypto = window.crypto;\n        // Native crypto in web worker (Browser)\n        if (typeof self !== 'undefined' && self.crypto) crypto = self.crypto;\n        // Native crypto from worker\n        if (typeof globalThis !== 'undefined' && globalThis.crypto) crypto = globalThis.crypto;\n        // Native (experimental IE 11) crypto from window (Browser)\n        if (!crypto && typeof window !== 'undefined' && window.msCrypto) crypto = window.msCrypto;\n        // Native crypto from global (NodeJS)\n        if (!crypto && typeof $parcel$global !== 'undefined' && $parcel$global.crypto) crypto = $parcel$global.crypto;\n        // Native crypto import via require (NodeJS)\n        if (!crypto && true) try {\n            crypto = (parcelRequire(\"kjyEk\"));\n        } catch (err) {}\n        /*\n\t     * Cryptographically secure pseudorandom number generator\n\t     *\n\t     * As Math.random() is cryptographically not safe to use\n\t     */ var cryptoSecureRandomInt = function() {\n            if (crypto) {\n                // Use getRandomValues method (Browser)\n                if (typeof crypto.getRandomValues === 'function') try {\n                    return crypto.getRandomValues(new Uint32Array(1))[0];\n                } catch (err) {}\n                // Use randomBytes method (NodeJS)\n                if (typeof crypto.randomBytes === 'function') try {\n                    return crypto.randomBytes(4).readInt32LE();\n                } catch (err) {}\n            }\n            throw new Error('Native crypto module could not be used to get secure random number.');\n        };\n        /*\n\t     * Local polyfill of Object.create\n\n\t     */ var create = Object.create || function() {\n            function F() {}\n            return function(obj) {\n                var subtype;\n                F.prototype = obj;\n                subtype = new F();\n                F.prototype = null;\n                return subtype;\n            };\n        }();\n        /**\n\t     * CryptoJS namespace.\n\t     */ var C = {};\n        /**\n\t     * Library namespace.\n\t     */ var C_lib = C.lib = {};\n        /**\n\t     * Base object for prototypal inheritance.\n\t     */ var Base = C_lib.Base = function() {\n            return {\n                /**\n\t             * Creates a new object that inherits from this object.\n\t             *\n\t             * @param {Object} overrides Properties to copy into the new object.\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         field: 'value',\n\t             *\n\t             *         method: function () {\n\t             *         }\n\t             *     });\n\t             */ extend: function(overrides) {\n                    // Spawn\n                    var subtype = create(this);\n                    // Augment\n                    if (overrides) subtype.mixIn(overrides);\n                    // Create default initializer\n                    if (!subtype.hasOwnProperty('init') || this.init === subtype.init) subtype.init = function() {\n                        subtype.$super.init.apply(this, arguments);\n                    };\n                    // Initializer's prototype is the subtype object\n                    subtype.init.prototype = subtype;\n                    // Reference supertype\n                    subtype.$super = this;\n                    return subtype;\n                },\n                /**\n\t             * Extends this object and runs the init method.\n\t             * Arguments to create() will be passed to init().\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var instance = MyType.create();\n\t             */ create: function() {\n                    var instance = this.extend();\n                    instance.init.apply(instance, arguments);\n                    return instance;\n                },\n                /**\n\t             * Initializes a newly created object.\n\t             * Override this method to add some logic when your objects are created.\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         init: function () {\n\t             *             // ...\n\t             *         }\n\t             *     });\n\t             */ init: function() {},\n                /**\n\t             * Copies properties into this object.\n\t             *\n\t             * @param {Object} properties The properties to mix in.\n\t             *\n\t             * @example\n\t             *\n\t             *     MyType.mixIn({\n\t             *         field: 'value'\n\t             *     });\n\t             */ mixIn: function(properties) {\n                    for(var propertyName in properties)if (properties.hasOwnProperty(propertyName)) this[propertyName] = properties[propertyName];\n                    // IE won't copy toString using the loop above\n                    if (properties.hasOwnProperty('toString')) this.toString = properties.toString;\n                },\n                /**\n\t             * Creates a copy of this object.\n\t             *\n\t             * @return {Object} The clone.\n\t             *\n\t             * @example\n\t             *\n\t             *     var clone = instance.clone();\n\t             */ clone: function() {\n                    return this.init.prototype.extend(this);\n                }\n            };\n        }();\n        /**\n\t     * An array of 32-bit words.\n\t     *\n\t     * @property {Array} words The array of 32-bit words.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */ var WordArray = C_lib.WordArray = Base.extend({\n            /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t         */ init: function(words, sigBytes) {\n                words = this.words = words || [];\n                if (sigBytes != undefined) this.sigBytes = sigBytes;\n                else this.sigBytes = words.length * 4;\n            },\n            /**\n\t         * Converts this word array to a string.\n\t         *\n\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t         *\n\t         * @return {string} The stringified word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = wordArray + '';\n\t         *     var string = wordArray.toString();\n\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t         */ toString: function(encoder) {\n                return (encoder || Hex).stringify(this);\n            },\n            /**\n\t         * Concatenates a word array to this word array.\n\t         *\n\t         * @param {WordArray} wordArray The word array to append.\n\t         *\n\t         * @return {WordArray} This word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray1.concat(wordArray2);\n\t         */ concat: function(wordArray) {\n                // Shortcuts\n                var thisWords = this.words;\n                var thatWords = wordArray.words;\n                var thisSigBytes = this.sigBytes;\n                var thatSigBytes = wordArray.sigBytes;\n                // Clamp excess bits\n                this.clamp();\n                // Concat\n                if (thisSigBytes % 4) // Copy one byte at a time\n                for(var i = 0; i < thatSigBytes; i++){\n                    var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;\n                    thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;\n                }\n                else // Copy one word at a time\n                for(var j = 0; j < thatSigBytes; j += 4)thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];\n                this.sigBytes += thatSigBytes;\n                // Chainable\n                return this;\n            },\n            /**\n\t         * Removes insignificant bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray.clamp();\n\t         */ clamp: function() {\n                // Shortcuts\n                var words = this.words;\n                var sigBytes = this.sigBytes;\n                // Clamp\n                words[sigBytes >>> 2] &= 0xffffffff << 32 - sigBytes % 4 * 8;\n                words.length = Math1.ceil(sigBytes / 4);\n            },\n            /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = wordArray.clone();\n\t         */ clone: function() {\n                var clone = Base.clone.call(this);\n                clone.words = this.words.slice(0);\n                return clone;\n            },\n            /**\n\t         * Creates a word array filled with random bytes.\n\t         *\n\t         * @param {number} nBytes The number of random bytes to generate.\n\t         *\n\t         * @return {WordArray} The random word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t         */ random: function(nBytes) {\n                var words = [];\n                for(var i = 0; i < nBytes; i += 4)words.push(cryptoSecureRandomInt());\n                return new WordArray.init(words, nBytes);\n            }\n        });\n        /**\n\t     * Encoder namespace.\n\t     */ var C_enc = C.enc = {};\n        /**\n\t     * Hex encoding strategy.\n\t     */ var Hex = C_enc.Hex = {\n            /**\n\t         * Converts a word array to a hex string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The hex string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t         */ stringify: function(wordArray) {\n                // Shortcuts\n                var words = wordArray.words;\n                var sigBytes = wordArray.sigBytes;\n                // Convert\n                var hexChars = [];\n                for(var i = 0; i < sigBytes; i++){\n                    var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;\n                    hexChars.push((bite >>> 4).toString(16));\n                    hexChars.push((bite & 0x0f).toString(16));\n                }\n                return hexChars.join('');\n            },\n            /**\n\t         * Converts a hex string to a word array.\n\t         *\n\t         * @param {string} hexStr The hex string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t         */ parse: function(hexStr) {\n                // Shortcut\n                var hexStrLength = hexStr.length;\n                // Convert\n                var words = [];\n                for(var i = 0; i < hexStrLength; i += 2)words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;\n                return new WordArray.init(words, hexStrLength / 2);\n            }\n        };\n        /**\n\t     * Latin1 encoding strategy.\n\t     */ var Latin1 = C_enc.Latin1 = {\n            /**\n\t         * Converts a word array to a Latin1 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Latin1 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t         */ stringify: function(wordArray) {\n                // Shortcuts\n                var words = wordArray.words;\n                var sigBytes = wordArray.sigBytes;\n                // Convert\n                var latin1Chars = [];\n                for(var i = 0; i < sigBytes; i++){\n                    var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;\n                    latin1Chars.push(String.fromCharCode(bite));\n                }\n                return latin1Chars.join('');\n            },\n            /**\n\t         * Converts a Latin1 string to a word array.\n\t         *\n\t         * @param {string} latin1Str The Latin1 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t         */ parse: function(latin1Str) {\n                // Shortcut\n                var latin1StrLength = latin1Str.length;\n                // Convert\n                var words = [];\n                for(var i = 0; i < latin1StrLength; i++)words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << 24 - i % 4 * 8;\n                return new WordArray.init(words, latin1StrLength);\n            }\n        };\n        /**\n\t     * UTF-8 encoding strategy.\n\t     */ var Utf8 = C_enc.Utf8 = {\n            /**\n\t         * Converts a word array to a UTF-8 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-8 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t         */ stringify: function(wordArray) {\n                try {\n                    return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n                } catch (e) {\n                    throw new Error('Malformed UTF-8 data');\n                }\n            },\n            /**\n\t         * Converts a UTF-8 string to a word array.\n\t         *\n\t         * @param {string} utf8Str The UTF-8 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t         */ parse: function(utf8Str) {\n                return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n            }\n        };\n        /**\n\t     * Abstract buffered block algorithm template.\n\t     *\n\t     * The property blockSize must be implemented in a concrete subtype.\n\t     *\n\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t     */ var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n            /**\n\t         * Resets this block algorithm's data buffer to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm.reset();\n\t         */ reset: function() {\n                // Initial values\n                this._data = new WordArray.init();\n                this._nDataBytes = 0;\n            },\n            /**\n\t         * Adds new data to this block algorithm's buffer.\n\t         *\n\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm._append('data');\n\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t         */ _append: function(data) {\n                // Convert string to WordArray, else assume WordArray already\n                if (typeof data == 'string') data = Utf8.parse(data);\n                // Append\n                this._data.concat(data);\n                this._nDataBytes += data.sigBytes;\n            },\n            /**\n\t         * Processes available data blocks.\n\t         *\n\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t         *\n\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t         *\n\t         * @return {WordArray} The processed data.\n\t         *\n\t         * @example\n\t         *\n\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t         */ _process: function(doFlush) {\n                var processedWords;\n                // Shortcuts\n                var data = this._data;\n                var dataWords = data.words;\n                var dataSigBytes = data.sigBytes;\n                var blockSize = this.blockSize;\n                var blockSizeBytes = blockSize * 4;\n                // Count blocks ready\n                var nBlocksReady = dataSigBytes / blockSizeBytes;\n                if (doFlush) // Round up to include partial blocks\n                nBlocksReady = Math1.ceil(nBlocksReady);\n                else // Round down to include only full blocks,\n                // less the number of blocks that must remain in the buffer\n                nBlocksReady = Math1.max((nBlocksReady | 0) - this._minBufferSize, 0);\n                // Count words ready\n                var nWordsReady = nBlocksReady * blockSize;\n                // Count bytes ready\n                var nBytesReady = Math1.min(nWordsReady * 4, dataSigBytes);\n                // Process blocks\n                if (nWordsReady) {\n                    for(var offset = 0; offset < nWordsReady; offset += blockSize)// Perform concrete-algorithm logic\n                    this._doProcessBlock(dataWords, offset);\n                    // Remove processed words\n                    processedWords = dataWords.splice(0, nWordsReady);\n                    data.sigBytes -= nBytesReady;\n                }\n                // Return processed words\n                return new WordArray.init(processedWords, nBytesReady);\n            },\n            /**\n\t         * Creates a copy of this object.\n\t         *\n\t         * @return {Object} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t         */ clone: function() {\n                var clone = Base.clone.call(this);\n                clone._data = this._data.clone();\n                return clone;\n            },\n            _minBufferSize: 0\n        });\n        /**\n\t     * Abstract hasher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t     */ var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n            /**\n\t         * Configuration options.\n\t         */ cfg: Base.extend(),\n            /**\n\t         * Initializes a newly created hasher.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t         */ init: function(cfg) {\n                // Apply config defaults\n                this.cfg = this.cfg.extend(cfg);\n                // Set initial values\n                this.reset();\n            },\n            /**\n\t         * Resets this hasher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.reset();\n\t         */ reset: function() {\n                // Reset data buffer\n                BufferedBlockAlgorithm.reset.call(this);\n                // Perform concrete-hasher logic\n                this._doReset();\n            },\n            /**\n\t         * Updates this hasher with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {Hasher} This hasher.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.update('message');\n\t         *     hasher.update(wordArray);\n\t         */ update: function(messageUpdate) {\n                // Append\n                this._append(messageUpdate);\n                // Update the hash\n                this._process();\n                // Chainable\n                return this;\n            },\n            /**\n\t         * Finalizes the hash computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The hash.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hash = hasher.finalize();\n\t         *     var hash = hasher.finalize('message');\n\t         *     var hash = hasher.finalize(wordArray);\n\t         */ finalize: function(messageUpdate) {\n                // Final message update\n                if (messageUpdate) this._append(messageUpdate);\n                // Perform concrete-hasher logic\n                var hash = this._doFinalize();\n                return hash;\n            },\n            blockSize: 16,\n            /**\n\t         * Creates a shortcut function to a hasher's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t         */ _createHelper: function(hasher) {\n                return function(message, cfg) {\n                    return new hasher.init(cfg).finalize(message);\n                };\n            },\n            /**\n\t         * Creates a shortcut function to the HMAC's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t         */ _createHmacHelper: function(hasher) {\n                return function(message, key) {\n                    return new C_algo.HMAC.init(hasher, key).finalize(message);\n                };\n            }\n        });\n        /**\n\t     * Algorithm namespace.\n\t     */ var C_algo = C.algo = {};\n        return C;\n    }(Math);\n    return CryptoJS;\n});\n\n});\nparcelRegister(\"kjyEk\", function(module, exports) {\n\"use strict\";\n\n});\n\n\nparcelRegister(\"dCBbD\", function(module, exports) {\n\n(function(root, factory) {\n    // CommonJS\n    module.exports = exports = factory((parcelRequire(\"3OBZa\")));\n})(this, function(CryptoJS) {\n    (function(Math1) {\n        // Shortcuts\n        var C = CryptoJS;\n        var C_lib = C.lib;\n        var WordArray = C_lib.WordArray;\n        var Hasher = C_lib.Hasher;\n        var C_algo = C.algo;\n        // Initialization and round constants tables\n        var H = [];\n        var K = [];\n        // Compute constants\n        (function() {\n            function isPrime(n) {\n                var sqrtN = Math1.sqrt(n);\n                for(var factor = 2; factor <= sqrtN; factor++){\n                    if (!(n % factor)) return false;\n                }\n                return true;\n            }\n            function getFractionalBits(n) {\n                return (n - (n | 0)) * 0x100000000 | 0;\n            }\n            var n = 2;\n            var nPrime = 0;\n            while(nPrime < 64){\n                if (isPrime(n)) {\n                    if (nPrime < 8) H[nPrime] = getFractionalBits(Math1.pow(n, 0.5));\n                    K[nPrime] = getFractionalBits(Math1.pow(n, 1 / 3));\n                    nPrime++;\n                }\n                n++;\n            }\n        })();\n        // Reusable object\n        var W = [];\n        /**\n\t     * SHA-256 hash algorithm.\n\t     */ var SHA256 = C_algo.SHA256 = Hasher.extend({\n            _doReset: function() {\n                this._hash = new WordArray.init(H.slice(0));\n            },\n            _doProcessBlock: function(M, offset) {\n                // Shortcut\n                var H = this._hash.words;\n                // Working variables\n                var a = H[0];\n                var b = H[1];\n                var c = H[2];\n                var d = H[3];\n                var e = H[4];\n                var f = H[5];\n                var g = H[6];\n                var h = H[7];\n                // Computation\n                for(var i = 0; i < 64; i++){\n                    if (i < 16) W[i] = M[offset + i] | 0;\n                    else {\n                        var gamma0x = W[i - 15];\n                        var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n                        var gamma1x = W[i - 2];\n                        var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n                        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n                    }\n                    var ch = e & f ^ ~e & g;\n                    var maj = a & b ^ a & c ^ b & c;\n                    var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n                    var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n                    var t1 = h + sigma1 + ch + K[i] + W[i];\n                    var t2 = sigma0 + maj;\n                    h = g;\n                    g = f;\n                    f = e;\n                    e = d + t1 | 0;\n                    d = c;\n                    c = b;\n                    b = a;\n                    a = t1 + t2 | 0;\n                }\n                // Intermediate hash value\n                H[0] = H[0] + a | 0;\n                H[1] = H[1] + b | 0;\n                H[2] = H[2] + c | 0;\n                H[3] = H[3] + d | 0;\n                H[4] = H[4] + e | 0;\n                H[5] = H[5] + f | 0;\n                H[6] = H[6] + g | 0;\n                H[7] = H[7] + h | 0;\n            },\n            _doFinalize: function() {\n                // Shortcuts\n                var data = this._data;\n                var dataWords = data.words;\n                var nBitsTotal = this._nDataBytes * 8;\n                var nBitsLeft = data.sigBytes * 8;\n                // Add padding\n                dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;\n                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math1.floor(nBitsTotal / 0x100000000);\n                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n                data.sigBytes = dataWords.length * 4;\n                // Hash final blocks\n                this._process();\n                // Return final computed hash\n                return this._hash;\n            },\n            clone: function() {\n                var clone = Hasher.clone.call(this);\n                clone._hash = this._hash.clone();\n                return clone;\n            }\n        });\n        /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA256('message');\n\t     *     var hash = CryptoJS.SHA256(wordArray);\n\t     */ C.SHA256 = Hasher._createHelper(SHA256);\n        /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\n\t     */ C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n    })(Math);\n    return CryptoJS.SHA256;\n});\n\n});\n\nparcelRegister(\"33Dov\", function(module, exports) {\n\n(function(root, factory) {\n    // CommonJS\n    module.exports = exports = factory((parcelRequire(\"3OBZa\")));\n})(this, function(CryptoJS) {\n    (function() {\n        // Shortcuts\n        var C = CryptoJS;\n        var C_lib = C.lib;\n        var WordArray = C_lib.WordArray;\n        var C_enc = C.enc;\n        /**\n\t     * Base64 encoding strategy.\n\t     */ var Base64 = C_enc.Base64 = {\n            /**\n\t         * Converts a word array to a Base64 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Base64 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);\n\t         */ stringify: function(wordArray) {\n                // Shortcuts\n                var words = wordArray.words;\n                var sigBytes = wordArray.sigBytes;\n                var map = this._map;\n                // Clamp excess bits\n                wordArray.clamp();\n                // Convert\n                var base64Chars = [];\n                for(var i = 0; i < sigBytes; i += 3){\n                    var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;\n                    var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 0xff;\n                    var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 0xff;\n                    var triplet = byte1 << 16 | byte2 << 8 | byte3;\n                    for(var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++)base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 0x3f));\n                }\n                // Add padding\n                var paddingChar = map.charAt(64);\n                if (paddingChar) while(base64Chars.length % 4)base64Chars.push(paddingChar);\n                return base64Chars.join('');\n            },\n            /**\n\t         * Converts a Base64 string to a word array.\n\t         *\n\t         * @param {string} base64Str The Base64 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);\n\t         */ parse: function(base64Str) {\n                // Shortcuts\n                var base64StrLength = base64Str.length;\n                var map = this._map;\n                var reverseMap = this._reverseMap;\n                if (!reverseMap) {\n                    reverseMap = this._reverseMap = [];\n                    for(var j = 0; j < map.length; j++)reverseMap[map.charCodeAt(j)] = j;\n                }\n                // Ignore padding\n                var paddingChar = map.charAt(64);\n                if (paddingChar) {\n                    var paddingIndex = base64Str.indexOf(paddingChar);\n                    if (paddingIndex !== -1) base64StrLength = paddingIndex;\n                }\n                // Convert\n                return parseLoop(base64Str, base64StrLength, reverseMap);\n            },\n            _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='\n        };\n        function parseLoop(base64Str, base64StrLength, reverseMap) {\n            var words = [];\n            var nBytes = 0;\n            for(var i = 0; i < base64StrLength; i++)if (i % 4) {\n                var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;\n                var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;\n                var bitsCombined = bits1 | bits2;\n                words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;\n                nBytes++;\n            }\n            return WordArray.create(words, nBytes);\n        }\n    })();\n    return CryptoJS.enc.Base64;\n});\n\n});\n\nparcelRegister(\"cpGza\", function(module, exports) {\n\n(function(root, factory) {\n    // CommonJS\n    module.exports = exports = factory((parcelRequire(\"3OBZa\")));\n})(this, function(CryptoJS) {\n    return CryptoJS.enc.Utf8;\n});\n\n});\n\nparcelRegister(\"2Eznr\", function(module, exports) {\n\n$parcel$defineInteropFlag(module.exports);\n\n$parcel$export(module.exports, \"InvalidTokenError\", () => $1eeac253570f845a$export$b9721ef022f71a68);\n$parcel$export(module.exports, \"default\", () => $1eeac253570f845a$export$2e2bcd8739ae039);\nfunction $1eeac253570f845a$var$e(e) {\n    this.message = e;\n}\n$1eeac253570f845a$var$e.prototype = new Error, $1eeac253570f845a$var$e.prototype.name = \"InvalidCharacterError\";\nvar $1eeac253570f845a$var$r = \"undefined\" != typeof window && window.atob && window.atob.bind(window) || function(r) {\n    var t = String(r).replace(/=+$/, \"\");\n    if (t.length % 4 == 1) throw new $1eeac253570f845a$var$e(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n    for(var n, o, a = 0, i = 0, c = \"\"; o = t.charAt(i++); ~o && (n = a % 4 ? 64 * n + o : o, a++ % 4) && (c += String.fromCharCode(255 & n >> (-2 * a & 6))))o = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(o);\n    return c;\n};\nfunction $1eeac253570f845a$var$t(e) {\n    var t = e.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch(t.length % 4){\n        case 0:\n            break;\n        case 2:\n            t += \"==\";\n            break;\n        case 3:\n            t += \"=\";\n            break;\n        default:\n            throw \"Illegal base64url string!\";\n    }\n    try {\n        return function(e) {\n            return decodeURIComponent($1eeac253570f845a$var$r(e).replace(/(.)/g, function(e, r) {\n                var t = r.charCodeAt(0).toString(16).toUpperCase();\n                return t.length < 2 && (t = \"0\" + t), \"%\" + t;\n            }));\n        }(t);\n    } catch (e) {\n        return $1eeac253570f845a$var$r(t);\n    }\n}\nfunction $1eeac253570f845a$export$b9721ef022f71a68(e) {\n    this.message = e;\n}\nfunction $1eeac253570f845a$var$o(e, r) {\n    if (\"string\" != typeof e) throw new $1eeac253570f845a$export$b9721ef022f71a68(\"Invalid token specified\");\n    var o = !0 === (r = r || {}).header ? 0 : 1;\n    try {\n        return JSON.parse($1eeac253570f845a$var$t(e.split(\".\")[o]));\n    } catch (e) {\n        throw new $1eeac253570f845a$export$b9721ef022f71a68(\"Invalid token specified: \" + e.message);\n    }\n}\n$1eeac253570f845a$export$b9721ef022f71a68.prototype = new Error, $1eeac253570f845a$export$b9721ef022f71a68.prototype.name = \"InvalidTokenError\";\nvar $1eeac253570f845a$export$2e2bcd8739ae039 = $1eeac253570f845a$var$o;\n\n});\n\nvar $631c75f8a3fcffe9$exports = {};\n\"use strict\";\nvar $631c75f8a3fcffe9$var$__create = Object.create;\nvar $631c75f8a3fcffe9$var$__defProp = Object.defineProperty;\nvar $631c75f8a3fcffe9$var$__getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar $631c75f8a3fcffe9$var$__getOwnPropNames = Object.getOwnPropertyNames;\nvar $631c75f8a3fcffe9$var$__getProtoOf = Object.getPrototypeOf;\nvar $631c75f8a3fcffe9$var$__hasOwnProp = Object.prototype.hasOwnProperty;\nvar $631c75f8a3fcffe9$var$__export = (target, all)=>{\n    for(var name in all)$631c75f8a3fcffe9$var$__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar $631c75f8a3fcffe9$var$__copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of $631c75f8a3fcffe9$var$__getOwnPropNames(from))if (!$631c75f8a3fcffe9$var$__hasOwnProp.call(to, key) && key !== except) $631c75f8a3fcffe9$var$__defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = $631c75f8a3fcffe9$var$__getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar $631c75f8a3fcffe9$var$__toESM = (mod, isNodeMode, target)=>(target = mod != null ? $631c75f8a3fcffe9$var$__create($631c75f8a3fcffe9$var$__getProtoOf(mod)) : {}, $631c75f8a3fcffe9$var$__copyProps(// If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? $631c75f8a3fcffe9$var$__defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\nvar $631c75f8a3fcffe9$var$__toCommonJS = (mod)=>$631c75f8a3fcffe9$var$__copyProps($631c75f8a3fcffe9$var$__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\n// src/index.ts\nvar $631c75f8a3fcffe9$var$src_exports = {};\n$631c75f8a3fcffe9$var$__export($631c75f8a3fcffe9$var$src_exports, {\n    AccessTokenEvents: ()=>$631c75f8a3fcffe9$var$AccessTokenEvents,\n    CheckSessionIFrame: ()=>$631c75f8a3fcffe9$var$CheckSessionIFrame,\n    ErrorResponse: ()=>$631c75f8a3fcffe9$var$ErrorResponse,\n    ErrorTimeout: ()=>$631c75f8a3fcffe9$var$ErrorTimeout,\n    InMemoryWebStorage: ()=>$631c75f8a3fcffe9$var$InMemoryWebStorage,\n    Log: ()=>$631c75f8a3fcffe9$var$Log,\n    Logger: ()=>$631c75f8a3fcffe9$var$Logger,\n    MetadataService: ()=>$631c75f8a3fcffe9$var$MetadataService,\n    OidcClient: ()=>$631c75f8a3fcffe9$var$OidcClient,\n    OidcClientSettingsStore: ()=>$631c75f8a3fcffe9$var$OidcClientSettingsStore,\n    SessionMonitor: ()=>$631c75f8a3fcffe9$var$SessionMonitor,\n    SigninResponse: ()=>$631c75f8a3fcffe9$var$SigninResponse,\n    SigninState: ()=>$631c75f8a3fcffe9$var$SigninState,\n    SignoutResponse: ()=>$631c75f8a3fcffe9$var$SignoutResponse,\n    State: ()=>$631c75f8a3fcffe9$var$State,\n    User: ()=>$631c75f8a3fcffe9$var$User,\n    UserManager: ()=>$631c75f8a3fcffe9$var$UserManager,\n    UserManagerSettingsStore: ()=>$631c75f8a3fcffe9$var$UserManagerSettingsStore,\n    Version: ()=>$631c75f8a3fcffe9$var$Version,\n    WebStorageStateStore: ()=>$631c75f8a3fcffe9$var$WebStorageStateStore\n});\n$631c75f8a3fcffe9$exports = $631c75f8a3fcffe9$var$__toCommonJS($631c75f8a3fcffe9$var$src_exports);\n\n// src/utils/CryptoUtils.ts\nvar $631c75f8a3fcffe9$var$import_core = $631c75f8a3fcffe9$var$__toESM((parcelRequire(\"3OBZa\")));\n\nvar $631c75f8a3fcffe9$var$import_sha256 = $631c75f8a3fcffe9$var$__toESM((parcelRequire(\"dCBbD\")));\n\nvar $631c75f8a3fcffe9$var$import_enc_base64 = $631c75f8a3fcffe9$var$__toESM((parcelRequire(\"33Dov\")));\n\nvar $631c75f8a3fcffe9$var$import_enc_utf8 = $631c75f8a3fcffe9$var$__toESM((parcelRequire(\"cpGza\")));\n// src/utils/Logger.ts\nvar $631c75f8a3fcffe9$var$nopLogger = {\n    debug: ()=>void 0,\n    info: ()=>void 0,\n    warn: ()=>void 0,\n    error: ()=>void 0\n};\nvar $631c75f8a3fcffe9$var$level;\nvar $631c75f8a3fcffe9$var$logger;\nvar $631c75f8a3fcffe9$var$Log = /* @__PURE__ */ ((Log2)=>{\n    Log2[Log2[\"NONE\"] = 0] = \"NONE\";\n    Log2[Log2[\"ERROR\"] = 1] = \"ERROR\";\n    Log2[Log2[\"WARN\"] = 2] = \"WARN\";\n    Log2[Log2[\"INFO\"] = 3] = \"INFO\";\n    Log2[Log2[\"DEBUG\"] = 4] = \"DEBUG\";\n    return Log2;\n})($631c75f8a3fcffe9$var$Log || {});\n((Log2)=>{\n    function reset() {\n        $631c75f8a3fcffe9$var$level = 3 /* INFO */ ;\n        $631c75f8a3fcffe9$var$logger = $631c75f8a3fcffe9$var$nopLogger;\n    }\n    Log2.reset = reset;\n    function setLevel(value) {\n        if (!(0 /* NONE */  <= value && value <= 4 /* DEBUG */ )) throw new Error(\"Invalid log level\");\n        $631c75f8a3fcffe9$var$level = value;\n    }\n    Log2.setLevel = setLevel;\n    function setLogger(value) {\n        $631c75f8a3fcffe9$var$logger = value;\n    }\n    Log2.setLogger = setLogger;\n})($631c75f8a3fcffe9$var$Log || ($631c75f8a3fcffe9$var$Log = {}));\nvar $631c75f8a3fcffe9$var$Logger = class {\n    constructor(_name){\n        this._name = _name;\n    }\n    /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */ debug(...args) {\n        if ($631c75f8a3fcffe9$var$level >= 4 /* DEBUG */ ) $631c75f8a3fcffe9$var$logger.debug($631c75f8a3fcffe9$var$Logger._format(this._name, this._method), ...args);\n    }\n    info(...args) {\n        if ($631c75f8a3fcffe9$var$level >= 3 /* INFO */ ) $631c75f8a3fcffe9$var$logger.info($631c75f8a3fcffe9$var$Logger._format(this._name, this._method), ...args);\n    }\n    warn(...args) {\n        if ($631c75f8a3fcffe9$var$level >= 2 /* WARN */ ) $631c75f8a3fcffe9$var$logger.warn($631c75f8a3fcffe9$var$Logger._format(this._name, this._method), ...args);\n    }\n    error(...args) {\n        if ($631c75f8a3fcffe9$var$level >= 1 /* ERROR */ ) $631c75f8a3fcffe9$var$logger.error($631c75f8a3fcffe9$var$Logger._format(this._name, this._method), ...args);\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */ throw(err) {\n        this.error(err);\n        throw err;\n    }\n    create(method) {\n        const methodLogger = Object.create(this);\n        methodLogger._method = method;\n        methodLogger.debug(\"begin\");\n        return methodLogger;\n    }\n    static createStatic(name, staticMethod) {\n        const staticLogger = new $631c75f8a3fcffe9$var$Logger(`${name}.${staticMethod}`);\n        staticLogger.debug(\"begin\");\n        return staticLogger;\n    }\n    static _format(name, method) {\n        const prefix = `[${name}]`;\n        return method ? `${prefix} ${method}:` : prefix;\n    }\n    /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */ // helpers for static class methods\n    static debug(name, ...args) {\n        if ($631c75f8a3fcffe9$var$level >= 4 /* DEBUG */ ) $631c75f8a3fcffe9$var$logger.debug($631c75f8a3fcffe9$var$Logger._format(name), ...args);\n    }\n    static info(name, ...args) {\n        if ($631c75f8a3fcffe9$var$level >= 3 /* INFO */ ) $631c75f8a3fcffe9$var$logger.info($631c75f8a3fcffe9$var$Logger._format(name), ...args);\n    }\n    static warn(name, ...args) {\n        if ($631c75f8a3fcffe9$var$level >= 2 /* WARN */ ) $631c75f8a3fcffe9$var$logger.warn($631c75f8a3fcffe9$var$Logger._format(name), ...args);\n    }\n    static error(name, ...args) {\n        if ($631c75f8a3fcffe9$var$level >= 1 /* ERROR */ ) $631c75f8a3fcffe9$var$logger.error($631c75f8a3fcffe9$var$Logger._format(name), ...args);\n    }\n};\n$631c75f8a3fcffe9$var$Log.reset();\n// src/utils/CryptoUtils.ts\nvar $631c75f8a3fcffe9$var$UUID_V4_TEMPLATE = \"10000000-1000-4000-8000-100000000000\";\nvar $631c75f8a3fcffe9$var$CryptoUtils = class {\n    static _randomWord() {\n        return $631c75f8a3fcffe9$var$import_core.default.lib.WordArray.random(1).words[0];\n    }\n    /**\n   * Generates RFC4122 version 4 guid\n   */ static generateUUIDv4() {\n        const uuid = $631c75f8a3fcffe9$var$UUID_V4_TEMPLATE.replace(/[018]/g, (c)=>(+c ^ $631c75f8a3fcffe9$var$CryptoUtils._randomWord() & 15 >> +c / 4).toString(16));\n        return uuid.replace(/-/g, \"\");\n    }\n    /**\n   * PKCE: Generate a code verifier\n   */ static generateCodeVerifier() {\n        return $631c75f8a3fcffe9$var$CryptoUtils.generateUUIDv4() + $631c75f8a3fcffe9$var$CryptoUtils.generateUUIDv4() + $631c75f8a3fcffe9$var$CryptoUtils.generateUUIDv4();\n    }\n    /**\n   * PKCE: Generate a code challenge\n   */ static generateCodeChallenge(code_verifier) {\n        try {\n            const hashed = (0, $631c75f8a3fcffe9$var$import_sha256.default)(code_verifier);\n            return $631c75f8a3fcffe9$var$import_enc_base64.default.stringify(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n        } catch (err) {\n            $631c75f8a3fcffe9$var$Logger.error(\"CryptoUtils.generateCodeChallenge\", err);\n            throw err;\n        }\n    }\n    /**\n   * Generates a base64-encoded string for a basic auth header\n   */ static generateBasicAuth(client_id, client_secret) {\n        const basicAuth = $631c75f8a3fcffe9$var$import_enc_utf8.default.parse([\n            client_id,\n            client_secret\n        ].join(\":\"));\n        return $631c75f8a3fcffe9$var$import_enc_base64.default.stringify(basicAuth);\n    }\n};\n// src/utils/Event.ts\nvar $631c75f8a3fcffe9$var$Event = class {\n    constructor(_name){\n        this._name = _name;\n        this._logger = new $631c75f8a3fcffe9$var$Logger(`Event('${this._name}')`);\n        this._callbacks = [];\n    }\n    addHandler(cb) {\n        this._callbacks.push(cb);\n        return ()=>this.removeHandler(cb);\n    }\n    removeHandler(cb) {\n        const idx = this._callbacks.lastIndexOf(cb);\n        if (idx >= 0) this._callbacks.splice(idx, 1);\n    }\n    raise(...ev) {\n        this._logger.debug(\"raise:\", ...ev);\n        for (const cb of this._callbacks)cb(...ev);\n    }\n};\n\n// src/utils/JwtUtils.ts\nvar $631c75f8a3fcffe9$var$import_jwt_decode = $631c75f8a3fcffe9$var$__toESM((parcelRequire(\"2Eznr\")));\nvar $631c75f8a3fcffe9$var$JwtUtils = class {\n    // IMPORTANT: doesn't validate the token\n    static decode(token) {\n        try {\n            return (0, $631c75f8a3fcffe9$var$import_jwt_decode.default)(token);\n        } catch (err) {\n            $631c75f8a3fcffe9$var$Logger.error(\"JwtUtils.decode\", err);\n            throw err;\n        }\n    }\n};\n// src/utils/PopupUtils.ts\nvar $631c75f8a3fcffe9$var$PopupUtils = class {\n    /**\n   * Populates a map of window features with a placement centered in front of\n   * the current window. If no explicit width is given, a default value is\n   * binned into [800, 720, 600, 480, 360] based on the current window's width.\n   */ static center({ ...features }) {\n        var _a, _b, _c;\n        if (features.width == null) features.width = (_a = [\n            800,\n            720,\n            600,\n            480\n        ].find((width)=>width <= window.outerWidth / 1.618)) != null ? _a : 360;\n        (_b = features.left) != null ? _b : features.left = Math.max(0, Math.round(window.screenX + (window.outerWidth - features.width) / 2));\n        if (features.height != null) (_c = features.top) != null ? _c : features.top = Math.max(0, Math.round(window.screenY + (window.outerHeight - features.height) / 2));\n        return features;\n    }\n    static serialize(features) {\n        return Object.entries(features).filter(([, value])=>value != null).map(([key, value])=>`${key}=${typeof value !== \"boolean\" ? value : value ? \"yes\" : \"no\"}`).join(\",\");\n    }\n};\n// src/utils/Timer.ts\nvar $631c75f8a3fcffe9$var$Timer = class extends $631c75f8a3fcffe9$var$Event {\n    constructor(){\n        super(...arguments);\n        this._logger = new $631c75f8a3fcffe9$var$Logger(`Timer('${this._name}')`);\n        this._timerHandle = null;\n        this._expiration = 0;\n        this._callback = ()=>{\n            const diff = this._expiration - $631c75f8a3fcffe9$var$Timer.getEpochTime();\n            this._logger.debug(\"timer completes in\", diff);\n            if (this._expiration <= $631c75f8a3fcffe9$var$Timer.getEpochTime()) {\n                this.cancel();\n                super.raise();\n            }\n        };\n    }\n    // get the time\n    static getEpochTime() {\n        return Math.floor(Date.now() / 1e3);\n    }\n    init(durationInSeconds) {\n        const logger2 = this._logger.create(\"init\");\n        durationInSeconds = Math.max(Math.floor(durationInSeconds), 1);\n        const expiration = $631c75f8a3fcffe9$var$Timer.getEpochTime() + durationInSeconds;\n        if (this.expiration === expiration && this._timerHandle) {\n            logger2.debug(\"skipping since already initialized for expiration at\", this.expiration);\n            return;\n        }\n        this.cancel();\n        logger2.debug(\"using duration\", durationInSeconds);\n        this._expiration = expiration;\n        const timerDurationInSeconds = Math.min(durationInSeconds, 5);\n        this._timerHandle = setInterval(this._callback, timerDurationInSeconds * 1e3);\n    }\n    get expiration() {\n        return this._expiration;\n    }\n    cancel() {\n        this._logger.create(\"cancel\");\n        if (this._timerHandle) {\n            clearInterval(this._timerHandle);\n            this._timerHandle = null;\n        }\n    }\n};\n// src/utils/UrlUtils.ts\nvar $631c75f8a3fcffe9$var$UrlUtils = class {\n    static readParams(url, responseMode = \"query\") {\n        if (!url) throw new TypeError(\"Invalid URL\");\n        const parsedUrl = new URL(url, \"http://127.0.0.1\");\n        const params = parsedUrl[responseMode === \"fragment\" ? \"hash\" : \"search\"];\n        return new URLSearchParams(params.slice(1));\n    }\n};\nvar $631c75f8a3fcffe9$var$URL_STATE_DELIMITER = \";\";\n// src/errors/ErrorResponse.ts\nvar $631c75f8a3fcffe9$var$ErrorResponse = class extends Error {\n    constructor(args, form){\n        var _a, _b, _c;\n        super(args.error_description || args.error || \"\");\n        this.form = form;\n        /** Marker to detect class: \"ErrorResponse\" */ this.name = \"ErrorResponse\";\n        if (!args.error) {\n            $631c75f8a3fcffe9$var$Logger.error(\"ErrorResponse\", \"No error passed\");\n            throw new Error(\"No error passed\");\n        }\n        this.error = args.error;\n        this.error_description = (_a = args.error_description) != null ? _a : null;\n        this.error_uri = (_b = args.error_uri) != null ? _b : null;\n        this.state = args.userState;\n        this.session_state = (_c = args.session_state) != null ? _c : null;\n        this.url_state = args.url_state;\n    }\n};\n// src/errors/ErrorTimeout.ts\nvar $631c75f8a3fcffe9$var$ErrorTimeout = class extends Error {\n    constructor(message){\n        super(message);\n        /** Marker to detect class: \"ErrorTimeout\" */ this.name = \"ErrorTimeout\";\n    }\n};\n// src/AccessTokenEvents.ts\nvar $631c75f8a3fcffe9$var$AccessTokenEvents = class {\n    constructor(args){\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"AccessTokenEvents\");\n        this._expiringTimer = new $631c75f8a3fcffe9$var$Timer(\"Access token expiring\");\n        this._expiredTimer = new $631c75f8a3fcffe9$var$Timer(\"Access token expired\");\n        this._expiringNotificationTimeInSeconds = args.expiringNotificationTimeInSeconds;\n    }\n    load(container) {\n        const logger2 = this._logger.create(\"load\");\n        if (container.access_token && container.expires_in !== void 0) {\n            const duration = container.expires_in;\n            logger2.debug(\"access token present, remaining duration:\", duration);\n            if (duration > 0) {\n                let expiring = duration - this._expiringNotificationTimeInSeconds;\n                if (expiring <= 0) expiring = 1;\n                logger2.debug(\"registering expiring timer, raising in\", expiring, \"seconds\");\n                this._expiringTimer.init(expiring);\n            } else {\n                logger2.debug(\"canceling existing expiring timer because we're past expiration.\");\n                this._expiringTimer.cancel();\n            }\n            const expired = duration + 1;\n            logger2.debug(\"registering expired timer, raising in\", expired, \"seconds\");\n            this._expiredTimer.init(expired);\n        } else {\n            this._expiringTimer.cancel();\n            this._expiredTimer.cancel();\n        }\n    }\n    unload() {\n        this._logger.debug(\"unload: canceling existing access token timers\");\n        this._expiringTimer.cancel();\n        this._expiredTimer.cancel();\n    }\n    /**\n   * Add callback: Raised prior to the access token expiring.\n   */ addAccessTokenExpiring(cb) {\n        return this._expiringTimer.addHandler(cb);\n    }\n    /**\n   * Remove callback: Raised prior to the access token expiring.\n   */ removeAccessTokenExpiring(cb) {\n        this._expiringTimer.removeHandler(cb);\n    }\n    /**\n   * Add callback: Raised after the access token has expired.\n   */ addAccessTokenExpired(cb) {\n        return this._expiredTimer.addHandler(cb);\n    }\n    /**\n   * Remove callback: Raised after the access token has expired.\n   */ removeAccessTokenExpired(cb) {\n        this._expiredTimer.removeHandler(cb);\n    }\n};\n// src/CheckSessionIFrame.ts\nvar $631c75f8a3fcffe9$var$CheckSessionIFrame = class {\n    constructor(_callback, _client_id, url, _intervalInSeconds, _stopOnError){\n        this._callback = _callback;\n        this._client_id = _client_id;\n        this._intervalInSeconds = _intervalInSeconds;\n        this._stopOnError = _stopOnError;\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"CheckSessionIFrame\");\n        this._timer = null;\n        this._session_state = null;\n        this._message = (e)=>{\n            if (e.origin === this._frame_origin && e.source === this._frame.contentWindow) {\n                if (e.data === \"error\") {\n                    this._logger.error(\"error message from check session op iframe\");\n                    if (this._stopOnError) this.stop();\n                } else if (e.data === \"changed\") {\n                    this._logger.debug(\"changed message from check session op iframe\");\n                    this.stop();\n                    this._callback();\n                } else this._logger.debug(e.data + \" message from check session op iframe\");\n            }\n        };\n        const parsedUrl = new URL(url);\n        this._frame_origin = parsedUrl.origin;\n        this._frame = window.document.createElement(\"iframe\");\n        this._frame.style.visibility = \"hidden\";\n        this._frame.style.position = \"fixed\";\n        this._frame.style.left = \"-1000px\";\n        this._frame.style.top = \"0\";\n        this._frame.width = \"0\";\n        this._frame.height = \"0\";\n        this._frame.src = parsedUrl.href;\n    }\n    load() {\n        return new Promise((resolve)=>{\n            this._frame.onload = ()=>{\n                resolve();\n            };\n            window.document.body.appendChild(this._frame);\n            window.addEventListener(\"message\", this._message, false);\n        });\n    }\n    start(session_state) {\n        if (this._session_state === session_state) return;\n        this._logger.create(\"start\");\n        this.stop();\n        this._session_state = session_state;\n        const send = ()=>{\n            if (!this._frame.contentWindow || !this._session_state) return;\n            this._frame.contentWindow.postMessage(this._client_id + \" \" + this._session_state, this._frame_origin);\n        };\n        send();\n        this._timer = setInterval(send, this._intervalInSeconds * 1e3);\n    }\n    stop() {\n        this._logger.create(\"stop\");\n        this._session_state = null;\n        if (this._timer) {\n            clearInterval(this._timer);\n            this._timer = null;\n        }\n    }\n};\n// src/InMemoryWebStorage.ts\nvar $631c75f8a3fcffe9$var$InMemoryWebStorage = class {\n    constructor(){\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"InMemoryWebStorage\");\n        this._data = {};\n    }\n    clear() {\n        this._logger.create(\"clear\");\n        this._data = {};\n    }\n    getItem(key) {\n        this._logger.create(`getItem('${key}')`);\n        return this._data[key];\n    }\n    setItem(key, value) {\n        this._logger.create(`setItem('${key}')`);\n        this._data[key] = value;\n    }\n    removeItem(key) {\n        this._logger.create(`removeItem('${key}')`);\n        delete this._data[key];\n    }\n    get length() {\n        return Object.getOwnPropertyNames(this._data).length;\n    }\n    key(index) {\n        return Object.getOwnPropertyNames(this._data)[index];\n    }\n};\n// src/JsonService.ts\nvar $631c75f8a3fcffe9$var$JsonService = class {\n    constructor(additionalContentTypes = [], _jwtHandler = null, _extraHeaders = {}){\n        this._jwtHandler = _jwtHandler;\n        this._extraHeaders = _extraHeaders;\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"JsonService\");\n        this._contentTypes = [];\n        this._contentTypes.push(...additionalContentTypes, \"application/json\");\n        if (_jwtHandler) this._contentTypes.push(\"application/jwt\");\n    }\n    async fetchWithTimeout(input, init = {}) {\n        const { timeoutInSeconds: timeoutInSeconds, ...initFetch } = init;\n        if (!timeoutInSeconds) return await fetch(input, initFetch);\n        const controller = new AbortController();\n        const timeoutId = setTimeout(()=>controller.abort(), timeoutInSeconds * 1e3);\n        try {\n            const response = await fetch(input, {\n                ...init,\n                signal: controller.signal\n            });\n            return response;\n        } catch (err) {\n            if (err instanceof DOMException && err.name === \"AbortError\") throw new $631c75f8a3fcffe9$var$ErrorTimeout(\"Network timed out\");\n            throw err;\n        } finally{\n            clearTimeout(timeoutId);\n        }\n    }\n    async getJson(url, { token: token, credentials: credentials } = {}) {\n        const logger2 = this._logger.create(\"getJson\");\n        const headers = {\n            \"Accept\": this._contentTypes.join(\", \")\n        };\n        if (token) {\n            logger2.debug(\"token passed, setting Authorization header\");\n            headers[\"Authorization\"] = \"Bearer \" + token;\n        }\n        this.appendExtraHeaders(headers);\n        let response;\n        try {\n            logger2.debug(\"url:\", url);\n            response = await this.fetchWithTimeout(url, {\n                method: \"GET\",\n                headers: headers,\n                credentials: credentials\n            });\n        } catch (err) {\n            logger2.error(\"Network Error\");\n            throw err;\n        }\n        logger2.debug(\"HTTP response received, status\", response.status);\n        const contentType = response.headers.get(\"Content-Type\");\n        if (contentType && !this._contentTypes.find((item)=>contentType.startsWith(item))) logger2.throw(new Error(`Invalid response Content-Type: ${contentType != null ? contentType : \"undefined\"}, from URL: ${url}`));\n        if (response.ok && this._jwtHandler && (contentType == null ? void 0 : contentType.startsWith(\"application/jwt\"))) return await this._jwtHandler(await response.text());\n        let json;\n        try {\n            json = await response.json();\n        } catch (err) {\n            logger2.error(\"Error parsing JSON response\", err);\n            if (response.ok) throw err;\n            throw new Error(`${response.statusText} (${response.status})`);\n        }\n        if (!response.ok) {\n            logger2.error(\"Error from server:\", json);\n            if (json.error) throw new $631c75f8a3fcffe9$var$ErrorResponse(json);\n            throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n        }\n        return json;\n    }\n    async postForm(url, { body: body, basicAuth: basicAuth, timeoutInSeconds: timeoutInSeconds, initCredentials: initCredentials }) {\n        const logger2 = this._logger.create(\"postForm\");\n        const headers = {\n            \"Accept\": this._contentTypes.join(\", \"),\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        };\n        if (basicAuth !== void 0) headers[\"Authorization\"] = \"Basic \" + basicAuth;\n        this.appendExtraHeaders(headers);\n        let response;\n        try {\n            logger2.debug(\"url:\", url);\n            response = await this.fetchWithTimeout(url, {\n                method: \"POST\",\n                headers: headers,\n                body: body,\n                timeoutInSeconds: timeoutInSeconds,\n                credentials: initCredentials\n            });\n        } catch (err) {\n            logger2.error(\"Network error\");\n            throw err;\n        }\n        logger2.debug(\"HTTP response received, status\", response.status);\n        const contentType = response.headers.get(\"Content-Type\");\n        if (contentType && !this._contentTypes.find((item)=>contentType.startsWith(item))) throw new Error(`Invalid response Content-Type: ${contentType != null ? contentType : \"undefined\"}, from URL: ${url}`);\n        const responseText = await response.text();\n        let json = {};\n        if (responseText) try {\n            json = JSON.parse(responseText);\n        } catch (err) {\n            logger2.error(\"Error parsing JSON response\", err);\n            if (response.ok) throw err;\n            throw new Error(`${response.statusText} (${response.status})`);\n        }\n        if (!response.ok) {\n            logger2.error(\"Error from server:\", json);\n            if (json.error) throw new $631c75f8a3fcffe9$var$ErrorResponse(json, body);\n            throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n        }\n        return json;\n    }\n    appendExtraHeaders(headers) {\n        const logger2 = this._logger.create(\"appendExtraHeaders\");\n        const customKeys = Object.keys(this._extraHeaders);\n        const protectedHeaders = [\n            \"authorization\",\n            \"accept\",\n            \"content-type\"\n        ];\n        if (customKeys.length === 0) return;\n        customKeys.forEach((headerName)=>{\n            if (protectedHeaders.includes(headerName.toLocaleLowerCase())) {\n                logger2.warn(\"Protected header could not be overridden\", headerName, protectedHeaders);\n                return;\n            }\n            const content = typeof this._extraHeaders[headerName] === \"function\" ? this._extraHeaders[headerName]() : this._extraHeaders[headerName];\n            if (content && content !== \"\") headers[headerName] = content;\n        });\n    }\n};\n// src/MetadataService.ts\nvar $631c75f8a3fcffe9$var$MetadataService = class {\n    constructor(_settings){\n        this._settings = _settings;\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"MetadataService\");\n        this._signingKeys = null;\n        this._metadata = null;\n        this._metadataUrl = this._settings.metadataUrl;\n        this._jsonService = new $631c75f8a3fcffe9$var$JsonService([\n            \"application/jwk-set+json\"\n        ], null, this._settings.extraHeaders);\n        if (this._settings.signingKeys) {\n            this._logger.debug(\"using signingKeys from settings\");\n            this._signingKeys = this._settings.signingKeys;\n        }\n        if (this._settings.metadata) {\n            this._logger.debug(\"using metadata from settings\");\n            this._metadata = this._settings.metadata;\n        }\n        if (this._settings.fetchRequestCredentials) {\n            this._logger.debug(\"using fetchRequestCredentials from settings\");\n            this._fetchRequestCredentials = this._settings.fetchRequestCredentials;\n        }\n    }\n    resetSigningKeys() {\n        this._signingKeys = null;\n    }\n    async getMetadata() {\n        const logger2 = this._logger.create(\"getMetadata\");\n        if (this._metadata) {\n            logger2.debug(\"using cached values\");\n            return this._metadata;\n        }\n        if (!this._metadataUrl) {\n            logger2.throw(new Error(\"No authority or metadataUrl configured on settings\"));\n            throw null;\n        }\n        logger2.debug(\"getting metadata from\", this._metadataUrl);\n        const metadata = await this._jsonService.getJson(this._metadataUrl, {\n            credentials: this._fetchRequestCredentials\n        });\n        logger2.debug(\"merging remote JSON with seed metadata\");\n        this._metadata = Object.assign({}, this._settings.metadataSeed, metadata);\n        return this._metadata;\n    }\n    getIssuer() {\n        return this._getMetadataProperty(\"issuer\");\n    }\n    getAuthorizationEndpoint() {\n        return this._getMetadataProperty(\"authorization_endpoint\");\n    }\n    getUserInfoEndpoint() {\n        return this._getMetadataProperty(\"userinfo_endpoint\");\n    }\n    getTokenEndpoint(optional = true) {\n        return this._getMetadataProperty(\"token_endpoint\", optional);\n    }\n    getCheckSessionIframe() {\n        return this._getMetadataProperty(\"check_session_iframe\", true);\n    }\n    getEndSessionEndpoint() {\n        return this._getMetadataProperty(\"end_session_endpoint\", true);\n    }\n    getRevocationEndpoint(optional = true) {\n        return this._getMetadataProperty(\"revocation_endpoint\", optional);\n    }\n    getKeysEndpoint(optional = true) {\n        return this._getMetadataProperty(\"jwks_uri\", optional);\n    }\n    async _getMetadataProperty(name, optional = false) {\n        const logger2 = this._logger.create(`_getMetadataProperty('${name}')`);\n        const metadata = await this.getMetadata();\n        logger2.debug(\"resolved\");\n        if (metadata[name] === void 0) {\n            if (optional === true) {\n                logger2.warn(\"Metadata does not contain optional property\");\n                return void 0;\n            }\n            logger2.throw(new Error(\"Metadata does not contain property \" + name));\n        }\n        return metadata[name];\n    }\n    async getSigningKeys() {\n        const logger2 = this._logger.create(\"getSigningKeys\");\n        if (this._signingKeys) {\n            logger2.debug(\"returning signingKeys from cache\");\n            return this._signingKeys;\n        }\n        const jwks_uri = await this.getKeysEndpoint(false);\n        logger2.debug(\"got jwks_uri\", jwks_uri);\n        const keySet = await this._jsonService.getJson(jwks_uri);\n        logger2.debug(\"got key set\", keySet);\n        if (!Array.isArray(keySet.keys)) {\n            logger2.throw(new Error(\"Missing keys on keyset\"));\n            throw null;\n        }\n        this._signingKeys = keySet.keys;\n        return this._signingKeys;\n    }\n};\n// src/WebStorageStateStore.ts\nvar $631c75f8a3fcffe9$var$WebStorageStateStore = class {\n    constructor({ prefix: prefix = \"oidc.\", store: store = localStorage } = {}){\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"WebStorageStateStore\");\n        this._store = store;\n        this._prefix = prefix;\n    }\n    async set(key, value) {\n        this._logger.create(`set('${key}')`);\n        key = this._prefix + key;\n        await this._store.setItem(key, value);\n    }\n    async get(key) {\n        this._logger.create(`get('${key}')`);\n        key = this._prefix + key;\n        const item = await this._store.getItem(key);\n        return item;\n    }\n    async remove(key) {\n        this._logger.create(`remove('${key}')`);\n        key = this._prefix + key;\n        const item = await this._store.getItem(key);\n        await this._store.removeItem(key);\n        return item;\n    }\n    async getAllKeys() {\n        this._logger.create(\"getAllKeys\");\n        const len = await this._store.length;\n        const keys = [];\n        for(let index = 0; index < len; index++){\n            const key = await this._store.key(index);\n            if (key && key.indexOf(this._prefix) === 0) keys.push(key.substr(this._prefix.length));\n        }\n        return keys;\n    }\n};\n// src/OidcClientSettings.ts\nvar $631c75f8a3fcffe9$var$DefaultResponseType = \"code\";\nvar $631c75f8a3fcffe9$var$DefaultScope = \"openid\";\nvar $631c75f8a3fcffe9$var$DefaultClientAuthentication = \"client_secret_post\";\nvar $631c75f8a3fcffe9$var$DefaultResponseMode = \"query\";\nvar $631c75f8a3fcffe9$var$DefaultStaleStateAgeInSeconds = 900;\nvar $631c75f8a3fcffe9$var$DefaultClockSkewInSeconds = 300;\nvar $631c75f8a3fcffe9$var$OidcClientSettingsStore = class {\n    constructor({ authority: // metadata related\n    authority, metadataUrl: metadataUrl, metadata: metadata, signingKeys: signingKeys, metadataSeed: metadataSeed, client_id: // client related\n    client_id, client_secret: client_secret, response_type: response_type = $631c75f8a3fcffe9$var$DefaultResponseType, scope: scope = $631c75f8a3fcffe9$var$DefaultScope, redirect_uri: redirect_uri, post_logout_redirect_uri: post_logout_redirect_uri, client_authentication: client_authentication = $631c75f8a3fcffe9$var$DefaultClientAuthentication, prompt: // optional protocol\n    prompt, display: display, max_age: max_age, ui_locales: ui_locales, acr_values: acr_values, resource: resource, response_mode: response_mode = $631c75f8a3fcffe9$var$DefaultResponseMode, filterProtocolClaims: // behavior flags\n    filterProtocolClaims = true, loadUserInfo: loadUserInfo = false, staleStateAgeInSeconds: staleStateAgeInSeconds = $631c75f8a3fcffe9$var$DefaultStaleStateAgeInSeconds, clockSkewInSeconds: clockSkewInSeconds = $631c75f8a3fcffe9$var$DefaultClockSkewInSeconds, userInfoJwtIssuer: userInfoJwtIssuer = \"OP\", mergeClaims: mergeClaims = false, disablePKCE: disablePKCE = false, stateStore: // other behavior\n    stateStore, refreshTokenCredentials: refreshTokenCredentials, revokeTokenAdditionalContentTypes: revokeTokenAdditionalContentTypes, fetchRequestCredentials: fetchRequestCredentials, refreshTokenAllowedScope: refreshTokenAllowedScope, extraQueryParams: // extra\n    extraQueryParams = {}, extraTokenParams: extraTokenParams = {}, extraHeaders: extraHeaders = {} }){\n        this.authority = authority;\n        if (metadataUrl) this.metadataUrl = metadataUrl;\n        else {\n            this.metadataUrl = authority;\n            if (authority) {\n                if (!this.metadataUrl.endsWith(\"/\")) this.metadataUrl += \"/\";\n                this.metadataUrl += \".well-known/openid-configuration\";\n            }\n        }\n        this.metadata = metadata;\n        this.metadataSeed = metadataSeed;\n        this.signingKeys = signingKeys;\n        this.client_id = client_id;\n        this.client_secret = client_secret;\n        this.response_type = response_type;\n        this.scope = scope;\n        this.redirect_uri = redirect_uri;\n        this.post_logout_redirect_uri = post_logout_redirect_uri;\n        this.client_authentication = client_authentication;\n        this.prompt = prompt;\n        this.display = display;\n        this.max_age = max_age;\n        this.ui_locales = ui_locales;\n        this.acr_values = acr_values;\n        this.resource = resource;\n        this.response_mode = response_mode;\n        this.filterProtocolClaims = filterProtocolClaims != null ? filterProtocolClaims : true;\n        this.loadUserInfo = !!loadUserInfo;\n        this.staleStateAgeInSeconds = staleStateAgeInSeconds;\n        this.clockSkewInSeconds = clockSkewInSeconds;\n        this.userInfoJwtIssuer = userInfoJwtIssuer;\n        this.mergeClaims = !!mergeClaims;\n        this.disablePKCE = !!disablePKCE;\n        this.revokeTokenAdditionalContentTypes = revokeTokenAdditionalContentTypes;\n        if (fetchRequestCredentials && refreshTokenCredentials) console.warn(\"Both fetchRequestCredentials and refreshTokenCredentials is set. Only fetchRequestCredentials will be used.\");\n        this.fetchRequestCredentials = fetchRequestCredentials ? fetchRequestCredentials : refreshTokenCredentials ? refreshTokenCredentials : \"same-origin\";\n        if (stateStore) this.stateStore = stateStore;\n        else {\n            const store = typeof window !== \"undefined\" ? window.localStorage : new $631c75f8a3fcffe9$var$InMemoryWebStorage();\n            this.stateStore = new $631c75f8a3fcffe9$var$WebStorageStateStore({\n                store: store\n            });\n        }\n        this.refreshTokenAllowedScope = refreshTokenAllowedScope;\n        this.extraQueryParams = extraQueryParams;\n        this.extraTokenParams = extraTokenParams;\n        this.extraHeaders = extraHeaders;\n    }\n};\n// src/UserInfoService.ts\nvar $631c75f8a3fcffe9$var$UserInfoService = class {\n    constructor(_settings, _metadataService){\n        this._settings = _settings;\n        this._metadataService = _metadataService;\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"UserInfoService\");\n        this._getClaimsFromJwt = async (responseText)=>{\n            const logger2 = this._logger.create(\"_getClaimsFromJwt\");\n            try {\n                const payload = $631c75f8a3fcffe9$var$JwtUtils.decode(responseText);\n                logger2.debug(\"JWT decoding successful\");\n                return payload;\n            } catch (err) {\n                logger2.error(\"Error parsing JWT response\");\n                throw err;\n            }\n        };\n        this._jsonService = new $631c75f8a3fcffe9$var$JsonService(void 0, this._getClaimsFromJwt, this._settings.extraHeaders);\n    }\n    async getClaims(token) {\n        const logger2 = this._logger.create(\"getClaims\");\n        if (!token) this._logger.throw(new Error(\"No token passed\"));\n        const url = await this._metadataService.getUserInfoEndpoint();\n        logger2.debug(\"got userinfo url\", url);\n        const claims = await this._jsonService.getJson(url, {\n            token: token,\n            credentials: this._settings.fetchRequestCredentials\n        });\n        logger2.debug(\"got claims\", claims);\n        return claims;\n    }\n};\n// src/TokenClient.ts\nvar $631c75f8a3fcffe9$var$TokenClient = class {\n    constructor(_settings, _metadataService){\n        this._settings = _settings;\n        this._metadataService = _metadataService;\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"TokenClient\");\n        this._jsonService = new $631c75f8a3fcffe9$var$JsonService(this._settings.revokeTokenAdditionalContentTypes, null, this._settings.extraHeaders);\n    }\n    /**\n   * Exchange code.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3\n   */ async exchangeCode({ grant_type: grant_type = \"authorization_code\", redirect_uri: redirect_uri = this._settings.redirect_uri, client_id: client_id = this._settings.client_id, client_secret: client_secret = this._settings.client_secret, ...args }) {\n        const logger2 = this._logger.create(\"exchangeCode\");\n        if (!client_id) logger2.throw(new Error(\"A client_id is required\"));\n        if (!redirect_uri) logger2.throw(new Error(\"A redirect_uri is required\"));\n        if (!args.code) logger2.throw(new Error(\"A code is required\"));\n        const params = new URLSearchParams({\n            grant_type: grant_type,\n            redirect_uri: redirect_uri\n        });\n        for (const [key, value] of Object.entries(args))if (value != null) params.set(key, value);\n        let basicAuth;\n        switch(this._settings.client_authentication){\n            case \"client_secret_basic\":\n                if (!client_secret) {\n                    logger2.throw(new Error(\"A client_secret is required\"));\n                    throw null;\n                }\n                basicAuth = $631c75f8a3fcffe9$var$CryptoUtils.generateBasicAuth(client_id, client_secret);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) params.append(\"client_secret\", client_secret);\n                break;\n        }\n        const url = await this._metadataService.getTokenEndpoint(false);\n        logger2.debug(\"got token endpoint\");\n        const response = await this._jsonService.postForm(url, {\n            body: params,\n            basicAuth: basicAuth,\n            initCredentials: this._settings.fetchRequestCredentials\n        });\n        logger2.debug(\"got response\");\n        return response;\n    }\n    /**\n   * Exchange credentials.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.3.2\n   */ async exchangeCredentials({ grant_type: grant_type = \"password\", client_id: client_id = this._settings.client_id, client_secret: client_secret = this._settings.client_secret, scope: scope = this._settings.scope, ...args }) {\n        const logger2 = this._logger.create(\"exchangeCredentials\");\n        if (!client_id) logger2.throw(new Error(\"A client_id is required\"));\n        const params = new URLSearchParams({\n            grant_type: grant_type,\n            scope: scope\n        });\n        for (const [key, value] of Object.entries(args))if (value != null) params.set(key, value);\n        let basicAuth;\n        switch(this._settings.client_authentication){\n            case \"client_secret_basic\":\n                if (!client_secret) {\n                    logger2.throw(new Error(\"A client_secret is required\"));\n                    throw null;\n                }\n                basicAuth = $631c75f8a3fcffe9$var$CryptoUtils.generateBasicAuth(client_id, client_secret);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) params.append(\"client_secret\", client_secret);\n                break;\n        }\n        const url = await this._metadataService.getTokenEndpoint(false);\n        logger2.debug(\"got token endpoint\");\n        const response = await this._jsonService.postForm(url, {\n            body: params,\n            basicAuth: basicAuth,\n            initCredentials: this._settings.fetchRequestCredentials\n        });\n        logger2.debug(\"got response\");\n        return response;\n    }\n    /**\n   * Exchange a refresh token.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-6\n   */ async exchangeRefreshToken({ grant_type: grant_type = \"refresh_token\", client_id: client_id = this._settings.client_id, client_secret: client_secret = this._settings.client_secret, timeoutInSeconds: timeoutInSeconds, ...args }) {\n        const logger2 = this._logger.create(\"exchangeRefreshToken\");\n        if (!client_id) logger2.throw(new Error(\"A client_id is required\"));\n        if (!args.refresh_token) logger2.throw(new Error(\"A refresh_token is required\"));\n        const params = new URLSearchParams({\n            grant_type: grant_type\n        });\n        for (const [key, value] of Object.entries(args)){\n            if (Array.isArray(value)) value.forEach((param)=>params.append(key, param));\n            else if (value != null) params.set(key, value);\n        }\n        let basicAuth;\n        switch(this._settings.client_authentication){\n            case \"client_secret_basic\":\n                if (!client_secret) {\n                    logger2.throw(new Error(\"A client_secret is required\"));\n                    throw null;\n                }\n                basicAuth = $631c75f8a3fcffe9$var$CryptoUtils.generateBasicAuth(client_id, client_secret);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) params.append(\"client_secret\", client_secret);\n                break;\n        }\n        const url = await this._metadataService.getTokenEndpoint(false);\n        logger2.debug(\"got token endpoint\");\n        const response = await this._jsonService.postForm(url, {\n            body: params,\n            basicAuth: basicAuth,\n            timeoutInSeconds: timeoutInSeconds,\n            initCredentials: this._settings.fetchRequestCredentials\n        });\n        logger2.debug(\"got response\");\n        return response;\n    }\n    /**\n   * Revoke an access or refresh token.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc7009#section-2.1\n   */ async revoke(args) {\n        var _a;\n        const logger2 = this._logger.create(\"revoke\");\n        if (!args.token) logger2.throw(new Error(\"A token is required\"));\n        const url = await this._metadataService.getRevocationEndpoint(false);\n        logger2.debug(`got revocation endpoint, revoking ${(_a = args.token_type_hint) != null ? _a : \"default token type\"}`);\n        const params = new URLSearchParams();\n        for (const [key, value] of Object.entries(args))if (value != null) params.set(key, value);\n        params.set(\"client_id\", this._settings.client_id);\n        if (this._settings.client_secret) params.set(\"client_secret\", this._settings.client_secret);\n        await this._jsonService.postForm(url, {\n            body: params\n        });\n        logger2.debug(\"got response\");\n    }\n};\n// src/ResponseValidator.ts\nvar $631c75f8a3fcffe9$var$ResponseValidator = class {\n    constructor(_settings, _metadataService, _claimsService){\n        this._settings = _settings;\n        this._metadataService = _metadataService;\n        this._claimsService = _claimsService;\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"ResponseValidator\");\n        this._userInfoService = new $631c75f8a3fcffe9$var$UserInfoService(this._settings, this._metadataService);\n        this._tokenClient = new $631c75f8a3fcffe9$var$TokenClient(this._settings, this._metadataService);\n    }\n    async validateSigninResponse(response, state) {\n        const logger2 = this._logger.create(\"validateSigninResponse\");\n        this._processSigninState(response, state);\n        logger2.debug(\"state processed\");\n        await this._processCode(response, state);\n        logger2.debug(\"code processed\");\n        if (response.isOpenId) this._validateIdTokenAttributes(response);\n        logger2.debug(\"tokens validated\");\n        await this._processClaims(response, state == null ? void 0 : state.skipUserInfo, response.isOpenId);\n        logger2.debug(\"claims processed\");\n    }\n    async validateCredentialsResponse(response, skipUserInfo) {\n        const logger2 = this._logger.create(\"validateCredentialsResponse\");\n        if (response.isOpenId && !!response.id_token) this._validateIdTokenAttributes(response);\n        logger2.debug(\"tokens validated\");\n        await this._processClaims(response, skipUserInfo, response.isOpenId);\n        logger2.debug(\"claims processed\");\n    }\n    async validateRefreshResponse(response, state) {\n        var _a, _b;\n        const logger2 = this._logger.create(\"validateRefreshResponse\");\n        response.userState = state.data;\n        (_a = response.session_state) != null ? _a : response.session_state = state.session_state;\n        (_b = response.scope) != null ? _b : response.scope = state.scope;\n        if (response.isOpenId && !!response.id_token) {\n            this._validateIdTokenAttributes(response, state.id_token);\n            logger2.debug(\"ID Token validated\");\n        }\n        if (!response.id_token) {\n            response.id_token = state.id_token;\n            response.profile = state.profile;\n        }\n        const hasIdToken = response.isOpenId && !!response.id_token;\n        await this._processClaims(response, false, hasIdToken);\n        logger2.debug(\"claims processed\");\n    }\n    validateSignoutResponse(response, state) {\n        const logger2 = this._logger.create(\"validateSignoutResponse\");\n        if (state.id !== response.state) logger2.throw(new Error(\"State does not match\"));\n        logger2.debug(\"state validated\");\n        response.userState = state.data;\n        if (response.error) {\n            logger2.warn(\"Response was error\", response.error);\n            throw new $631c75f8a3fcffe9$var$ErrorResponse(response);\n        }\n    }\n    _processSigninState(response, state) {\n        var _a;\n        const logger2 = this._logger.create(\"_processSigninState\");\n        if (state.id !== response.state) logger2.throw(new Error(\"State does not match\"));\n        if (!state.client_id) logger2.throw(new Error(\"No client_id on state\"));\n        if (!state.authority) logger2.throw(new Error(\"No authority on state\"));\n        if (this._settings.authority !== state.authority) logger2.throw(new Error(\"authority mismatch on settings vs. signin state\"));\n        if (this._settings.client_id && this._settings.client_id !== state.client_id) logger2.throw(new Error(\"client_id mismatch on settings vs. signin state\"));\n        logger2.debug(\"state validated\");\n        response.userState = state.data;\n        response.url_state = state.url_state;\n        (_a = response.scope) != null ? _a : response.scope = state.scope;\n        if (response.error) {\n            logger2.warn(\"Response was error\", response.error);\n            throw new $631c75f8a3fcffe9$var$ErrorResponse(response);\n        }\n        if (state.code_verifier && !response.code) logger2.throw(new Error(\"Expected code in response\"));\n    }\n    async _processClaims(response, skipUserInfo = false, validateSub = true) {\n        const logger2 = this._logger.create(\"_processClaims\");\n        response.profile = this._claimsService.filterProtocolClaims(response.profile);\n        if (skipUserInfo || !this._settings.loadUserInfo || !response.access_token) {\n            logger2.debug(\"not loading user info\");\n            return;\n        }\n        logger2.debug(\"loading user info\");\n        const claims = await this._userInfoService.getClaims(response.access_token);\n        logger2.debug(\"user info claims received from user info endpoint\");\n        if (validateSub && claims.sub !== response.profile.sub) logger2.throw(new Error(\"subject from UserInfo response does not match subject in ID Token\"));\n        response.profile = this._claimsService.mergeClaims(response.profile, this._claimsService.filterProtocolClaims(claims));\n        logger2.debug(\"user info claims received, updated profile:\", response.profile);\n    }\n    async _processCode(response, state) {\n        const logger2 = this._logger.create(\"_processCode\");\n        if (response.code) {\n            logger2.debug(\"Validating code\");\n            const tokenResponse = await this._tokenClient.exchangeCode({\n                client_id: state.client_id,\n                client_secret: state.client_secret,\n                code: response.code,\n                redirect_uri: state.redirect_uri,\n                code_verifier: state.code_verifier,\n                ...state.extraTokenParams\n            });\n            Object.assign(response, tokenResponse);\n        } else logger2.debug(\"No code to process\");\n    }\n    _validateIdTokenAttributes(response, existingToken) {\n        var _a;\n        const logger2 = this._logger.create(\"_validateIdTokenAttributes\");\n        logger2.debug(\"decoding ID Token JWT\");\n        const incoming = $631c75f8a3fcffe9$var$JwtUtils.decode((_a = response.id_token) != null ? _a : \"\");\n        if (!incoming.sub) logger2.throw(new Error(\"ID Token is missing a subject claim\"));\n        if (existingToken) {\n            const existing = $631c75f8a3fcffe9$var$JwtUtils.decode(existingToken);\n            if (incoming.sub !== existing.sub) logger2.throw(new Error(\"sub in id_token does not match current sub\"));\n            if (incoming.auth_time && incoming.auth_time !== existing.auth_time) logger2.throw(new Error(\"auth_time in id_token does not match original auth_time\"));\n            if (incoming.azp && incoming.azp !== existing.azp) logger2.throw(new Error(\"azp in id_token does not match original azp\"));\n            if (!incoming.azp && existing.azp) logger2.throw(new Error(\"azp not in id_token, but present in original id_token\"));\n        }\n        response.profile = incoming;\n    }\n};\n// src/State.ts\nvar $631c75f8a3fcffe9$var$State = class {\n    constructor(args){\n        this.id = args.id || $631c75f8a3fcffe9$var$CryptoUtils.generateUUIDv4();\n        this.data = args.data;\n        if (args.created && args.created > 0) this.created = args.created;\n        else this.created = $631c75f8a3fcffe9$var$Timer.getEpochTime();\n        this.request_type = args.request_type;\n        this.url_state = args.url_state;\n    }\n    toStorageString() {\n        new $631c75f8a3fcffe9$var$Logger(\"State\").create(\"toStorageString\");\n        return JSON.stringify({\n            id: this.id,\n            data: this.data,\n            created: this.created,\n            request_type: this.request_type,\n            url_state: this.url_state\n        });\n    }\n    static fromStorageString(storageString) {\n        $631c75f8a3fcffe9$var$Logger.createStatic(\"State\", \"fromStorageString\");\n        return new $631c75f8a3fcffe9$var$State(JSON.parse(storageString));\n    }\n    static async clearStaleState(storage, age) {\n        const logger2 = $631c75f8a3fcffe9$var$Logger.createStatic(\"State\", \"clearStaleState\");\n        const cutoff = $631c75f8a3fcffe9$var$Timer.getEpochTime() - age;\n        const keys = await storage.getAllKeys();\n        logger2.debug(\"got keys\", keys);\n        for(let i = 0; i < keys.length; i++){\n            const key = keys[i];\n            const item = await storage.get(key);\n            let remove = false;\n            if (item) try {\n                const state = $631c75f8a3fcffe9$var$State.fromStorageString(item);\n                logger2.debug(\"got item from key:\", key, state.created);\n                if (state.created <= cutoff) remove = true;\n            } catch (err) {\n                logger2.error(\"Error parsing state for key:\", key, err);\n                remove = true;\n            }\n            else {\n                logger2.debug(\"no item in storage for key:\", key);\n                remove = true;\n            }\n            if (remove) {\n                logger2.debug(\"removed item for key:\", key);\n                storage.remove(key);\n            }\n        }\n    }\n};\n// src/SigninState.ts\nvar $631c75f8a3fcffe9$var$SigninState = class extends $631c75f8a3fcffe9$var$State {\n    constructor(args){\n        super(args);\n        if (args.code_verifier === true) this.code_verifier = $631c75f8a3fcffe9$var$CryptoUtils.generateCodeVerifier();\n        else if (args.code_verifier) this.code_verifier = args.code_verifier;\n        if (this.code_verifier) this.code_challenge = $631c75f8a3fcffe9$var$CryptoUtils.generateCodeChallenge(this.code_verifier);\n        this.authority = args.authority;\n        this.client_id = args.client_id;\n        this.redirect_uri = args.redirect_uri;\n        this.scope = args.scope;\n        this.client_secret = args.client_secret;\n        this.extraTokenParams = args.extraTokenParams;\n        this.response_mode = args.response_mode;\n        this.skipUserInfo = args.skipUserInfo;\n    }\n    toStorageString() {\n        new $631c75f8a3fcffe9$var$Logger(\"SigninState\").create(\"toStorageString\");\n        return JSON.stringify({\n            id: this.id,\n            data: this.data,\n            created: this.created,\n            request_type: this.request_type,\n            url_state: this.url_state,\n            code_verifier: this.code_verifier,\n            authority: this.authority,\n            client_id: this.client_id,\n            redirect_uri: this.redirect_uri,\n            scope: this.scope,\n            client_secret: this.client_secret,\n            extraTokenParams: this.extraTokenParams,\n            response_mode: this.response_mode,\n            skipUserInfo: this.skipUserInfo\n        });\n    }\n    static fromStorageString(storageString) {\n        $631c75f8a3fcffe9$var$Logger.createStatic(\"SigninState\", \"fromStorageString\");\n        const data = JSON.parse(storageString);\n        return new $631c75f8a3fcffe9$var$SigninState(data);\n    }\n};\n// src/SigninRequest.ts\nvar $631c75f8a3fcffe9$var$SigninRequest = class {\n    constructor({ url: // mandatory\n    url, authority: authority, client_id: client_id, redirect_uri: redirect_uri, response_type: response_type, scope: scope, state_data: // optional\n    state_data, response_mode: response_mode, request_type: request_type, client_secret: client_secret, nonce: nonce, url_state: url_state, resource: resource, skipUserInfo: skipUserInfo, extraQueryParams: extraQueryParams, extraTokenParams: extraTokenParams, disablePKCE: disablePKCE, ...optionalParams }){\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"SigninRequest\");\n        if (!url) {\n            this._logger.error(\"ctor: No url passed\");\n            throw new Error(\"url\");\n        }\n        if (!client_id) {\n            this._logger.error(\"ctor: No client_id passed\");\n            throw new Error(\"client_id\");\n        }\n        if (!redirect_uri) {\n            this._logger.error(\"ctor: No redirect_uri passed\");\n            throw new Error(\"redirect_uri\");\n        }\n        if (!response_type) {\n            this._logger.error(\"ctor: No response_type passed\");\n            throw new Error(\"response_type\");\n        }\n        if (!scope) {\n            this._logger.error(\"ctor: No scope passed\");\n            throw new Error(\"scope\");\n        }\n        if (!authority) {\n            this._logger.error(\"ctor: No authority passed\");\n            throw new Error(\"authority\");\n        }\n        this.state = new $631c75f8a3fcffe9$var$SigninState({\n            data: state_data,\n            request_type: request_type,\n            url_state: url_state,\n            code_verifier: !disablePKCE,\n            client_id: client_id,\n            authority: authority,\n            redirect_uri: redirect_uri,\n            response_mode: response_mode,\n            client_secret: client_secret,\n            scope: scope,\n            extraTokenParams: extraTokenParams,\n            skipUserInfo: skipUserInfo\n        });\n        const parsedUrl = new URL(url);\n        parsedUrl.searchParams.append(\"client_id\", client_id);\n        parsedUrl.searchParams.append(\"redirect_uri\", redirect_uri);\n        parsedUrl.searchParams.append(\"response_type\", response_type);\n        parsedUrl.searchParams.append(\"scope\", scope);\n        if (nonce) parsedUrl.searchParams.append(\"nonce\", nonce);\n        let state = this.state.id;\n        if (url_state) state = `${state}${$631c75f8a3fcffe9$var$URL_STATE_DELIMITER}${url_state}`;\n        parsedUrl.searchParams.append(\"state\", state);\n        if (this.state.code_challenge) {\n            parsedUrl.searchParams.append(\"code_challenge\", this.state.code_challenge);\n            parsedUrl.searchParams.append(\"code_challenge_method\", \"S256\");\n        }\n        if (resource) {\n            const resources = Array.isArray(resource) ? resource : [\n                resource\n            ];\n            resources.forEach((r)=>parsedUrl.searchParams.append(\"resource\", r));\n        }\n        for (const [key, value] of Object.entries({\n            response_mode: response_mode,\n            ...optionalParams,\n            ...extraQueryParams\n        }))if (value != null) parsedUrl.searchParams.append(key, value.toString());\n        this.url = parsedUrl.href;\n    }\n};\n// src/SigninResponse.ts\nvar $631c75f8a3fcffe9$var$OidcScope = \"openid\";\nvar $631c75f8a3fcffe9$var$SigninResponse = class {\n    constructor(params){\n        /** @see {@link User.access_token} */ this.access_token = \"\";\n        /** @see {@link User.token_type} */ this.token_type = \"\";\n        /** @see {@link User.profile} */ this.profile = {};\n        this.state = params.get(\"state\");\n        this.session_state = params.get(\"session_state\");\n        if (this.state) {\n            const splitState = decodeURIComponent(this.state).split($631c75f8a3fcffe9$var$URL_STATE_DELIMITER);\n            this.state = splitState[0];\n            if (splitState.length > 1) this.url_state = splitState.slice(1).join($631c75f8a3fcffe9$var$URL_STATE_DELIMITER);\n        }\n        this.error = params.get(\"error\");\n        this.error_description = params.get(\"error_description\");\n        this.error_uri = params.get(\"error_uri\");\n        this.code = params.get(\"code\");\n    }\n    get expires_in() {\n        if (this.expires_at === void 0) return void 0;\n        return this.expires_at - $631c75f8a3fcffe9$var$Timer.getEpochTime();\n    }\n    set expires_in(value) {\n        if (typeof value === \"string\") value = Number(value);\n        if (value !== void 0 && value >= 0) this.expires_at = Math.floor(value) + $631c75f8a3fcffe9$var$Timer.getEpochTime();\n    }\n    get isOpenId() {\n        var _a;\n        return ((_a = this.scope) == null ? void 0 : _a.split(\" \").includes($631c75f8a3fcffe9$var$OidcScope)) || !!this.id_token;\n    }\n};\n// src/SignoutRequest.ts\nvar $631c75f8a3fcffe9$var$SignoutRequest = class {\n    constructor({ url: url, state_data: state_data, id_token_hint: id_token_hint, post_logout_redirect_uri: post_logout_redirect_uri, extraQueryParams: extraQueryParams, request_type: request_type, client_id: client_id }){\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"SignoutRequest\");\n        if (!url) {\n            this._logger.error(\"ctor: No url passed\");\n            throw new Error(\"url\");\n        }\n        const parsedUrl = new URL(url);\n        if (id_token_hint) parsedUrl.searchParams.append(\"id_token_hint\", id_token_hint);\n        if (client_id) parsedUrl.searchParams.append(\"client_id\", client_id);\n        if (post_logout_redirect_uri) {\n            parsedUrl.searchParams.append(\"post_logout_redirect_uri\", post_logout_redirect_uri);\n            if (state_data) {\n                this.state = new $631c75f8a3fcffe9$var$State({\n                    data: state_data,\n                    request_type: request_type\n                });\n                parsedUrl.searchParams.append(\"state\", this.state.id);\n            }\n        }\n        for (const [key, value] of Object.entries({\n            ...extraQueryParams\n        }))if (value != null) parsedUrl.searchParams.append(key, value.toString());\n        this.url = parsedUrl.href;\n    }\n};\n// src/SignoutResponse.ts\nvar $631c75f8a3fcffe9$var$SignoutResponse = class {\n    constructor(params){\n        this.state = params.get(\"state\");\n        this.error = params.get(\"error\");\n        this.error_description = params.get(\"error_description\");\n        this.error_uri = params.get(\"error_uri\");\n    }\n};\n// src/ClaimsService.ts\nvar $631c75f8a3fcffe9$var$DefaultProtocolClaims = [\n    \"nbf\",\n    \"jti\",\n    \"auth_time\",\n    \"nonce\",\n    \"acr\",\n    \"amr\",\n    \"azp\",\n    \"at_hash\"\n];\nvar $631c75f8a3fcffe9$var$InternalRequiredProtocolClaims = [\n    \"sub\",\n    \"iss\",\n    \"aud\",\n    \"exp\",\n    \"iat\"\n];\nvar $631c75f8a3fcffe9$var$ClaimsService = class {\n    constructor(_settings){\n        this._settings = _settings;\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"ClaimsService\");\n    }\n    filterProtocolClaims(claims) {\n        const result = {\n            ...claims\n        };\n        if (this._settings.filterProtocolClaims) {\n            let protocolClaims;\n            if (Array.isArray(this._settings.filterProtocolClaims)) protocolClaims = this._settings.filterProtocolClaims;\n            else protocolClaims = $631c75f8a3fcffe9$var$DefaultProtocolClaims;\n            for (const claim of protocolClaims)if (!$631c75f8a3fcffe9$var$InternalRequiredProtocolClaims.includes(claim)) delete result[claim];\n        }\n        return result;\n    }\n    mergeClaims(claims1, claims2) {\n        const result = {\n            ...claims1\n        };\n        for (const [claim, values] of Object.entries(claims2))for (const value of Array.isArray(values) ? values : [\n            values\n        ]){\n            const previousValue = result[claim];\n            if (previousValue === void 0) result[claim] = value;\n            else if (Array.isArray(previousValue)) {\n                if (!previousValue.includes(value)) previousValue.push(value);\n            } else if (result[claim] !== value) {\n                if (typeof value === \"object\" && this._settings.mergeClaims) result[claim] = this.mergeClaims(previousValue, value);\n                else result[claim] = [\n                    previousValue,\n                    value\n                ];\n            }\n        }\n        return result;\n    }\n};\n// src/OidcClient.ts\nvar $631c75f8a3fcffe9$var$OidcClient = class {\n    constructor(settings, metadataService){\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"OidcClient\");\n        this.settings = settings instanceof $631c75f8a3fcffe9$var$OidcClientSettingsStore ? settings : new $631c75f8a3fcffe9$var$OidcClientSettingsStore(settings);\n        this.metadataService = metadataService != null ? metadataService : new $631c75f8a3fcffe9$var$MetadataService(this.settings);\n        this._claimsService = new $631c75f8a3fcffe9$var$ClaimsService(this.settings);\n        this._validator = new $631c75f8a3fcffe9$var$ResponseValidator(this.settings, this.metadataService, this._claimsService);\n        this._tokenClient = new $631c75f8a3fcffe9$var$TokenClient(this.settings, this.metadataService);\n    }\n    async createSigninRequest({ state: state, request: request, request_uri: request_uri, request_type: request_type, id_token_hint: id_token_hint, login_hint: login_hint, skipUserInfo: skipUserInfo, nonce: nonce, url_state: url_state, response_type: response_type = this.settings.response_type, scope: scope = this.settings.scope, redirect_uri: redirect_uri = this.settings.redirect_uri, prompt: prompt = this.settings.prompt, display: display = this.settings.display, max_age: max_age = this.settings.max_age, ui_locales: ui_locales = this.settings.ui_locales, acr_values: acr_values = this.settings.acr_values, resource: resource = this.settings.resource, response_mode: response_mode = this.settings.response_mode, extraQueryParams: extraQueryParams = this.settings.extraQueryParams, extraTokenParams: extraTokenParams = this.settings.extraTokenParams }) {\n        const logger2 = this._logger.create(\"createSigninRequest\");\n        if (response_type !== \"code\") throw new Error(\"Only the Authorization Code flow (with PKCE) is supported\");\n        const url = await this.metadataService.getAuthorizationEndpoint();\n        logger2.debug(\"Received authorization endpoint\", url);\n        const signinRequest = new $631c75f8a3fcffe9$var$SigninRequest({\n            url: url,\n            authority: this.settings.authority,\n            client_id: this.settings.client_id,\n            redirect_uri: redirect_uri,\n            response_type: response_type,\n            scope: scope,\n            state_data: state,\n            url_state: url_state,\n            prompt: prompt,\n            display: display,\n            max_age: max_age,\n            ui_locales: ui_locales,\n            id_token_hint: id_token_hint,\n            login_hint: login_hint,\n            acr_values: acr_values,\n            resource: resource,\n            request: request,\n            request_uri: request_uri,\n            extraQueryParams: extraQueryParams,\n            extraTokenParams: extraTokenParams,\n            request_type: request_type,\n            response_mode: response_mode,\n            client_secret: this.settings.client_secret,\n            skipUserInfo: skipUserInfo,\n            nonce: nonce,\n            disablePKCE: this.settings.disablePKCE\n        });\n        await this.clearStaleState();\n        const signinState = signinRequest.state;\n        await this.settings.stateStore.set(signinState.id, signinState.toStorageString());\n        return signinRequest;\n    }\n    async readSigninResponseState(url, removeState = false) {\n        const logger2 = this._logger.create(\"readSigninResponseState\");\n        const response = new $631c75f8a3fcffe9$var$SigninResponse($631c75f8a3fcffe9$var$UrlUtils.readParams(url, this.settings.response_mode));\n        if (!response.state) {\n            logger2.throw(new Error(\"No state in response\"));\n            throw null;\n        }\n        const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n        if (!storedStateString) {\n            logger2.throw(new Error(\"No matching state found in storage\"));\n            throw null;\n        }\n        const state = $631c75f8a3fcffe9$var$SigninState.fromStorageString(storedStateString);\n        return {\n            state: state,\n            response: response\n        };\n    }\n    async processSigninResponse(url) {\n        const logger2 = this._logger.create(\"processSigninResponse\");\n        const { state: state, response: response } = await this.readSigninResponseState(url, true);\n        logger2.debug(\"received state from storage; validating response\");\n        await this._validator.validateSigninResponse(response, state);\n        return response;\n    }\n    async processResourceOwnerPasswordCredentials({ username: username, password: password, skipUserInfo: skipUserInfo = false, extraTokenParams: extraTokenParams = {} }) {\n        const tokenResponse = await this._tokenClient.exchangeCredentials({\n            username: username,\n            password: password,\n            ...extraTokenParams\n        });\n        const signinResponse = new $631c75f8a3fcffe9$var$SigninResponse(new URLSearchParams());\n        Object.assign(signinResponse, tokenResponse);\n        await this._validator.validateCredentialsResponse(signinResponse, skipUserInfo);\n        return signinResponse;\n    }\n    async useRefreshToken({ state: state, timeoutInSeconds: timeoutInSeconds }) {\n        var _a;\n        const logger2 = this._logger.create(\"useRefreshToken\");\n        let scope;\n        if (this.settings.refreshTokenAllowedScope === void 0) scope = state.scope;\n        else {\n            const allowableScopes = this.settings.refreshTokenAllowedScope.split(\" \");\n            const providedScopes = ((_a = state.scope) == null ? void 0 : _a.split(\" \")) || [];\n            scope = providedScopes.filter((s)=>allowableScopes.includes(s)).join(\" \");\n        }\n        const result = await this._tokenClient.exchangeRefreshToken({\n            refresh_token: state.refresh_token,\n            resource: state.resource,\n            scope: // provide the (possible filtered) scope list\n            scope,\n            timeoutInSeconds: timeoutInSeconds\n        });\n        const response = new $631c75f8a3fcffe9$var$SigninResponse(new URLSearchParams());\n        Object.assign(response, result);\n        logger2.debug(\"validating response\", response);\n        await this._validator.validateRefreshResponse(response, {\n            ...state,\n            scope: // overide the scope in the state handed over to the validator\n            // so it can set the granted scope to the requested scope in case none is included in the response\n            scope\n        });\n        return response;\n    }\n    async createSignoutRequest({ state: state, id_token_hint: id_token_hint, client_id: client_id, request_type: request_type, post_logout_redirect_uri: post_logout_redirect_uri = this.settings.post_logout_redirect_uri, extraQueryParams: extraQueryParams = this.settings.extraQueryParams } = {}) {\n        const logger2 = this._logger.create(\"createSignoutRequest\");\n        const url = await this.metadataService.getEndSessionEndpoint();\n        if (!url) {\n            logger2.throw(new Error(\"No end session endpoint\"));\n            throw null;\n        }\n        logger2.debug(\"Received end session endpoint\", url);\n        if (!client_id && post_logout_redirect_uri && !id_token_hint) client_id = this.settings.client_id;\n        const request = new $631c75f8a3fcffe9$var$SignoutRequest({\n            url: url,\n            id_token_hint: id_token_hint,\n            client_id: client_id,\n            post_logout_redirect_uri: post_logout_redirect_uri,\n            state_data: state,\n            extraQueryParams: extraQueryParams,\n            request_type: request_type\n        });\n        await this.clearStaleState();\n        const signoutState = request.state;\n        if (signoutState) {\n            logger2.debug(\"Signout request has state to persist\");\n            await this.settings.stateStore.set(signoutState.id, signoutState.toStorageString());\n        }\n        return request;\n    }\n    async readSignoutResponseState(url, removeState = false) {\n        const logger2 = this._logger.create(\"readSignoutResponseState\");\n        const response = new $631c75f8a3fcffe9$var$SignoutResponse($631c75f8a3fcffe9$var$UrlUtils.readParams(url, this.settings.response_mode));\n        if (!response.state) {\n            logger2.debug(\"No state in response\");\n            if (response.error) {\n                logger2.warn(\"Response was error:\", response.error);\n                throw new $631c75f8a3fcffe9$var$ErrorResponse(response);\n            }\n            return {\n                state: void 0,\n                response: response\n            };\n        }\n        const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n        if (!storedStateString) {\n            logger2.throw(new Error(\"No matching state found in storage\"));\n            throw null;\n        }\n        const state = $631c75f8a3fcffe9$var$State.fromStorageString(storedStateString);\n        return {\n            state: state,\n            response: response\n        };\n    }\n    async processSignoutResponse(url) {\n        const logger2 = this._logger.create(\"processSignoutResponse\");\n        const { state: state, response: response } = await this.readSignoutResponseState(url, true);\n        if (state) {\n            logger2.debug(\"Received state from storage; validating response\");\n            this._validator.validateSignoutResponse(response, state);\n        } else logger2.debug(\"No state from storage; skipping response validation\");\n        return response;\n    }\n    clearStaleState() {\n        this._logger.create(\"clearStaleState\");\n        return $631c75f8a3fcffe9$var$State.clearStaleState(this.settings.stateStore, this.settings.staleStateAgeInSeconds);\n    }\n    async revokeToken(token, type) {\n        this._logger.create(\"revokeToken\");\n        return await this._tokenClient.revoke({\n            token: token,\n            token_type_hint: type\n        });\n    }\n};\n// src/SessionMonitor.ts\nvar $631c75f8a3fcffe9$var$SessionMonitor = class {\n    constructor(_userManager){\n        this._userManager = _userManager;\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"SessionMonitor\");\n        this._start = async (user)=>{\n            const session_state = user.session_state;\n            if (!session_state) return;\n            const logger2 = this._logger.create(\"_start\");\n            if (user.profile) {\n                this._sub = user.profile.sub;\n                this._sid = user.profile.sid;\n                logger2.debug(\"session_state\", session_state, \", sub\", this._sub);\n            } else {\n                this._sub = void 0;\n                this._sid = void 0;\n                logger2.debug(\"session_state\", session_state, \", anonymous user\");\n            }\n            if (this._checkSessionIFrame) {\n                this._checkSessionIFrame.start(session_state);\n                return;\n            }\n            try {\n                const url = await this._userManager.metadataService.getCheckSessionIframe();\n                if (url) {\n                    logger2.debug(\"initializing check session iframe\");\n                    const client_id = this._userManager.settings.client_id;\n                    const intervalInSeconds = this._userManager.settings.checkSessionIntervalInSeconds;\n                    const stopOnError = this._userManager.settings.stopCheckSessionOnError;\n                    const checkSessionIFrame = new $631c75f8a3fcffe9$var$CheckSessionIFrame(this._callback, client_id, url, intervalInSeconds, stopOnError);\n                    await checkSessionIFrame.load();\n                    this._checkSessionIFrame = checkSessionIFrame;\n                    checkSessionIFrame.start(session_state);\n                } else logger2.warn(\"no check session iframe found in the metadata\");\n            } catch (err) {\n                logger2.error(\"Error from getCheckSessionIframe:\", err instanceof Error ? err.message : err);\n            }\n        };\n        this._stop = ()=>{\n            const logger2 = this._logger.create(\"_stop\");\n            this._sub = void 0;\n            this._sid = void 0;\n            if (this._checkSessionIFrame) this._checkSessionIFrame.stop();\n            if (this._userManager.settings.monitorAnonymousSession) {\n                const timerHandle = setInterval(async ()=>{\n                    clearInterval(timerHandle);\n                    try {\n                        const session = await this._userManager.querySessionStatus();\n                        if (session) {\n                            const tmpUser = {\n                                session_state: session.session_state,\n                                profile: session.sub && session.sid ? {\n                                    sub: session.sub,\n                                    sid: session.sid\n                                } : null\n                            };\n                            this._start(tmpUser);\n                        }\n                    } catch (err) {\n                        logger2.error(\"error from querySessionStatus\", err instanceof Error ? err.message : err);\n                    }\n                }, 1e3);\n            }\n        };\n        this._callback = async ()=>{\n            const logger2 = this._logger.create(\"_callback\");\n            try {\n                const session = await this._userManager.querySessionStatus();\n                let raiseEvent = true;\n                if (session && this._checkSessionIFrame) {\n                    if (session.sub === this._sub) {\n                        raiseEvent = false;\n                        this._checkSessionIFrame.start(session.session_state);\n                        if (session.sid === this._sid) logger2.debug(\"same sub still logged in at OP, restarting check session iframe; session_state\", session.session_state);\n                        else {\n                            logger2.debug(\"same sub still logged in at OP, session state has changed, restarting check session iframe; session_state\", session.session_state);\n                            this._userManager.events._raiseUserSessionChanged();\n                        }\n                    } else logger2.debug(\"different subject signed into OP\", session.sub);\n                } else logger2.debug(\"subject no longer signed into OP\");\n                if (raiseEvent) {\n                    if (this._sub) this._userManager.events._raiseUserSignedOut();\n                    else this._userManager.events._raiseUserSignedIn();\n                } else logger2.debug(\"no change in session detected, no event to raise\");\n            } catch (err) {\n                if (this._sub) {\n                    logger2.debug(\"Error calling queryCurrentSigninSession; raising signed out event\", err);\n                    this._userManager.events._raiseUserSignedOut();\n                }\n            }\n        };\n        if (!_userManager) this._logger.throw(new Error(\"No user manager passed\"));\n        this._userManager.events.addUserLoaded(this._start);\n        this._userManager.events.addUserUnloaded(this._stop);\n        this._init().catch((err)=>{\n            this._logger.error(err);\n        });\n    }\n    async _init() {\n        this._logger.create(\"_init\");\n        const user = await this._userManager.getUser();\n        if (user) this._start(user);\n        else if (this._userManager.settings.monitorAnonymousSession) {\n            const session = await this._userManager.querySessionStatus();\n            if (session) {\n                const tmpUser = {\n                    session_state: session.session_state,\n                    profile: session.sub && session.sid ? {\n                        sub: session.sub,\n                        sid: session.sid\n                    } : null\n                };\n                this._start(tmpUser);\n            }\n        }\n    }\n};\n// src/User.ts\nvar $631c75f8a3fcffe9$var$User = class {\n    constructor(args){\n        var _a;\n        this.id_token = args.id_token;\n        this.session_state = (_a = args.session_state) != null ? _a : null;\n        this.access_token = args.access_token;\n        this.refresh_token = args.refresh_token;\n        this.token_type = args.token_type;\n        this.scope = args.scope;\n        this.profile = args.profile;\n        this.expires_at = args.expires_at;\n        this.state = args.userState;\n        this.url_state = args.url_state;\n    }\n    /** Computed number of seconds the access token has remaining. */ get expires_in() {\n        if (this.expires_at === void 0) return void 0;\n        return this.expires_at - $631c75f8a3fcffe9$var$Timer.getEpochTime();\n    }\n    set expires_in(value) {\n        if (value !== void 0) this.expires_at = Math.floor(value) + $631c75f8a3fcffe9$var$Timer.getEpochTime();\n    }\n    /** Computed value indicating if the access token is expired. */ get expired() {\n        const expires_in = this.expires_in;\n        if (expires_in === void 0) return void 0;\n        return expires_in <= 0;\n    }\n    /** Array representing the parsed values from the `scope`. */ get scopes() {\n        var _a, _b;\n        return (_b = (_a = this.scope) == null ? void 0 : _a.split(\" \")) != null ? _b : [];\n    }\n    toStorageString() {\n        new $631c75f8a3fcffe9$var$Logger(\"User\").create(\"toStorageString\");\n        return JSON.stringify({\n            id_token: this.id_token,\n            session_state: this.session_state,\n            access_token: this.access_token,\n            refresh_token: this.refresh_token,\n            token_type: this.token_type,\n            scope: this.scope,\n            profile: this.profile,\n            expires_at: this.expires_at\n        });\n    }\n    static fromStorageString(storageString) {\n        $631c75f8a3fcffe9$var$Logger.createStatic(\"User\", \"fromStorageString\");\n        return new $631c75f8a3fcffe9$var$User(JSON.parse(storageString));\n    }\n};\n// src/navigators/AbstractChildWindow.ts\nvar $631c75f8a3fcffe9$var$messageSource = \"oidc-client\";\nvar $631c75f8a3fcffe9$var$AbstractChildWindow = class {\n    constructor(){\n        this._abort = new $631c75f8a3fcffe9$var$Event(\"Window navigation aborted\");\n        this._disposeHandlers = /* @__PURE__ */ new Set();\n        this._window = null;\n    }\n    async navigate(params) {\n        const logger2 = this._logger.create(\"navigate\");\n        if (!this._window) throw new Error(\"Attempted to navigate on a disposed window\");\n        logger2.debug(\"setting URL in window\");\n        this._window.location.replace(params.url);\n        const { url: url, keepOpen: keepOpen } = await new Promise((resolve, reject)=>{\n            const listener = (e)=>{\n                var _a;\n                const data = e.data;\n                const origin = (_a = params.scriptOrigin) != null ? _a : window.location.origin;\n                if (e.origin !== origin || (data == null ? void 0 : data.source) !== $631c75f8a3fcffe9$var$messageSource) return;\n                try {\n                    const state = $631c75f8a3fcffe9$var$UrlUtils.readParams(data.url, params.response_mode).get(\"state\");\n                    if (!state) logger2.warn(\"no state found in response url\");\n                    if (e.source !== this._window && state !== params.state) return;\n                } catch (err) {\n                    this._dispose();\n                    reject(new Error(\"Invalid response from window\"));\n                }\n                resolve(data);\n            };\n            window.addEventListener(\"message\", listener, false);\n            this._disposeHandlers.add(()=>window.removeEventListener(\"message\", listener, false));\n            this._disposeHandlers.add(this._abort.addHandler((reason)=>{\n                this._dispose();\n                reject(reason);\n            }));\n        });\n        logger2.debug(\"got response from window\");\n        this._dispose();\n        if (!keepOpen) this.close();\n        return {\n            url: url\n        };\n    }\n    _dispose() {\n        this._logger.create(\"_dispose\");\n        for (const dispose of this._disposeHandlers)dispose();\n        this._disposeHandlers.clear();\n    }\n    static _notifyParent(parent, url, keepOpen = false, targetOrigin = window.location.origin) {\n        parent.postMessage({\n            source: $631c75f8a3fcffe9$var$messageSource,\n            url: url,\n            keepOpen: keepOpen\n        }, targetOrigin);\n    }\n};\n// src/UserManagerSettings.ts\nvar $631c75f8a3fcffe9$var$DefaultPopupWindowFeatures = {\n    location: false,\n    toolbar: false,\n    height: 640,\n    closePopupWindowAfterInSeconds: -1\n};\nvar $631c75f8a3fcffe9$var$DefaultPopupTarget = \"_blank\";\nvar $631c75f8a3fcffe9$var$DefaultAccessTokenExpiringNotificationTimeInSeconds = 60;\nvar $631c75f8a3fcffe9$var$DefaultCheckSessionIntervalInSeconds = 2;\nvar $631c75f8a3fcffe9$var$DefaultSilentRequestTimeoutInSeconds = 10;\nvar $631c75f8a3fcffe9$var$UserManagerSettingsStore = class extends $631c75f8a3fcffe9$var$OidcClientSettingsStore {\n    constructor(args){\n        const { popup_redirect_uri: popup_redirect_uri = args.redirect_uri, popup_post_logout_redirect_uri: popup_post_logout_redirect_uri = args.post_logout_redirect_uri, popupWindowFeatures: popupWindowFeatures = $631c75f8a3fcffe9$var$DefaultPopupWindowFeatures, popupWindowTarget: popupWindowTarget = $631c75f8a3fcffe9$var$DefaultPopupTarget, redirectMethod: redirectMethod = \"assign\", redirectTarget: redirectTarget = \"self\", iframeNotifyParentOrigin: iframeNotifyParentOrigin = args.iframeNotifyParentOrigin, iframeScriptOrigin: iframeScriptOrigin = args.iframeScriptOrigin, silent_redirect_uri: silent_redirect_uri = args.redirect_uri, silentRequestTimeoutInSeconds: silentRequestTimeoutInSeconds = $631c75f8a3fcffe9$var$DefaultSilentRequestTimeoutInSeconds, automaticSilentRenew: automaticSilentRenew = true, validateSubOnSilentRenew: validateSubOnSilentRenew = true, includeIdTokenInSilentRenew: includeIdTokenInSilentRenew = false, monitorSession: monitorSession = false, monitorAnonymousSession: monitorAnonymousSession = false, checkSessionIntervalInSeconds: checkSessionIntervalInSeconds = $631c75f8a3fcffe9$var$DefaultCheckSessionIntervalInSeconds, query_status_response_type: query_status_response_type = \"code\", stopCheckSessionOnError: stopCheckSessionOnError = true, revokeTokenTypes: revokeTokenTypes = [\n            \"access_token\",\n            \"refresh_token\"\n        ], revokeTokensOnSignout: revokeTokensOnSignout = false, includeIdTokenInSilentSignout: includeIdTokenInSilentSignout = false, accessTokenExpiringNotificationTimeInSeconds: accessTokenExpiringNotificationTimeInSeconds = $631c75f8a3fcffe9$var$DefaultAccessTokenExpiringNotificationTimeInSeconds, userStore: userStore } = args;\n        super(args);\n        this.popup_redirect_uri = popup_redirect_uri;\n        this.popup_post_logout_redirect_uri = popup_post_logout_redirect_uri;\n        this.popupWindowFeatures = popupWindowFeatures;\n        this.popupWindowTarget = popupWindowTarget;\n        this.redirectMethod = redirectMethod;\n        this.redirectTarget = redirectTarget;\n        this.iframeNotifyParentOrigin = iframeNotifyParentOrigin;\n        this.iframeScriptOrigin = iframeScriptOrigin;\n        this.silent_redirect_uri = silent_redirect_uri;\n        this.silentRequestTimeoutInSeconds = silentRequestTimeoutInSeconds;\n        this.automaticSilentRenew = automaticSilentRenew;\n        this.validateSubOnSilentRenew = validateSubOnSilentRenew;\n        this.includeIdTokenInSilentRenew = includeIdTokenInSilentRenew;\n        this.monitorSession = monitorSession;\n        this.monitorAnonymousSession = monitorAnonymousSession;\n        this.checkSessionIntervalInSeconds = checkSessionIntervalInSeconds;\n        this.stopCheckSessionOnError = stopCheckSessionOnError;\n        this.query_status_response_type = query_status_response_type;\n        this.revokeTokenTypes = revokeTokenTypes;\n        this.revokeTokensOnSignout = revokeTokensOnSignout;\n        this.includeIdTokenInSilentSignout = includeIdTokenInSilentSignout;\n        this.accessTokenExpiringNotificationTimeInSeconds = accessTokenExpiringNotificationTimeInSeconds;\n        if (userStore) this.userStore = userStore;\n        else {\n            const store = typeof window !== \"undefined\" ? window.sessionStorage : new $631c75f8a3fcffe9$var$InMemoryWebStorage();\n            this.userStore = new $631c75f8a3fcffe9$var$WebStorageStateStore({\n                store: store\n            });\n        }\n    }\n};\n// src/navigators/IFrameWindow.ts\nvar $631c75f8a3fcffe9$var$IFrameWindow = class extends $631c75f8a3fcffe9$var$AbstractChildWindow {\n    constructor({ silentRequestTimeoutInSeconds: silentRequestTimeoutInSeconds = $631c75f8a3fcffe9$var$DefaultSilentRequestTimeoutInSeconds }){\n        super();\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"IFrameWindow\");\n        this._timeoutInSeconds = silentRequestTimeoutInSeconds;\n        this._frame = $631c75f8a3fcffe9$var$IFrameWindow.createHiddenIframe();\n        this._window = this._frame.contentWindow;\n    }\n    static createHiddenIframe() {\n        const iframe = window.document.createElement(\"iframe\");\n        iframe.style.visibility = \"hidden\";\n        iframe.style.position = \"fixed\";\n        iframe.style.left = \"-1000px\";\n        iframe.style.top = \"0\";\n        iframe.width = \"0\";\n        iframe.height = \"0\";\n        window.document.body.appendChild(iframe);\n        return iframe;\n    }\n    async navigate(params) {\n        this._logger.debug(\"navigate: Using timeout of:\", this._timeoutInSeconds);\n        const timer = setTimeout(()=>this._abort.raise(new $631c75f8a3fcffe9$var$ErrorTimeout(\"IFrame timed out without a response\")), this._timeoutInSeconds * 1e3);\n        this._disposeHandlers.add(()=>clearTimeout(timer));\n        return await super.navigate(params);\n    }\n    close() {\n        var _a;\n        if (this._frame) {\n            if (this._frame.parentNode) {\n                this._frame.addEventListener(\"load\", (ev)=>{\n                    var _a2;\n                    const frame = ev.target;\n                    (_a2 = frame.parentNode) == null || _a2.removeChild(frame);\n                    this._abort.raise(new Error(\"IFrame removed from DOM\"));\n                }, true);\n                (_a = this._frame.contentWindow) == null || _a.location.replace(\"about:blank\");\n            }\n            this._frame = null;\n        }\n        this._window = null;\n    }\n    static notifyParent(url, targetOrigin) {\n        return super._notifyParent(window.parent, url, false, targetOrigin);\n    }\n};\n// src/navigators/IFrameNavigator.ts\nvar $631c75f8a3fcffe9$var$IFrameNavigator = class {\n    constructor(_settings){\n        this._settings = _settings;\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"IFrameNavigator\");\n    }\n    async prepare({ silentRequestTimeoutInSeconds: silentRequestTimeoutInSeconds = this._settings.silentRequestTimeoutInSeconds }) {\n        return new $631c75f8a3fcffe9$var$IFrameWindow({\n            silentRequestTimeoutInSeconds: silentRequestTimeoutInSeconds\n        });\n    }\n    async callback(url) {\n        this._logger.create(\"callback\");\n        $631c75f8a3fcffe9$var$IFrameWindow.notifyParent(url, this._settings.iframeNotifyParentOrigin);\n    }\n};\n// src/navigators/PopupWindow.ts\nvar $631c75f8a3fcffe9$var$checkForPopupClosedInterval = 500;\nvar $631c75f8a3fcffe9$var$second = 1e3;\nvar $631c75f8a3fcffe9$var$PopupWindow = class extends $631c75f8a3fcffe9$var$AbstractChildWindow {\n    constructor({ popupWindowTarget: popupWindowTarget = $631c75f8a3fcffe9$var$DefaultPopupTarget, popupWindowFeatures: popupWindowFeatures = {} }){\n        super();\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"PopupWindow\");\n        const centeredPopup = $631c75f8a3fcffe9$var$PopupUtils.center({\n            ...$631c75f8a3fcffe9$var$DefaultPopupWindowFeatures,\n            ...popupWindowFeatures\n        });\n        this._window = window.open(void 0, popupWindowTarget, $631c75f8a3fcffe9$var$PopupUtils.serialize(centeredPopup));\n        if (popupWindowFeatures.closePopupWindowAfterInSeconds && popupWindowFeatures.closePopupWindowAfterInSeconds > 0) setTimeout(()=>{\n            if (!this._window || typeof this._window.closed !== \"boolean\" || this._window.closed) {\n                this._abort.raise(new Error(\"Popup blocked by user\"));\n                return;\n            }\n            this.close();\n        }, popupWindowFeatures.closePopupWindowAfterInSeconds * $631c75f8a3fcffe9$var$second);\n    }\n    async navigate(params) {\n        var _a;\n        (_a = this._window) == null || _a.focus();\n        const popupClosedInterval = setInterval(()=>{\n            if (!this._window || this._window.closed) this._abort.raise(new Error(\"Popup closed by user\"));\n        }, $631c75f8a3fcffe9$var$checkForPopupClosedInterval);\n        this._disposeHandlers.add(()=>clearInterval(popupClosedInterval));\n        return await super.navigate(params);\n    }\n    close() {\n        if (this._window) {\n            if (!this._window.closed) {\n                this._window.close();\n                this._abort.raise(new Error(\"Popup closed\"));\n            }\n        }\n        this._window = null;\n    }\n    static notifyOpener(url, keepOpen) {\n        if (!window.opener) throw new Error(\"No window.opener. Can't complete notification.\");\n        return super._notifyParent(window.opener, url, keepOpen);\n    }\n};\n// src/navigators/PopupNavigator.ts\nvar $631c75f8a3fcffe9$var$PopupNavigator = class {\n    constructor(_settings){\n        this._settings = _settings;\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"PopupNavigator\");\n    }\n    async prepare({ popupWindowFeatures: popupWindowFeatures = this._settings.popupWindowFeatures, popupWindowTarget: popupWindowTarget = this._settings.popupWindowTarget }) {\n        return new $631c75f8a3fcffe9$var$PopupWindow({\n            popupWindowFeatures: popupWindowFeatures,\n            popupWindowTarget: popupWindowTarget\n        });\n    }\n    async callback(url, { keepOpen: keepOpen = false }) {\n        this._logger.create(\"callback\");\n        $631c75f8a3fcffe9$var$PopupWindow.notifyOpener(url, keepOpen);\n    }\n};\n// src/navigators/RedirectNavigator.ts\nvar $631c75f8a3fcffe9$var$RedirectNavigator = class {\n    constructor(_settings){\n        this._settings = _settings;\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"RedirectNavigator\");\n    }\n    async prepare({ redirectMethod: redirectMethod = this._settings.redirectMethod, redirectTarget: redirectTarget = this._settings.redirectTarget }) {\n        var _a;\n        this._logger.create(\"prepare\");\n        let targetWindow = window.self;\n        if (redirectTarget === \"top\") targetWindow = (_a = window.top) != null ? _a : window.self;\n        const redirect = targetWindow.location[redirectMethod].bind(targetWindow.location);\n        let abort;\n        return {\n            navigate: async (params)=>{\n                this._logger.create(\"navigate\");\n                const promise = new Promise((resolve, reject)=>{\n                    abort = reject;\n                });\n                redirect(params.url);\n                return await promise;\n            },\n            close: ()=>{\n                this._logger.create(\"close\");\n                abort == null || abort(new Error(\"Redirect aborted\"));\n                targetWindow.stop();\n            }\n        };\n    }\n    async callback() {\n        return;\n    }\n};\n// src/UserManagerEvents.ts\nvar $631c75f8a3fcffe9$var$UserManagerEvents = class extends $631c75f8a3fcffe9$var$AccessTokenEvents {\n    constructor(settings){\n        super({\n            expiringNotificationTimeInSeconds: settings.accessTokenExpiringNotificationTimeInSeconds\n        });\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"UserManagerEvents\");\n        this._userLoaded = new $631c75f8a3fcffe9$var$Event(\"User loaded\");\n        this._userUnloaded = new $631c75f8a3fcffe9$var$Event(\"User unloaded\");\n        this._silentRenewError = new $631c75f8a3fcffe9$var$Event(\"Silent renew error\");\n        this._userSignedIn = new $631c75f8a3fcffe9$var$Event(\"User signed in\");\n        this._userSignedOut = new $631c75f8a3fcffe9$var$Event(\"User signed out\");\n        this._userSessionChanged = new $631c75f8a3fcffe9$var$Event(\"User session changed\");\n    }\n    load(user, raiseEvent = true) {\n        super.load(user);\n        if (raiseEvent) this._userLoaded.raise(user);\n    }\n    unload() {\n        super.unload();\n        this._userUnloaded.raise();\n    }\n    /**\n   * Add callback: Raised when a user session has been established (or re-established).\n   */ addUserLoaded(cb) {\n        return this._userLoaded.addHandler(cb);\n    }\n    /**\n   * Remove callback: Raised when a user session has been established (or re-established).\n   */ removeUserLoaded(cb) {\n        return this._userLoaded.removeHandler(cb);\n    }\n    /**\n   * Add callback: Raised when a user session has been terminated.\n   */ addUserUnloaded(cb) {\n        return this._userUnloaded.addHandler(cb);\n    }\n    /**\n   * Remove callback: Raised when a user session has been terminated.\n   */ removeUserUnloaded(cb) {\n        return this._userUnloaded.removeHandler(cb);\n    }\n    /**\n   * Add callback: Raised when the automatic silent renew has failed.\n   */ addSilentRenewError(cb) {\n        return this._silentRenewError.addHandler(cb);\n    }\n    /**\n   * Remove callback: Raised when the automatic silent renew has failed.\n   */ removeSilentRenewError(cb) {\n        return this._silentRenewError.removeHandler(cb);\n    }\n    /**\n   * @internal\n   */ _raiseSilentRenewError(e) {\n        this._silentRenewError.raise(e);\n    }\n    /**\n   * Add callback: Raised when the user is signed in (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */ addUserSignedIn(cb) {\n        return this._userSignedIn.addHandler(cb);\n    }\n    /**\n   * Remove callback: Raised when the user is signed in (when `monitorSession` is set).\n   */ removeUserSignedIn(cb) {\n        this._userSignedIn.removeHandler(cb);\n    }\n    /**\n   * @internal\n   */ _raiseUserSignedIn() {\n        this._userSignedIn.raise();\n    }\n    /**\n   * Add callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */ addUserSignedOut(cb) {\n        return this._userSignedOut.addHandler(cb);\n    }\n    /**\n   * Remove callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n   */ removeUserSignedOut(cb) {\n        this._userSignedOut.removeHandler(cb);\n    }\n    /**\n   * @internal\n   */ _raiseUserSignedOut() {\n        this._userSignedOut.raise();\n    }\n    /**\n   * Add callback: Raised when the user session changed (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */ addUserSessionChanged(cb) {\n        return this._userSessionChanged.addHandler(cb);\n    }\n    /**\n   * Remove callback: Raised when the user session changed (when `monitorSession` is set).\n   */ removeUserSessionChanged(cb) {\n        this._userSessionChanged.removeHandler(cb);\n    }\n    /**\n   * @internal\n   */ _raiseUserSessionChanged() {\n        this._userSessionChanged.raise();\n    }\n};\n// src/SilentRenewService.ts\nvar $631c75f8a3fcffe9$var$SilentRenewService = class {\n    constructor(_userManager){\n        this._userManager = _userManager;\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"SilentRenewService\");\n        this._isStarted = false;\n        this._retryTimer = new $631c75f8a3fcffe9$var$Timer(\"Retry Silent Renew\");\n        this._tokenExpiring = async ()=>{\n            const logger2 = this._logger.create(\"_tokenExpiring\");\n            try {\n                await this._userManager.signinSilent();\n                logger2.debug(\"silent token renewal successful\");\n            } catch (err) {\n                if (err instanceof $631c75f8a3fcffe9$var$ErrorTimeout) {\n                    logger2.warn(\"ErrorTimeout from signinSilent:\", err, \"retry in 5s\");\n                    this._retryTimer.init(5);\n                    return;\n                }\n                logger2.error(\"Error from signinSilent:\", err);\n                this._userManager.events._raiseSilentRenewError(err);\n            }\n        };\n    }\n    async start() {\n        const logger2 = this._logger.create(\"start\");\n        if (!this._isStarted) {\n            this._isStarted = true;\n            this._userManager.events.addAccessTokenExpiring(this._tokenExpiring);\n            this._retryTimer.addHandler(this._tokenExpiring);\n            try {\n                await this._userManager.getUser();\n            } catch (err) {\n                logger2.error(\"getUser error\", err);\n            }\n        }\n    }\n    stop() {\n        if (this._isStarted) {\n            this._retryTimer.cancel();\n            this._retryTimer.removeHandler(this._tokenExpiring);\n            this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring);\n            this._isStarted = false;\n        }\n    }\n};\n// src/RefreshState.ts\nvar $631c75f8a3fcffe9$var$RefreshState = class {\n    constructor(args, resource){\n        this.refresh_token = args.refresh_token;\n        this.id_token = args.id_token;\n        this.session_state = args.session_state;\n        this.scope = args.scope;\n        this.profile = args.profile;\n        this.resource = resource;\n        this.data = args.state;\n    }\n};\n// src/UserManager.ts\nvar $631c75f8a3fcffe9$var$UserManager = class {\n    constructor(settings, redirectNavigator, popupNavigator, iframeNavigator){\n        this._logger = new $631c75f8a3fcffe9$var$Logger(\"UserManager\");\n        this.settings = new $631c75f8a3fcffe9$var$UserManagerSettingsStore(settings);\n        this._client = new $631c75f8a3fcffe9$var$OidcClient(settings);\n        this._redirectNavigator = redirectNavigator != null ? redirectNavigator : new $631c75f8a3fcffe9$var$RedirectNavigator(this.settings);\n        this._popupNavigator = popupNavigator != null ? popupNavigator : new $631c75f8a3fcffe9$var$PopupNavigator(this.settings);\n        this._iframeNavigator = iframeNavigator != null ? iframeNavigator : new $631c75f8a3fcffe9$var$IFrameNavigator(this.settings);\n        this._events = new $631c75f8a3fcffe9$var$UserManagerEvents(this.settings);\n        this._silentRenewService = new $631c75f8a3fcffe9$var$SilentRenewService(this);\n        if (this.settings.automaticSilentRenew) this.startSilentRenew();\n        this._sessionMonitor = null;\n        if (this.settings.monitorSession) this._sessionMonitor = new $631c75f8a3fcffe9$var$SessionMonitor(this);\n    }\n    /** Returns an object used to register for events raised by the `UserManager`. */ get events() {\n        return this._events;\n    }\n    /** Returns an object used to access the metadata configuration of the OIDC provider. */ get metadataService() {\n        return this._client.metadataService;\n    }\n    /**\n   * Returns promise to load the `User` object for the currently authenticated user.\n   */ async getUser() {\n        const logger2 = this._logger.create(\"getUser\");\n        const user = await this._loadUser();\n        if (user) {\n            logger2.info(\"user loaded\");\n            this._events.load(user, false);\n            return user;\n        }\n        logger2.info(\"user not found in storage\");\n        return null;\n    }\n    /**\n   * Returns promise to remove from any storage the currently authenticated user.\n   */ async removeUser() {\n        const logger2 = this._logger.create(\"removeUser\");\n        await this.storeUser(null);\n        logger2.info(\"user removed from storage\");\n        this._events.unload();\n    }\n    /**\n   * Returns promise to trigger a redirect of the current window to the authorization endpoint.\n   */ async signinRedirect(args = {}) {\n        this._logger.create(\"signinRedirect\");\n        const { redirectMethod: redirectMethod, ...requestArgs } = args;\n        const handle = await this._redirectNavigator.prepare({\n            redirectMethod: redirectMethod\n        });\n        await this._signinStart({\n            request_type: \"si:r\",\n            ...requestArgs\n        }, handle);\n    }\n    /**\n   * Returns promise to process response from the authorization endpoint. The result of the promise is the authenticated `User`.\n   */ async signinRedirectCallback(url = window.location.href) {\n        const logger2 = this._logger.create(\"signinRedirectCallback\");\n        const user = await this._signinEnd(url);\n        if (user.profile && user.profile.sub) logger2.info(\"success, signed in subject\", user.profile.sub);\n        else logger2.info(\"no subject\");\n        return user;\n    }\n    /**\n   * Returns promise to process the signin with user/password. The result of the promise is the authenticated `User`.\n   *\n   * Throws an ErrorResponse in case of wrong authentication.\n   */ async signinResourceOwnerCredentials({ username: username, password: password, skipUserInfo: skipUserInfo = false }) {\n        const logger2 = this._logger.create(\"signinResourceOwnerCredential\");\n        const signinResponse = await this._client.processResourceOwnerPasswordCredentials({\n            username: username,\n            password: password,\n            skipUserInfo: skipUserInfo,\n            extraTokenParams: this.settings.extraTokenParams\n        });\n        logger2.debug(\"got signin response\");\n        const user = await this._buildUser(signinResponse);\n        if (user.profile && user.profile.sub) logger2.info(\"success, signed in subject\", user.profile.sub);\n        else logger2.info(\"no subject\");\n        return user;\n    }\n    /**\n   * Returns promise to trigger a request (via a popup window) to the authorization endpoint. The result of the promise is the authenticated `User`.\n   */ async signinPopup(args = {}) {\n        const logger2 = this._logger.create(\"signinPopup\");\n        const { popupWindowFeatures: popupWindowFeatures, popupWindowTarget: popupWindowTarget, ...requestArgs } = args;\n        const url = this.settings.popup_redirect_uri;\n        if (!url) logger2.throw(new Error(\"No popup_redirect_uri configured\"));\n        const handle = await this._popupNavigator.prepare({\n            popupWindowFeatures: popupWindowFeatures,\n            popupWindowTarget: popupWindowTarget\n        });\n        const user = await this._signin({\n            request_type: \"si:p\",\n            redirect_uri: url,\n            display: \"popup\",\n            ...requestArgs\n        }, handle);\n        if (user) {\n            if (user.profile && user.profile.sub) logger2.info(\"success, signed in subject\", user.profile.sub);\n            else logger2.info(\"no subject\");\n        }\n        return user;\n    }\n    /**\n   * Returns promise to notify the opening window of response from the authorization endpoint.\n   */ async signinPopupCallback(url = window.location.href, keepOpen = false) {\n        const logger2 = this._logger.create(\"signinPopupCallback\");\n        await this._popupNavigator.callback(url, {\n            keepOpen: keepOpen\n        });\n        logger2.info(\"success\");\n    }\n    /**\n   * Returns promise to trigger a silent request (via an iframe) to the authorization endpoint.\n   * The result of the promise is the authenticated `User`.\n   */ async signinSilent(args = {}) {\n        var _a;\n        const logger2 = this._logger.create(\"signinSilent\");\n        const { silentRequestTimeoutInSeconds: silentRequestTimeoutInSeconds, resource: resource, ...requestArgs } = args;\n        let user = await this._loadUser();\n        if (user == null ? void 0 : user.refresh_token) {\n            logger2.debug(\"using refresh token\");\n            const state = new $631c75f8a3fcffe9$var$RefreshState(user, resource);\n            return await this._useRefreshToken(state);\n        }\n        const url = this.settings.silent_redirect_uri;\n        if (!url) logger2.throw(new Error(\"No silent_redirect_uri configured\"));\n        let verifySub;\n        if (user && this.settings.validateSubOnSilentRenew) {\n            logger2.debug(\"subject prior to silent renew:\", user.profile.sub);\n            verifySub = user.profile.sub;\n        }\n        const handle = await this._iframeNavigator.prepare({\n            silentRequestTimeoutInSeconds: silentRequestTimeoutInSeconds\n        });\n        user = await this._signin({\n            request_type: \"si:s\",\n            redirect_uri: url,\n            prompt: \"none\",\n            id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,\n            ...requestArgs\n        }, handle, verifySub);\n        if (user) {\n            if ((_a = user.profile) == null ? void 0 : _a.sub) logger2.info(\"success, signed in subject\", user.profile.sub);\n            else logger2.info(\"no subject\");\n        }\n        return user;\n    }\n    async _useRefreshToken(state) {\n        const response = await this._client.useRefreshToken({\n            state: state,\n            timeoutInSeconds: this.settings.silentRequestTimeoutInSeconds\n        });\n        const user = new $631c75f8a3fcffe9$var$User({\n            ...state,\n            ...response\n        });\n        await this.storeUser(user);\n        this._events.load(user);\n        return user;\n    }\n    /**\n   * Returns promise to notify the parent window of response from the authorization endpoint.\n   */ async signinSilentCallback(url = window.location.href) {\n        const logger2 = this._logger.create(\"signinSilentCallback\");\n        await this._iframeNavigator.callback(url);\n        logger2.info(\"success\");\n    }\n    async signinCallback(url = window.location.href) {\n        const { state: state } = await this._client.readSigninResponseState(url);\n        switch(state.request_type){\n            case \"si:r\":\n                return await this.signinRedirectCallback(url);\n            case \"si:p\":\n                return await this.signinPopupCallback(url);\n            case \"si:s\":\n                return await this.signinSilentCallback(url);\n            default:\n                throw new Error(\"invalid response_type in state\");\n        }\n    }\n    async signoutCallback(url = window.location.href, keepOpen = false) {\n        const { state: state } = await this._client.readSignoutResponseState(url);\n        if (!state) return void 0;\n        switch(state.request_type){\n            case \"so:r\":\n                return await this.signoutRedirectCallback(url);\n            case \"so:p\":\n                await this.signoutPopupCallback(url, keepOpen);\n                break;\n            case \"so:s\":\n                await this.signoutSilentCallback(url);\n                break;\n            default:\n                throw new Error(\"invalid response_type in state\");\n        }\n        return void 0;\n    }\n    /**\n   * Returns promise to query OP for user's current signin status. Returns object with session_state and subject identifier.\n   */ async querySessionStatus(args = {}) {\n        const logger2 = this._logger.create(\"querySessionStatus\");\n        const { silentRequestTimeoutInSeconds: silentRequestTimeoutInSeconds, ...requestArgs } = args;\n        const url = this.settings.silent_redirect_uri;\n        if (!url) logger2.throw(new Error(\"No silent_redirect_uri configured\"));\n        const user = await this._loadUser();\n        const handle = await this._iframeNavigator.prepare({\n            silentRequestTimeoutInSeconds: silentRequestTimeoutInSeconds\n        });\n        const navResponse = await this._signinStart({\n            request_type: \"si:s\",\n            // this acts like a signin silent\n            redirect_uri: url,\n            prompt: \"none\",\n            id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,\n            response_type: this.settings.query_status_response_type,\n            scope: \"openid\",\n            skipUserInfo: true,\n            ...requestArgs\n        }, handle);\n        try {\n            const signinResponse = await this._client.processSigninResponse(navResponse.url);\n            logger2.debug(\"got signin response\");\n            if (signinResponse.session_state && signinResponse.profile.sub) {\n                logger2.info(\"success for subject\", signinResponse.profile.sub);\n                return {\n                    session_state: signinResponse.session_state,\n                    sub: signinResponse.profile.sub,\n                    sid: signinResponse.profile.sid\n                };\n            }\n            logger2.info(\"success, user not authenticated\");\n            return null;\n        } catch (err) {\n            if (this.settings.monitorAnonymousSession && err instanceof $631c75f8a3fcffe9$var$ErrorResponse) switch(err.error){\n                case \"login_required\":\n                case \"consent_required\":\n                case \"interaction_required\":\n                case \"account_selection_required\":\n                    logger2.info(\"success for anonymous user\");\n                    return {\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        session_state: err.session_state\n                    };\n            }\n            throw err;\n        }\n    }\n    async _signin(args, handle, verifySub) {\n        const navResponse = await this._signinStart(args, handle);\n        return await this._signinEnd(navResponse.url, verifySub);\n    }\n    async _signinStart(args, handle) {\n        const logger2 = this._logger.create(\"_signinStart\");\n        try {\n            const signinRequest = await this._client.createSigninRequest(args);\n            logger2.debug(\"got signin request\");\n            return await handle.navigate({\n                url: signinRequest.url,\n                state: signinRequest.state.id,\n                response_mode: signinRequest.state.response_mode,\n                scriptOrigin: this.settings.iframeScriptOrigin\n            });\n        } catch (err) {\n            logger2.debug(\"error after preparing navigator, closing navigator window\");\n            handle.close();\n            throw err;\n        }\n    }\n    async _signinEnd(url, verifySub) {\n        const logger2 = this._logger.create(\"_signinEnd\");\n        const signinResponse = await this._client.processSigninResponse(url);\n        logger2.debug(\"got signin response\");\n        const user = await this._buildUser(signinResponse, verifySub);\n        return user;\n    }\n    async _buildUser(signinResponse, verifySub) {\n        const logger2 = this._logger.create(\"_buildUser\");\n        const user = new $631c75f8a3fcffe9$var$User(signinResponse);\n        if (verifySub) {\n            if (verifySub !== user.profile.sub) {\n                logger2.debug(\"current user does not match user returned from signin. sub from signin:\", user.profile.sub);\n                throw new $631c75f8a3fcffe9$var$ErrorResponse({\n                    ...signinResponse,\n                    error: \"login_required\"\n                });\n            }\n            logger2.debug(\"current user matches user returned from signin\");\n        }\n        await this.storeUser(user);\n        logger2.debug(\"user stored\");\n        this._events.load(user);\n        return user;\n    }\n    /**\n   * Returns promise to trigger a redirect of the current window to the end session endpoint.\n   */ async signoutRedirect(args = {}) {\n        const logger2 = this._logger.create(\"signoutRedirect\");\n        const { redirectMethod: redirectMethod, ...requestArgs } = args;\n        const handle = await this._redirectNavigator.prepare({\n            redirectMethod: redirectMethod\n        });\n        await this._signoutStart({\n            request_type: \"so:r\",\n            post_logout_redirect_uri: this.settings.post_logout_redirect_uri,\n            ...requestArgs\n        }, handle);\n        logger2.info(\"success\");\n    }\n    /**\n   * Returns promise to process response from the end session endpoint.\n   */ async signoutRedirectCallback(url = window.location.href) {\n        const logger2 = this._logger.create(\"signoutRedirectCallback\");\n        const response = await this._signoutEnd(url);\n        logger2.info(\"success\");\n        return response;\n    }\n    /**\n   * Returns promise to trigger a redirect of a popup window window to the end session endpoint.\n   */ async signoutPopup(args = {}) {\n        const logger2 = this._logger.create(\"signoutPopup\");\n        const { popupWindowFeatures: popupWindowFeatures, popupWindowTarget: popupWindowTarget, ...requestArgs } = args;\n        const url = this.settings.popup_post_logout_redirect_uri;\n        const handle = await this._popupNavigator.prepare({\n            popupWindowFeatures: popupWindowFeatures,\n            popupWindowTarget: popupWindowTarget\n        });\n        await this._signout({\n            request_type: \"so:p\",\n            post_logout_redirect_uri: url,\n            // we're putting a dummy entry in here because we\n            // need a unique id from the state for notification\n            // to the parent window, which is necessary if we\n            // plan to return back to the client after signout\n            // and so we can close the popup after signout\n            state: url == null ? void 0 : {},\n            ...requestArgs\n        }, handle);\n        logger2.info(\"success\");\n    }\n    /**\n   * Returns promise to process response from the end session endpoint from a popup window.\n   */ async signoutPopupCallback(url = window.location.href, keepOpen = false) {\n        const logger2 = this._logger.create(\"signoutPopupCallback\");\n        await this._popupNavigator.callback(url, {\n            keepOpen: keepOpen\n        });\n        logger2.info(\"success\");\n    }\n    async _signout(args, handle) {\n        const navResponse = await this._signoutStart(args, handle);\n        return await this._signoutEnd(navResponse.url);\n    }\n    async _signoutStart(args = {}, handle) {\n        var _a;\n        const logger2 = this._logger.create(\"_signoutStart\");\n        try {\n            const user = await this._loadUser();\n            logger2.debug(\"loaded current user from storage\");\n            if (this.settings.revokeTokensOnSignout) await this._revokeInternal(user);\n            const id_token = args.id_token_hint || user && user.id_token;\n            if (id_token) {\n                logger2.debug(\"setting id_token_hint in signout request\");\n                args.id_token_hint = id_token;\n            }\n            await this.removeUser();\n            logger2.debug(\"user removed, creating signout request\");\n            const signoutRequest = await this._client.createSignoutRequest(args);\n            logger2.debug(\"got signout request\");\n            return await handle.navigate({\n                url: signoutRequest.url,\n                state: (_a = signoutRequest.state) == null ? void 0 : _a.id,\n                scriptOrigin: this.settings.iframeScriptOrigin\n            });\n        } catch (err) {\n            logger2.debug(\"error after preparing navigator, closing navigator window\");\n            handle.close();\n            throw err;\n        }\n    }\n    async _signoutEnd(url) {\n        const logger2 = this._logger.create(\"_signoutEnd\");\n        const signoutResponse = await this._client.processSignoutResponse(url);\n        logger2.debug(\"got signout response\");\n        return signoutResponse;\n    }\n    /**\n   * Returns promise to trigger a silent request (via an iframe) to the end session endpoint.\n   */ async signoutSilent(args = {}) {\n        var _a;\n        const logger2 = this._logger.create(\"signoutSilent\");\n        const { silentRequestTimeoutInSeconds: silentRequestTimeoutInSeconds, ...requestArgs } = args;\n        const id_token_hint = this.settings.includeIdTokenInSilentSignout ? (_a = await this._loadUser()) == null ? void 0 : _a.id_token : void 0;\n        const url = this.settings.popup_post_logout_redirect_uri;\n        const handle = await this._iframeNavigator.prepare({\n            silentRequestTimeoutInSeconds: silentRequestTimeoutInSeconds\n        });\n        await this._signout({\n            request_type: \"so:s\",\n            post_logout_redirect_uri: url,\n            id_token_hint: id_token_hint,\n            ...requestArgs\n        }, handle);\n        logger2.info(\"success\");\n    }\n    /**\n   * Returns promise to notify the parent window of response from the end session endpoint.\n   */ async signoutSilentCallback(url = window.location.href) {\n        const logger2 = this._logger.create(\"signoutSilentCallback\");\n        await this._iframeNavigator.callback(url);\n        logger2.info(\"success\");\n    }\n    async revokeTokens(types) {\n        const user = await this._loadUser();\n        await this._revokeInternal(user, types);\n    }\n    async _revokeInternal(user, types = this.settings.revokeTokenTypes) {\n        const logger2 = this._logger.create(\"_revokeInternal\");\n        if (!user) return;\n        const typesPresent = types.filter((type)=>typeof user[type] === \"string\");\n        if (!typesPresent.length) {\n            logger2.debug(\"no need to revoke due to no token(s)\");\n            return;\n        }\n        for (const type of typesPresent){\n            await this._client.revokeToken(user[type], // eslint-disable-line @typescript-eslint/no-non-null-assertion\n            type);\n            logger2.info(`${type} revoked successfully`);\n            if (type !== \"access_token\") user[type] = null;\n        }\n        await this.storeUser(user);\n        logger2.debug(\"user stored\");\n        this._events.load(user);\n    }\n    /**\n   * Enables silent renew for the `UserManager`.\n   */ startSilentRenew() {\n        this._logger.create(\"startSilentRenew\");\n        this._silentRenewService.start();\n    }\n    /**\n   * Disables silent renew for the `UserManager`.\n   */ stopSilentRenew() {\n        this._silentRenewService.stop();\n    }\n    get _userStoreKey() {\n        return `user:${this.settings.authority}:${this.settings.client_id}`;\n    }\n    async _loadUser() {\n        const logger2 = this._logger.create(\"_loadUser\");\n        const storageString = await this.settings.userStore.get(this._userStoreKey);\n        if (storageString) {\n            logger2.debug(\"user storageString loaded\");\n            return $631c75f8a3fcffe9$var$User.fromStorageString(storageString);\n        }\n        logger2.debug(\"no user storageString\");\n        return null;\n    }\n    async storeUser(user) {\n        const logger2 = this._logger.create(\"storeUser\");\n        if (user) {\n            logger2.debug(\"storing user\");\n            const storageString = user.toStorageString();\n            await this.settings.userStore.set(this._userStoreKey, storageString);\n        } else {\n            this._logger.debug(\"removing user\");\n            await this.settings.userStore.remove(this._userStoreKey);\n        }\n    }\n    /**\n   * Removes stale state entries in storage for incomplete authorize requests.\n   */ async clearStaleState() {\n        await this._client.clearStaleState();\n    }\n};\n// package.json\nvar $631c75f8a3fcffe9$var$version = \"2.4.1\";\n// src/Version.ts\nvar $631c75f8a3fcffe9$var$Version = $631c75f8a3fcffe9$var$version;\n\n\nconst $7bc1e5a75795e44f$var$cognitoAuthConfig = {\n    authority: `https://cognito-idp.us-east-1.amazonaws.com/${\"us-east-1_xsdzha3Ck\"}`,\n    client_id: \"25iso3inbh42eqguqmtssc1gbi\",\n    redirect_uri: \"http://localhost:1234\",\n    response_type: 'code',\n    scope: 'phone openid email',\n    revokeTokenTypes: [\n        'refresh_token'\n    ],\n    automaticSilentRenew: false\n};\nconst $7bc1e5a75795e44f$export$cc5a9a3851cbd70d = new (0, $631c75f8a3fcffe9$exports.UserManager)({\n    ...$7bc1e5a75795e44f$var$cognitoAuthConfig\n});\nasync function $7bc1e5a75795e44f$export$9670d83f11d4b64a() {\n    await $7bc1e5a75795e44f$export$cc5a9a3851cbd70d.signinRedirect();\n}\nasync function $7bc1e5a75795e44f$export$b0ac3a1c242cb1ea() {\n    try {\n        // Clear the user from the UserManager first\n        await $7bc1e5a75795e44f$export$cc5a9a3851cbd70d.removeUser();\n    } catch (error) {\n        console.error('Error clearing local session:', error);\n    }\n    // For Cognito, we need to manually construct the logout URL with client_id\n    const logoutUrl = `https://fragments-ui-1757690046.auth.us-east-1.amazoncognito.com/logout?client_id=${\"25iso3inbh42eqguqmtssc1gbi\"}&logout_uri=${encodeURIComponent(\"http://localhost:1234\")}`;\n    window.location.href = logoutUrl;\n}\nfunction $7bc1e5a75795e44f$var$formatUser(user) {\n    console.log('User Authenticated', {\n        user: user\n    });\n    return {\n        username: user.profile.preferred_username || user.profile.email,\n        email: user.profile.email,\n        idToken: user.id_token,\n        accessToken: user.access_token,\n        authorizationHeaders: (type = 'application/json')=>({\n                'Content-Type': type,\n                Authorization: `Bearer ${user.id_token}`\n            })\n    };\n}\nasync function $7bc1e5a75795e44f$export$7cbf767827cd68ba() {\n    if (window.location.search.includes('code=')) {\n        const user = await $7bc1e5a75795e44f$export$cc5a9a3851cbd70d.signinCallback();\n        window.history.replaceState({}, document.title, window.location.pathname);\n        return $7bc1e5a75795e44f$var$formatUser(user);\n    }\n    const user = await $7bc1e5a75795e44f$export$cc5a9a3851cbd70d.getUser();\n    return user ? $7bc1e5a75795e44f$var$formatUser(user) : null;\n}\n\n\nconst $96e14f2a7c3555e4$var$apiUrl = \"http://localhost:8080\";\nasync function $96e14f2a7c3555e4$export$4517903f0097c2bd(user) {\n    const response = await fetch(`${$96e14f2a7c3555e4$var$apiUrl}/v1/fragments`, {\n        headers: user.authorizationHeaders()\n    });\n    if (!response.ok) throw new Error(`Failed to get fragments: ${response.status}`);\n    return await response.json();\n}\n\n\nasync function $e73bf42412feb220$var$init() {\n    const userSection = document.querySelector('#user');\n    const loginBtn = document.querySelector('#login');\n    const user = await (0, $7bc1e5a75795e44f$export$7cbf767827cd68ba)();\n    if (user) {\n        userSection.innerHTML = `\n      <p>Welcome, ${user.username}!</p>\n      <button id=\"logout\">Logout</button>\n    `;\n        const logoutBtn = document.querySelector('#logout');\n        logoutBtn.addEventListener('click', async ()=>{\n            await (0, $7bc1e5a75795e44f$export$b0ac3a1c242cb1ea)();\n        });\n        try {\n            const fragments = await (0, $96e14f2a7c3555e4$export$4517903f0097c2bd)(user);\n            console.log('User fragments:', fragments);\n        } catch (error) {\n            console.error('Failed to get fragments:', error);\n        }\n    } else loginBtn.addEventListener('click', (0, $7bc1e5a75795e44f$export$9670d83f11d4b64a));\n}\naddEventListener('DOMContentLoaded', $e73bf42412feb220$var$init);\n\n\n//# sourceMappingURL=fragments-ui.e5b7f26e.js.map\n",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory();\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\troot.CryptoJS = factory();\n\t}\n}(this, function () {\n\n\t/*globals window, global, require*/\n\n\t/**\n\t * CryptoJS core components.\n\t */\n\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\n\n\t    var crypto;\n\n\t    // Native crypto from window (Browser)\n\t    if (typeof window !== 'undefined' && window.crypto) {\n\t        crypto = window.crypto;\n\t    }\n\n\t    // Native crypto in web worker (Browser)\n\t    if (typeof self !== 'undefined' && self.crypto) {\n\t        crypto = self.crypto;\n\t    }\n\n\t    // Native crypto from worker\n\t    if (typeof globalThis !== 'undefined' && globalThis.crypto) {\n\t        crypto = globalThis.crypto;\n\t    }\n\n\t    // Native (experimental IE 11) crypto from window (Browser)\n\t    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {\n\t        crypto = window.msCrypto;\n\t    }\n\n\t    // Native crypto from global (NodeJS)\n\t    if (!crypto && typeof global !== 'undefined' && global.crypto) {\n\t        crypto = global.crypto;\n\t    }\n\n\t    // Native crypto import via require (NodeJS)\n\t    if (!crypto && typeof require === 'function') {\n\t        try {\n\t            crypto = require('crypto');\n\t        } catch (err) {}\n\t    }\n\n\t    /*\n\t     * Cryptographically secure pseudorandom number generator\n\t     *\n\t     * As Math.random() is cryptographically not safe to use\n\t     */\n\t    var cryptoSecureRandomInt = function () {\n\t        if (crypto) {\n\t            // Use getRandomValues method (Browser)\n\t            if (typeof crypto.getRandomValues === 'function') {\n\t                try {\n\t                    return crypto.getRandomValues(new Uint32Array(1))[0];\n\t                } catch (err) {}\n\t            }\n\n\t            // Use randomBytes method (NodeJS)\n\t            if (typeof crypto.randomBytes === 'function') {\n\t                try {\n\t                    return crypto.randomBytes(4).readInt32LE();\n\t                } catch (err) {}\n\t            }\n\t        }\n\n\t        throw new Error('Native crypto module could not be used to get secure random number.');\n\t    };\n\n\t    /*\n\t     * Local polyfill of Object.create\n\n\t     */\n\t    var create = Object.create || (function () {\n\t        function F() {}\n\n\t        return function (obj) {\n\t            var subtype;\n\n\t            F.prototype = obj;\n\n\t            subtype = new F();\n\n\t            F.prototype = null;\n\n\t            return subtype;\n\t        };\n\t    }());\n\n\t    /**\n\t     * CryptoJS namespace.\n\t     */\n\t    var C = {};\n\n\t    /**\n\t     * Library namespace.\n\t     */\n\t    var C_lib = C.lib = {};\n\n\t    /**\n\t     * Base object for prototypal inheritance.\n\t     */\n\t    var Base = C_lib.Base = (function () {\n\n\n\t        return {\n\t            /**\n\t             * Creates a new object that inherits from this object.\n\t             *\n\t             * @param {Object} overrides Properties to copy into the new object.\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         field: 'value',\n\t             *\n\t             *         method: function () {\n\t             *         }\n\t             *     });\n\t             */\n\t            extend: function (overrides) {\n\t                // Spawn\n\t                var subtype = create(this);\n\n\t                // Augment\n\t                if (overrides) {\n\t                    subtype.mixIn(overrides);\n\t                }\n\n\t                // Create default initializer\n\t                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {\n\t                    subtype.init = function () {\n\t                        subtype.$super.init.apply(this, arguments);\n\t                    };\n\t                }\n\n\t                // Initializer's prototype is the subtype object\n\t                subtype.init.prototype = subtype;\n\n\t                // Reference supertype\n\t                subtype.$super = this;\n\n\t                return subtype;\n\t            },\n\n\t            /**\n\t             * Extends this object and runs the init method.\n\t             * Arguments to create() will be passed to init().\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var instance = MyType.create();\n\t             */\n\t            create: function () {\n\t                var instance = this.extend();\n\t                instance.init.apply(instance, arguments);\n\n\t                return instance;\n\t            },\n\n\t            /**\n\t             * Initializes a newly created object.\n\t             * Override this method to add some logic when your objects are created.\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         init: function () {\n\t             *             // ...\n\t             *         }\n\t             *     });\n\t             */\n\t            init: function () {\n\t            },\n\n\t            /**\n\t             * Copies properties into this object.\n\t             *\n\t             * @param {Object} properties The properties to mix in.\n\t             *\n\t             * @example\n\t             *\n\t             *     MyType.mixIn({\n\t             *         field: 'value'\n\t             *     });\n\t             */\n\t            mixIn: function (properties) {\n\t                for (var propertyName in properties) {\n\t                    if (properties.hasOwnProperty(propertyName)) {\n\t                        this[propertyName] = properties[propertyName];\n\t                    }\n\t                }\n\n\t                // IE won't copy toString using the loop above\n\t                if (properties.hasOwnProperty('toString')) {\n\t                    this.toString = properties.toString;\n\t                }\n\t            },\n\n\t            /**\n\t             * Creates a copy of this object.\n\t             *\n\t             * @return {Object} The clone.\n\t             *\n\t             * @example\n\t             *\n\t             *     var clone = instance.clone();\n\t             */\n\t            clone: function () {\n\t                return this.init.prototype.extend(this);\n\t            }\n\t        };\n\t    }());\n\n\t    /**\n\t     * An array of 32-bit words.\n\t     *\n\t     * @property {Array} words The array of 32-bit words.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var WordArray = C_lib.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 4;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this word array to a string.\n\t         *\n\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t         *\n\t         * @return {string} The stringified word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = wordArray + '';\n\t         *     var string = wordArray.toString();\n\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t         */\n\t        toString: function (encoder) {\n\t            return (encoder || Hex).stringify(this);\n\t        },\n\n\t        /**\n\t         * Concatenates a word array to this word array.\n\t         *\n\t         * @param {WordArray} wordArray The word array to append.\n\t         *\n\t         * @return {WordArray} This word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray1.concat(wordArray2);\n\t         */\n\t        concat: function (wordArray) {\n\t            // Shortcuts\n\t            var thisWords = this.words;\n\t            var thatWords = wordArray.words;\n\t            var thisSigBytes = this.sigBytes;\n\t            var thatSigBytes = wordArray.sigBytes;\n\n\t            // Clamp excess bits\n\t            this.clamp();\n\n\t            // Concat\n\t            if (thisSigBytes % 4) {\n\t                // Copy one byte at a time\n\t                for (var i = 0; i < thatSigBytes; i++) {\n\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n\t                }\n\t            } else {\n\t                // Copy one word at a time\n\t                for (var j = 0; j < thatSigBytes; j += 4) {\n\t                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];\n\t                }\n\t            }\n\t            this.sigBytes += thatSigBytes;\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Removes insignificant bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray.clamp();\n\t         */\n\t        clamp: function () {\n\t            // Shortcuts\n\t            var words = this.words;\n\t            var sigBytes = this.sigBytes;\n\n\t            // Clamp\n\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n\t            words.length = Math.ceil(sigBytes / 4);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = wordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone.words = this.words.slice(0);\n\n\t            return clone;\n\t        },\n\n\t        /**\n\t         * Creates a word array filled with random bytes.\n\t         *\n\t         * @param {number} nBytes The number of random bytes to generate.\n\t         *\n\t         * @return {WordArray} The random word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t         */\n\t        random: function (nBytes) {\n\t            var words = [];\n\n\t            for (var i = 0; i < nBytes; i += 4) {\n\t                words.push(cryptoSecureRandomInt());\n\t            }\n\n\t            return new WordArray.init(words, nBytes);\n\t        }\n\t    });\n\n\t    /**\n\t     * Encoder namespace.\n\t     */\n\t    var C_enc = C.enc = {};\n\n\t    /**\n\t     * Hex encoding strategy.\n\t     */\n\t    var Hex = C_enc.Hex = {\n\t        /**\n\t         * Converts a word array to a hex string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The hex string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var hexChars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                hexChars.push((bite >>> 4).toString(16));\n\t                hexChars.push((bite & 0x0f).toString(16));\n\t            }\n\n\t            return hexChars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a hex string to a word array.\n\t         *\n\t         * @param {string} hexStr The hex string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t         */\n\t        parse: function (hexStr) {\n\t            // Shortcut\n\t            var hexStrLength = hexStr.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < hexStrLength; i += 2) {\n\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n\t            }\n\n\t            return new WordArray.init(words, hexStrLength / 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * Latin1 encoding strategy.\n\t     */\n\t    var Latin1 = C_enc.Latin1 = {\n\t        /**\n\t         * Converts a word array to a Latin1 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Latin1 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var latin1Chars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                latin1Chars.push(String.fromCharCode(bite));\n\t            }\n\n\t            return latin1Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Latin1 string to a word array.\n\t         *\n\t         * @param {string} latin1Str The Latin1 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t         */\n\t        parse: function (latin1Str) {\n\t            // Shortcut\n\t            var latin1StrLength = latin1Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < latin1StrLength; i++) {\n\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n\t            }\n\n\t            return new WordArray.init(words, latin1StrLength);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-8 encoding strategy.\n\t     */\n\t    var Utf8 = C_enc.Utf8 = {\n\t        /**\n\t         * Converts a word array to a UTF-8 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-8 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            try {\n\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t            } catch (e) {\n\t                throw new Error('Malformed UTF-8 data');\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts a UTF-8 string to a word array.\n\t         *\n\t         * @param {string} utf8Str The UTF-8 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t         */\n\t        parse: function (utf8Str) {\n\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract buffered block algorithm template.\n\t     *\n\t     * The property blockSize must be implemented in a concrete subtype.\n\t     *\n\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t     */\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t        /**\n\t         * Resets this block algorithm's data buffer to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm.reset();\n\t         */\n\t        reset: function () {\n\t            // Initial values\n\t            this._data = new WordArray.init();\n\t            this._nDataBytes = 0;\n\t        },\n\n\t        /**\n\t         * Adds new data to this block algorithm's buffer.\n\t         *\n\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm._append('data');\n\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t         */\n\t        _append: function (data) {\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof data == 'string') {\n\t                data = Utf8.parse(data);\n\t            }\n\n\t            // Append\n\t            this._data.concat(data);\n\t            this._nDataBytes += data.sigBytes;\n\t        },\n\n\t        /**\n\t         * Processes available data blocks.\n\t         *\n\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t         *\n\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t         *\n\t         * @return {WordArray} The processed data.\n\t         *\n\t         * @example\n\t         *\n\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t         */\n\t        _process: function (doFlush) {\n\t            var processedWords;\n\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var dataSigBytes = data.sigBytes;\n\t            var blockSize = this.blockSize;\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count blocks ready\n\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t            if (doFlush) {\n\t                // Round up to include partial blocks\n\t                nBlocksReady = Math.ceil(nBlocksReady);\n\t            } else {\n\t                // Round down to include only full blocks,\n\t                // less the number of blocks that must remain in the buffer\n\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t            }\n\n\t            // Count words ready\n\t            var nWordsReady = nBlocksReady * blockSize;\n\n\t            // Count bytes ready\n\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n\t            // Process blocks\n\t            if (nWordsReady) {\n\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t                    // Perform concrete-algorithm logic\n\t                    this._doProcessBlock(dataWords, offset);\n\t                }\n\n\t                // Remove processed words\n\t                processedWords = dataWords.splice(0, nWordsReady);\n\t                data.sigBytes -= nBytesReady;\n\t            }\n\n\t            // Return processed words\n\t            return new WordArray.init(processedWords, nBytesReady);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this object.\n\t         *\n\t         * @return {Object} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone._data = this._data.clone();\n\n\t            return clone;\n\t        },\n\n\t        _minBufferSize: 0\n\t    });\n\n\t    /**\n\t     * Abstract hasher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t     */\n\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Initializes a newly created hasher.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t         */\n\t        init: function (cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this hasher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-hasher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Updates this hasher with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {Hasher} This hasher.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.update('message');\n\t         *     hasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            // Append\n\t            this._append(messageUpdate);\n\n\t            // Update the hash\n\t            this._process();\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the hash computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The hash.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hash = hasher.finalize();\n\t         *     var hash = hasher.finalize('message');\n\t         *     var hash = hasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Final message update\n\t            if (messageUpdate) {\n\t                this._append(messageUpdate);\n\t            }\n\n\t            // Perform concrete-hasher logic\n\t            var hash = this._doFinalize();\n\n\t            return hash;\n\t        },\n\n\t        blockSize: 512/32,\n\n\t        /**\n\t         * Creates a shortcut function to a hasher's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHelper: function (hasher) {\n\t            return function (message, cfg) {\n\t                return new hasher.init(cfg).finalize(message);\n\t            };\n\t        },\n\n\t        /**\n\t         * Creates a shortcut function to the HMAC's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHmacHelper: function (hasher) {\n\t            return function (message, key) {\n\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t            };\n\t        }\n\t    });\n\n\t    /**\n\t     * Algorithm namespace.\n\t     */\n\t    var C_algo = C.algo = {};\n\n\t    return C;\n\t}(Math));\n\n\n\treturn CryptoJS;\n\n}));","\"use strict\";",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Initialization and round constants tables\n\t    var H = [];\n\t    var K = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        function isPrime(n) {\n\t            var sqrtN = Math.sqrt(n);\n\t            for (var factor = 2; factor <= sqrtN; factor++) {\n\t                if (!(n % factor)) {\n\t                    return false;\n\t                }\n\t            }\n\n\t            return true;\n\t        }\n\n\t        function getFractionalBits(n) {\n\t            return ((n - (n | 0)) * 0x100000000) | 0;\n\t        }\n\n\t        var n = 2;\n\t        var nPrime = 0;\n\t        while (nPrime < 64) {\n\t            if (isPrime(n)) {\n\t                if (nPrime < 8) {\n\t                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t                }\n\t                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n\t                nPrime++;\n\t            }\n\n\t            n++;\n\t        }\n\t    }());\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-256 hash algorithm.\n\t     */\n\t    var SHA256 = C_algo.SHA256 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init(H.slice(0));\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\t            var f = H[5];\n\t            var g = H[6];\n\t            var h = H[7];\n\n\t            // Computation\n\t            for (var i = 0; i < 64; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var gamma0x = W[i - 15];\n\t                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n\t                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n\t                                   (gamma0x >>> 3);\n\n\t                    var gamma1x = W[i - 2];\n\t                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n\t                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n\t                                   (gamma1x >>> 10);\n\n\t                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t                }\n\n\t                var ch  = (e & f) ^ (~e & g);\n\t                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n\t                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n\t                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n\t                var t1 = h + sigma1 + ch + K[i] + W[i];\n\t                var t2 = sigma0 + maj;\n\n\t                h = g;\n\t                g = f;\n\t                f = e;\n\t                e = (d + t1) | 0;\n\t                d = c;\n\t                c = b;\n\t                b = a;\n\t                a = (t1 + t2) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t            H[5] = (H[5] + f) | 0;\n\t            H[6] = (H[6] + g) | 0;\n\t            H[7] = (H[7] + h) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA256('message');\n\t     *     var hash = CryptoJS.SHA256(wordArray);\n\t     */\n\t    C.SHA256 = Hasher._createHelper(SHA256);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\n\t     */\n\t    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA256;\n\n}));",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_enc = C.enc;\n\n\t    /**\n\t     * Base64 encoding strategy.\n\t     */\n\t    var Base64 = C_enc.Base64 = {\n\t        /**\n\t         * Converts a word array to a Base64 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Base64 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\t            var map = this._map;\n\n\t            // Clamp excess bits\n\t            wordArray.clamp();\n\n\t            // Convert\n\t            var base64Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 3) {\n\t                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;\n\t                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n\t                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n\t                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n\t                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {\n\t                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n\t                }\n\t            }\n\n\t            // Add padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                while (base64Chars.length % 4) {\n\t                    base64Chars.push(paddingChar);\n\t                }\n\t            }\n\n\t            return base64Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Base64 string to a word array.\n\t         *\n\t         * @param {string} base64Str The Base64 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);\n\t         */\n\t        parse: function (base64Str) {\n\t            // Shortcuts\n\t            var base64StrLength = base64Str.length;\n\t            var map = this._map;\n\t            var reverseMap = this._reverseMap;\n\n\t            if (!reverseMap) {\n\t                    reverseMap = this._reverseMap = [];\n\t                    for (var j = 0; j < map.length; j++) {\n\t                        reverseMap[map.charCodeAt(j)] = j;\n\t                    }\n\t            }\n\n\t            // Ignore padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                var paddingIndex = base64Str.indexOf(paddingChar);\n\t                if (paddingIndex !== -1) {\n\t                    base64StrLength = paddingIndex;\n\t                }\n\t            }\n\n\t            // Convert\n\t            return parseLoop(base64Str, base64StrLength, reverseMap);\n\n\t        },\n\n\t        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='\n\t    };\n\n\t    function parseLoop(base64Str, base64StrLength, reverseMap) {\n\t      var words = [];\n\t      var nBytes = 0;\n\t      for (var i = 0; i < base64StrLength; i++) {\n\t          if (i % 4) {\n\t              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n\t              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n\t              var bitsCombined = bits1 | bits2;\n\t              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\n\t              nBytes++;\n\t          }\n\t      }\n\t      return WordArray.create(words, nBytes);\n\t    }\n\t}());\n\n\n\treturn CryptoJS.enc.Base64;\n\n}));",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\treturn CryptoJS.enc.Utf8;\n\n}));","function e(e){this.message=e}e.prototype=new Error,e.prototype.name=\"InvalidCharacterError\";var r=\"undefined\"!=typeof window&&window.atob&&window.atob.bind(window)||function(r){var t=String(r).replace(/=+$/,\"\");if(t.length%4==1)throw new e(\"'atob' failed: The string to be decoded is not correctly encoded.\");for(var n,o,a=0,i=0,c=\"\";o=t.charAt(i++);~o&&(n=a%4?64*n+o:o,a++%4)?c+=String.fromCharCode(255&n>>(-2*a&6)):0)o=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(o);return c};function t(e){var t=e.replace(/-/g,\"+\").replace(/_/g,\"/\");switch(t.length%4){case 0:break;case 2:t+=\"==\";break;case 3:t+=\"=\";break;default:throw\"Illegal base64url string!\"}try{return function(e){return decodeURIComponent(r(e).replace(/(.)/g,(function(e,r){var t=r.charCodeAt(0).toString(16).toUpperCase();return t.length<2&&(t=\"0\"+t),\"%\"+t})))}(t)}catch(e){return r(t)}}function n(e){this.message=e}function o(e,r){if(\"string\"!=typeof e)throw new n(\"Invalid token specified\");var o=!0===(r=r||{}).header?0:1;try{return JSON.parse(t(e.split(\".\")[o]))}catch(e){throw new n(\"Invalid token specified: \"+e.message)}}n.prototype=new Error,n.prototype.name=\"InvalidTokenError\";export default o;export{n as InvalidTokenError};\n//# sourceMappingURL=jwt-decode.esm.js.map\n","/**\n * The code was extracted from:\n * https://github.com/davidchambers/Base64.js\n */\n\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\nfunction InvalidCharacterError(message) {\n    this.message = message;\n}\n\nInvalidCharacterError.prototype = new Error();\nInvalidCharacterError.prototype.name = \"InvalidCharacterError\";\n\nfunction polyfill(input) {\n    var str = String(input).replace(/=+$/, \"\");\n    if (str.length % 4 == 1) {\n        throw new InvalidCharacterError(\n            \"'atob' failed: The string to be decoded is not correctly encoded.\"\n        );\n    }\n    for (\n        // initialize result and counters\n        var bc = 0, bs, buffer, idx = 0, output = \"\";\n        // get next character\n        (buffer = str.charAt(idx++));\n        // character found in table? initialize bit storage and add its ascii value;\n        ~buffer &&\n        ((bs = bc % 4 ? bs * 64 + buffer : buffer),\n            // and if not first of each 4 characters,\n            // convert the first 8 bits to one ascii character\n            bc++ % 4) ?\n        (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6)))) :\n        0\n    ) {\n        // try to find character in table (0-63, not found => -1)\n        buffer = chars.indexOf(buffer);\n    }\n    return output;\n}\n\nexport default (typeof window !== \"undefined\" &&\n    window.atob &&\n    window.atob.bind(window)) ||\npolyfill;","import atob from \"./atob\";\n\nfunction b64DecodeUnicode(str) {\n    return decodeURIComponent(\n        atob(str).replace(/(.)/g, function(m, p) {\n            var code = p.charCodeAt(0).toString(16).toUpperCase();\n            if (code.length < 2) {\n                code = \"0\" + code;\n            }\n            return \"%\" + code;\n        })\n    );\n}\n\nexport default function(str) {\n    var output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch (output.length % 4) {\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw \"Illegal base64url string!\";\n    }\n\n    try {\n        return b64DecodeUnicode(output);\n    } catch (err) {\n        return atob(output);\n    }\n}","\"use strict\";\n\nimport base64_url_decode from \"./base64_url_decode\";\n\nexport function InvalidTokenError(message) {\n    this.message = message;\n}\n\nInvalidTokenError.prototype = new Error();\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\n\nexport default function(token, options) {\n    if (typeof token !== \"string\") {\n        throw new InvalidTokenError(\"Invalid token specified\");\n    }\n\n    options = options || {};\n    var pos = options.header === true ? 0 : 1;\n    try {\n        return JSON.parse(base64_url_decode(token.split(\".\")[pos]));\n    } catch (e) {\n        throw new InvalidTokenError(\"Invalid token specified: \" + e.message);\n    }\n}","import { signIn, getUser, signOut } from './auth.js';\nimport { getUserFragments } from './api.js';\n\nasync function init() {\n  const userSection = document.querySelector('#user');\n  const loginBtn = document.querySelector('#login');\n  const user = await getUser();\n  if (user) {\n    userSection.innerHTML = `\n      <p>Welcome, ${user.username}!</p>\n      <button id=\"logout\">Logout</button>\n    `;\n    const logoutBtn = document.querySelector('#logout');\n    logoutBtn.addEventListener('click', async () => {\n      await signOut();\n    });\n    try {\n      const fragments = await getUserFragments(user);\n      console.log('User fragments:', fragments);\n    } catch (error) {\n      console.error('Failed to get fragments:', error);\n    }\n  } else {\n    loginBtn.addEventListener('click', signIn);\n  }\n}\n\naddEventListener('DOMContentLoaded', init);","import { UserManager } from 'oidc-client-ts';\n\nconst cognitoAuthConfig = {\n  authority: `https://cognito-idp.us-east-1.amazonaws.com/${process.env.AWS_COGNITO_POOL_ID}`,\n  client_id: process.env.AWS_COGNITO_CLIENT_ID,\n  redirect_uri: process.env.OAUTH_SIGN_IN_REDIRECT_URL,\n  response_type: 'code',\n  scope: 'phone openid email',\n  revokeTokenTypes: ['refresh_token'],\n  automaticSilentRenew: false,\n};\n\nconst userManager = new UserManager({\n  ...cognitoAuthConfig,\n});\n\nexport { userManager };\n\nexport async function signIn() {\n  await userManager.signinRedirect();\n}\n\nexport async function signOut() {\n  try {\n    // Clear the user from the UserManager first\n    await userManager.removeUser();\n  } catch (error) {\n    console.error('Error clearing local session:', error);\n  }\n  \n  // For Cognito, we need to manually construct the logout URL with client_id\n  const logoutUrl = `https://fragments-ui-1757690046.auth.us-east-1.amazoncognito.com/logout?client_id=${process.env.AWS_COGNITO_CLIENT_ID}&logout_uri=${encodeURIComponent(process.env.OAUTH_SIGN_IN_REDIRECT_URL)}`;\n  window.location.href = logoutUrl;\n}\n\nfunction formatUser(user) {\n  console.log('User Authenticated', { user });\n  return {\n    username: user.profile.preferred_username || user.profile.email,\n    email: user.profile.email,\n    idToken: user.id_token,\n    accessToken: user.access_token,\n    authorizationHeaders: (type = 'application/json') => ({\n      'Content-Type': type,\n      Authorization: `Bearer ${user.id_token}`,\n    }),\n  };\n}\n\nexport async function getUser() {\n  if (window.location.search.includes('code=')) {\n    const user = await userManager.signinCallback();\n    window.history.replaceState({}, document.title, window.location.pathname);\n    return formatUser(user);\n  }\n  const user = await userManager.getUser();\n  return user ? formatUser(user) : null;\n}","\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  AccessTokenEvents: () => AccessTokenEvents,\n  CheckSessionIFrame: () => CheckSessionIFrame,\n  ErrorResponse: () => ErrorResponse,\n  ErrorTimeout: () => ErrorTimeout,\n  InMemoryWebStorage: () => InMemoryWebStorage,\n  Log: () => Log,\n  Logger: () => Logger,\n  MetadataService: () => MetadataService,\n  OidcClient: () => OidcClient,\n  OidcClientSettingsStore: () => OidcClientSettingsStore,\n  SessionMonitor: () => SessionMonitor,\n  SigninResponse: () => SigninResponse,\n  SigninState: () => SigninState,\n  SignoutResponse: () => SignoutResponse,\n  State: () => State,\n  User: () => User,\n  UserManager: () => UserManager,\n  UserManagerSettingsStore: () => UserManagerSettingsStore,\n  Version: () => Version,\n  WebStorageStateStore: () => WebStorageStateStore\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/utils/CryptoUtils.ts\nvar import_core = __toESM(require(\"crypto-js/core.js\"));\nvar import_sha256 = __toESM(require(\"crypto-js/sha256.js\"));\nvar import_enc_base64 = __toESM(require(\"crypto-js/enc-base64.js\"));\nvar import_enc_utf8 = __toESM(require(\"crypto-js/enc-utf8.js\"));\n\n// src/utils/Logger.ts\nvar nopLogger = {\n  debug: () => void 0,\n  info: () => void 0,\n  warn: () => void 0,\n  error: () => void 0\n};\nvar level;\nvar logger;\nvar Log = /* @__PURE__ */ ((Log2) => {\n  Log2[Log2[\"NONE\"] = 0] = \"NONE\";\n  Log2[Log2[\"ERROR\"] = 1] = \"ERROR\";\n  Log2[Log2[\"WARN\"] = 2] = \"WARN\";\n  Log2[Log2[\"INFO\"] = 3] = \"INFO\";\n  Log2[Log2[\"DEBUG\"] = 4] = \"DEBUG\";\n  return Log2;\n})(Log || {});\n((Log2) => {\n  function reset() {\n    level = 3 /* INFO */;\n    logger = nopLogger;\n  }\n  Log2.reset = reset;\n  function setLevel(value) {\n    if (!(0 /* NONE */ <= value && value <= 4 /* DEBUG */)) {\n      throw new Error(\"Invalid log level\");\n    }\n    level = value;\n  }\n  Log2.setLevel = setLevel;\n  function setLogger(value) {\n    logger = value;\n  }\n  Log2.setLogger = setLogger;\n})(Log || (Log = {}));\nvar Logger = class {\n  constructor(_name) {\n    this._name = _name;\n  }\n  /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n  debug(...args) {\n    if (level >= 4 /* DEBUG */) {\n      logger.debug(Logger._format(this._name, this._method), ...args);\n    }\n  }\n  info(...args) {\n    if (level >= 3 /* INFO */) {\n      logger.info(Logger._format(this._name, this._method), ...args);\n    }\n  }\n  warn(...args) {\n    if (level >= 2 /* WARN */) {\n      logger.warn(Logger._format(this._name, this._method), ...args);\n    }\n  }\n  error(...args) {\n    if (level >= 1 /* ERROR */) {\n      logger.error(Logger._format(this._name, this._method), ...args);\n    }\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n  throw(err) {\n    this.error(err);\n    throw err;\n  }\n  create(method) {\n    const methodLogger = Object.create(this);\n    methodLogger._method = method;\n    methodLogger.debug(\"begin\");\n    return methodLogger;\n  }\n  static createStatic(name, staticMethod) {\n    const staticLogger = new Logger(`${name}.${staticMethod}`);\n    staticLogger.debug(\"begin\");\n    return staticLogger;\n  }\n  static _format(name, method) {\n    const prefix = `[${name}]`;\n    return method ? `${prefix} ${method}:` : prefix;\n  }\n  /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n  // helpers for static class methods\n  static debug(name, ...args) {\n    if (level >= 4 /* DEBUG */) {\n      logger.debug(Logger._format(name), ...args);\n    }\n  }\n  static info(name, ...args) {\n    if (level >= 3 /* INFO */) {\n      logger.info(Logger._format(name), ...args);\n    }\n  }\n  static warn(name, ...args) {\n    if (level >= 2 /* WARN */) {\n      logger.warn(Logger._format(name), ...args);\n    }\n  }\n  static error(name, ...args) {\n    if (level >= 1 /* ERROR */) {\n      logger.error(Logger._format(name), ...args);\n    }\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n};\nLog.reset();\n\n// src/utils/CryptoUtils.ts\nvar UUID_V4_TEMPLATE = \"10000000-1000-4000-8000-100000000000\";\nvar CryptoUtils = class {\n  static _randomWord() {\n    return import_core.default.lib.WordArray.random(1).words[0];\n  }\n  /**\n   * Generates RFC4122 version 4 guid\n   */\n  static generateUUIDv4() {\n    const uuid = UUID_V4_TEMPLATE.replace(\n      /[018]/g,\n      (c) => (+c ^ CryptoUtils._randomWord() & 15 >> +c / 4).toString(16)\n    );\n    return uuid.replace(/-/g, \"\");\n  }\n  /**\n   * PKCE: Generate a code verifier\n   */\n  static generateCodeVerifier() {\n    return CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4();\n  }\n  /**\n   * PKCE: Generate a code challenge\n   */\n  static generateCodeChallenge(code_verifier) {\n    try {\n      const hashed = (0, import_sha256.default)(code_verifier);\n      return import_enc_base64.default.stringify(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n    } catch (err) {\n      Logger.error(\"CryptoUtils.generateCodeChallenge\", err);\n      throw err;\n    }\n  }\n  /**\n   * Generates a base64-encoded string for a basic auth header\n   */\n  static generateBasicAuth(client_id, client_secret) {\n    const basicAuth = import_enc_utf8.default.parse([client_id, client_secret].join(\":\"));\n    return import_enc_base64.default.stringify(basicAuth);\n  }\n};\n\n// src/utils/Event.ts\nvar Event = class {\n  constructor(_name) {\n    this._name = _name;\n    this._logger = new Logger(`Event('${this._name}')`);\n    this._callbacks = [];\n  }\n  addHandler(cb) {\n    this._callbacks.push(cb);\n    return () => this.removeHandler(cb);\n  }\n  removeHandler(cb) {\n    const idx = this._callbacks.lastIndexOf(cb);\n    if (idx >= 0) {\n      this._callbacks.splice(idx, 1);\n    }\n  }\n  raise(...ev) {\n    this._logger.debug(\"raise:\", ...ev);\n    for (const cb of this._callbacks) {\n      void cb(...ev);\n    }\n  }\n};\n\n// src/utils/JwtUtils.ts\nvar import_jwt_decode = __toESM(require(\"jwt-decode\"));\nvar JwtUtils = class {\n  // IMPORTANT: doesn't validate the token\n  static decode(token) {\n    try {\n      return (0, import_jwt_decode.default)(token);\n    } catch (err) {\n      Logger.error(\"JwtUtils.decode\", err);\n      throw err;\n    }\n  }\n};\n\n// src/utils/PopupUtils.ts\nvar PopupUtils = class {\n  /**\n   * Populates a map of window features with a placement centered in front of\n   * the current window. If no explicit width is given, a default value is\n   * binned into [800, 720, 600, 480, 360] based on the current window's width.\n   */\n  static center({ ...features }) {\n    var _a, _b, _c;\n    if (features.width == null)\n      features.width = (_a = [800, 720, 600, 480].find((width) => width <= window.outerWidth / 1.618)) != null ? _a : 360;\n    (_b = features.left) != null ? _b : features.left = Math.max(0, Math.round(window.screenX + (window.outerWidth - features.width) / 2));\n    if (features.height != null)\n      (_c = features.top) != null ? _c : features.top = Math.max(0, Math.round(window.screenY + (window.outerHeight - features.height) / 2));\n    return features;\n  }\n  static serialize(features) {\n    return Object.entries(features).filter(([, value]) => value != null).map(([key, value]) => `${key}=${typeof value !== \"boolean\" ? value : value ? \"yes\" : \"no\"}`).join(\",\");\n  }\n};\n\n// src/utils/Timer.ts\nvar Timer = class extends Event {\n  constructor() {\n    super(...arguments);\n    this._logger = new Logger(`Timer('${this._name}')`);\n    this._timerHandle = null;\n    this._expiration = 0;\n    this._callback = () => {\n      const diff = this._expiration - Timer.getEpochTime();\n      this._logger.debug(\"timer completes in\", diff);\n      if (this._expiration <= Timer.getEpochTime()) {\n        this.cancel();\n        super.raise();\n      }\n    };\n  }\n  // get the time\n  static getEpochTime() {\n    return Math.floor(Date.now() / 1e3);\n  }\n  init(durationInSeconds) {\n    const logger2 = this._logger.create(\"init\");\n    durationInSeconds = Math.max(Math.floor(durationInSeconds), 1);\n    const expiration = Timer.getEpochTime() + durationInSeconds;\n    if (this.expiration === expiration && this._timerHandle) {\n      logger2.debug(\"skipping since already initialized for expiration at\", this.expiration);\n      return;\n    }\n    this.cancel();\n    logger2.debug(\"using duration\", durationInSeconds);\n    this._expiration = expiration;\n    const timerDurationInSeconds = Math.min(durationInSeconds, 5);\n    this._timerHandle = setInterval(this._callback, timerDurationInSeconds * 1e3);\n  }\n  get expiration() {\n    return this._expiration;\n  }\n  cancel() {\n    this._logger.create(\"cancel\");\n    if (this._timerHandle) {\n      clearInterval(this._timerHandle);\n      this._timerHandle = null;\n    }\n  }\n};\n\n// src/utils/UrlUtils.ts\nvar UrlUtils = class {\n  static readParams(url, responseMode = \"query\") {\n    if (!url)\n      throw new TypeError(\"Invalid URL\");\n    const parsedUrl = new URL(url, \"http://127.0.0.1\");\n    const params = parsedUrl[responseMode === \"fragment\" ? \"hash\" : \"search\"];\n    return new URLSearchParams(params.slice(1));\n  }\n};\nvar URL_STATE_DELIMITER = \";\";\n\n// src/errors/ErrorResponse.ts\nvar ErrorResponse = class extends Error {\n  constructor(args, form) {\n    var _a, _b, _c;\n    super(args.error_description || args.error || \"\");\n    this.form = form;\n    /** Marker to detect class: \"ErrorResponse\" */\n    this.name = \"ErrorResponse\";\n    if (!args.error) {\n      Logger.error(\"ErrorResponse\", \"No error passed\");\n      throw new Error(\"No error passed\");\n    }\n    this.error = args.error;\n    this.error_description = (_a = args.error_description) != null ? _a : null;\n    this.error_uri = (_b = args.error_uri) != null ? _b : null;\n    this.state = args.userState;\n    this.session_state = (_c = args.session_state) != null ? _c : null;\n    this.url_state = args.url_state;\n  }\n};\n\n// src/errors/ErrorTimeout.ts\nvar ErrorTimeout = class extends Error {\n  constructor(message) {\n    super(message);\n    /** Marker to detect class: \"ErrorTimeout\" */\n    this.name = \"ErrorTimeout\";\n  }\n};\n\n// src/AccessTokenEvents.ts\nvar AccessTokenEvents = class {\n  constructor(args) {\n    this._logger = new Logger(\"AccessTokenEvents\");\n    this._expiringTimer = new Timer(\"Access token expiring\");\n    this._expiredTimer = new Timer(\"Access token expired\");\n    this._expiringNotificationTimeInSeconds = args.expiringNotificationTimeInSeconds;\n  }\n  load(container) {\n    const logger2 = this._logger.create(\"load\");\n    if (container.access_token && container.expires_in !== void 0) {\n      const duration = container.expires_in;\n      logger2.debug(\"access token present, remaining duration:\", duration);\n      if (duration > 0) {\n        let expiring = duration - this._expiringNotificationTimeInSeconds;\n        if (expiring <= 0) {\n          expiring = 1;\n        }\n        logger2.debug(\"registering expiring timer, raising in\", expiring, \"seconds\");\n        this._expiringTimer.init(expiring);\n      } else {\n        logger2.debug(\"canceling existing expiring timer because we're past expiration.\");\n        this._expiringTimer.cancel();\n      }\n      const expired = duration + 1;\n      logger2.debug(\"registering expired timer, raising in\", expired, \"seconds\");\n      this._expiredTimer.init(expired);\n    } else {\n      this._expiringTimer.cancel();\n      this._expiredTimer.cancel();\n    }\n  }\n  unload() {\n    this._logger.debug(\"unload: canceling existing access token timers\");\n    this._expiringTimer.cancel();\n    this._expiredTimer.cancel();\n  }\n  /**\n   * Add callback: Raised prior to the access token expiring.\n   */\n  addAccessTokenExpiring(cb) {\n    return this._expiringTimer.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised prior to the access token expiring.\n   */\n  removeAccessTokenExpiring(cb) {\n    this._expiringTimer.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised after the access token has expired.\n   */\n  addAccessTokenExpired(cb) {\n    return this._expiredTimer.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised after the access token has expired.\n   */\n  removeAccessTokenExpired(cb) {\n    this._expiredTimer.removeHandler(cb);\n  }\n};\n\n// src/CheckSessionIFrame.ts\nvar CheckSessionIFrame = class {\n  constructor(_callback, _client_id, url, _intervalInSeconds, _stopOnError) {\n    this._callback = _callback;\n    this._client_id = _client_id;\n    this._intervalInSeconds = _intervalInSeconds;\n    this._stopOnError = _stopOnError;\n    this._logger = new Logger(\"CheckSessionIFrame\");\n    this._timer = null;\n    this._session_state = null;\n    this._message = (e) => {\n      if (e.origin === this._frame_origin && e.source === this._frame.contentWindow) {\n        if (e.data === \"error\") {\n          this._logger.error(\"error message from check session op iframe\");\n          if (this._stopOnError) {\n            this.stop();\n          }\n        } else if (e.data === \"changed\") {\n          this._logger.debug(\"changed message from check session op iframe\");\n          this.stop();\n          void this._callback();\n        } else {\n          this._logger.debug(e.data + \" message from check session op iframe\");\n        }\n      }\n    };\n    const parsedUrl = new URL(url);\n    this._frame_origin = parsedUrl.origin;\n    this._frame = window.document.createElement(\"iframe\");\n    this._frame.style.visibility = \"hidden\";\n    this._frame.style.position = \"fixed\";\n    this._frame.style.left = \"-1000px\";\n    this._frame.style.top = \"0\";\n    this._frame.width = \"0\";\n    this._frame.height = \"0\";\n    this._frame.src = parsedUrl.href;\n  }\n  load() {\n    return new Promise((resolve) => {\n      this._frame.onload = () => {\n        resolve();\n      };\n      window.document.body.appendChild(this._frame);\n      window.addEventListener(\"message\", this._message, false);\n    });\n  }\n  start(session_state) {\n    if (this._session_state === session_state) {\n      return;\n    }\n    this._logger.create(\"start\");\n    this.stop();\n    this._session_state = session_state;\n    const send = () => {\n      if (!this._frame.contentWindow || !this._session_state) {\n        return;\n      }\n      this._frame.contentWindow.postMessage(this._client_id + \" \" + this._session_state, this._frame_origin);\n    };\n    send();\n    this._timer = setInterval(send, this._intervalInSeconds * 1e3);\n  }\n  stop() {\n    this._logger.create(\"stop\");\n    this._session_state = null;\n    if (this._timer) {\n      clearInterval(this._timer);\n      this._timer = null;\n    }\n  }\n};\n\n// src/InMemoryWebStorage.ts\nvar InMemoryWebStorage = class {\n  constructor() {\n    this._logger = new Logger(\"InMemoryWebStorage\");\n    this._data = {};\n  }\n  clear() {\n    this._logger.create(\"clear\");\n    this._data = {};\n  }\n  getItem(key) {\n    this._logger.create(`getItem('${key}')`);\n    return this._data[key];\n  }\n  setItem(key, value) {\n    this._logger.create(`setItem('${key}')`);\n    this._data[key] = value;\n  }\n  removeItem(key) {\n    this._logger.create(`removeItem('${key}')`);\n    delete this._data[key];\n  }\n  get length() {\n    return Object.getOwnPropertyNames(this._data).length;\n  }\n  key(index) {\n    return Object.getOwnPropertyNames(this._data)[index];\n  }\n};\n\n// src/JsonService.ts\nvar JsonService = class {\n  constructor(additionalContentTypes = [], _jwtHandler = null, _extraHeaders = {}) {\n    this._jwtHandler = _jwtHandler;\n    this._extraHeaders = _extraHeaders;\n    this._logger = new Logger(\"JsonService\");\n    this._contentTypes = [];\n    this._contentTypes.push(...additionalContentTypes, \"application/json\");\n    if (_jwtHandler) {\n      this._contentTypes.push(\"application/jwt\");\n    }\n  }\n  async fetchWithTimeout(input, init = {}) {\n    const { timeoutInSeconds, ...initFetch } = init;\n    if (!timeoutInSeconds) {\n      return await fetch(input, initFetch);\n    }\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeoutInSeconds * 1e3);\n    try {\n      const response = await fetch(input, {\n        ...init,\n        signal: controller.signal\n      });\n      return response;\n    } catch (err) {\n      if (err instanceof DOMException && err.name === \"AbortError\") {\n        throw new ErrorTimeout(\"Network timed out\");\n      }\n      throw err;\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n  async getJson(url, {\n    token,\n    credentials\n  } = {}) {\n    const logger2 = this._logger.create(\"getJson\");\n    const headers = {\n      \"Accept\": this._contentTypes.join(\", \")\n    };\n    if (token) {\n      logger2.debug(\"token passed, setting Authorization header\");\n      headers[\"Authorization\"] = \"Bearer \" + token;\n    }\n    this.appendExtraHeaders(headers);\n    let response;\n    try {\n      logger2.debug(\"url:\", url);\n      response = await this.fetchWithTimeout(url, { method: \"GET\", headers, credentials });\n    } catch (err) {\n      logger2.error(\"Network Error\");\n      throw err;\n    }\n    logger2.debug(\"HTTP response received, status\", response.status);\n    const contentType = response.headers.get(\"Content-Type\");\n    if (contentType && !this._contentTypes.find((item) => contentType.startsWith(item))) {\n      logger2.throw(new Error(`Invalid response Content-Type: ${contentType != null ? contentType : \"undefined\"}, from URL: ${url}`));\n    }\n    if (response.ok && this._jwtHandler && (contentType == null ? void 0 : contentType.startsWith(\"application/jwt\"))) {\n      return await this._jwtHandler(await response.text());\n    }\n    let json;\n    try {\n      json = await response.json();\n    } catch (err) {\n      logger2.error(\"Error parsing JSON response\", err);\n      if (response.ok)\n        throw err;\n      throw new Error(`${response.statusText} (${response.status})`);\n    }\n    if (!response.ok) {\n      logger2.error(\"Error from server:\", json);\n      if (json.error) {\n        throw new ErrorResponse(json);\n      }\n      throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n    }\n    return json;\n  }\n  async postForm(url, {\n    body,\n    basicAuth,\n    timeoutInSeconds,\n    initCredentials\n  }) {\n    const logger2 = this._logger.create(\"postForm\");\n    const headers = {\n      \"Accept\": this._contentTypes.join(\", \"),\n      \"Content-Type\": \"application/x-www-form-urlencoded\"\n    };\n    if (basicAuth !== void 0) {\n      headers[\"Authorization\"] = \"Basic \" + basicAuth;\n    }\n    this.appendExtraHeaders(headers);\n    let response;\n    try {\n      logger2.debug(\"url:\", url);\n      response = await this.fetchWithTimeout(url, { method: \"POST\", headers, body, timeoutInSeconds, credentials: initCredentials });\n    } catch (err) {\n      logger2.error(\"Network error\");\n      throw err;\n    }\n    logger2.debug(\"HTTP response received, status\", response.status);\n    const contentType = response.headers.get(\"Content-Type\");\n    if (contentType && !this._contentTypes.find((item) => contentType.startsWith(item))) {\n      throw new Error(`Invalid response Content-Type: ${contentType != null ? contentType : \"undefined\"}, from URL: ${url}`);\n    }\n    const responseText = await response.text();\n    let json = {};\n    if (responseText) {\n      try {\n        json = JSON.parse(responseText);\n      } catch (err) {\n        logger2.error(\"Error parsing JSON response\", err);\n        if (response.ok)\n          throw err;\n        throw new Error(`${response.statusText} (${response.status})`);\n      }\n    }\n    if (!response.ok) {\n      logger2.error(\"Error from server:\", json);\n      if (json.error) {\n        throw new ErrorResponse(json, body);\n      }\n      throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n    }\n    return json;\n  }\n  appendExtraHeaders(headers) {\n    const logger2 = this._logger.create(\"appendExtraHeaders\");\n    const customKeys = Object.keys(this._extraHeaders);\n    const protectedHeaders = [\n      \"authorization\",\n      \"accept\",\n      \"content-type\"\n    ];\n    if (customKeys.length === 0) {\n      return;\n    }\n    customKeys.forEach((headerName) => {\n      if (protectedHeaders.includes(headerName.toLocaleLowerCase())) {\n        logger2.warn(\"Protected header could not be overridden\", headerName, protectedHeaders);\n        return;\n      }\n      const content = typeof this._extraHeaders[headerName] === \"function\" ? this._extraHeaders[headerName]() : this._extraHeaders[headerName];\n      if (content && content !== \"\") {\n        headers[headerName] = content;\n      }\n    });\n  }\n};\n\n// src/MetadataService.ts\nvar MetadataService = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"MetadataService\");\n    this._signingKeys = null;\n    this._metadata = null;\n    this._metadataUrl = this._settings.metadataUrl;\n    this._jsonService = new JsonService(\n      [\"application/jwk-set+json\"],\n      null,\n      this._settings.extraHeaders\n    );\n    if (this._settings.signingKeys) {\n      this._logger.debug(\"using signingKeys from settings\");\n      this._signingKeys = this._settings.signingKeys;\n    }\n    if (this._settings.metadata) {\n      this._logger.debug(\"using metadata from settings\");\n      this._metadata = this._settings.metadata;\n    }\n    if (this._settings.fetchRequestCredentials) {\n      this._logger.debug(\"using fetchRequestCredentials from settings\");\n      this._fetchRequestCredentials = this._settings.fetchRequestCredentials;\n    }\n  }\n  resetSigningKeys() {\n    this._signingKeys = null;\n  }\n  async getMetadata() {\n    const logger2 = this._logger.create(\"getMetadata\");\n    if (this._metadata) {\n      logger2.debug(\"using cached values\");\n      return this._metadata;\n    }\n    if (!this._metadataUrl) {\n      logger2.throw(new Error(\"No authority or metadataUrl configured on settings\"));\n      throw null;\n    }\n    logger2.debug(\"getting metadata from\", this._metadataUrl);\n    const metadata = await this._jsonService.getJson(this._metadataUrl, { credentials: this._fetchRequestCredentials });\n    logger2.debug(\"merging remote JSON with seed metadata\");\n    this._metadata = Object.assign({}, this._settings.metadataSeed, metadata);\n    return this._metadata;\n  }\n  getIssuer() {\n    return this._getMetadataProperty(\"issuer\");\n  }\n  getAuthorizationEndpoint() {\n    return this._getMetadataProperty(\"authorization_endpoint\");\n  }\n  getUserInfoEndpoint() {\n    return this._getMetadataProperty(\"userinfo_endpoint\");\n  }\n  getTokenEndpoint(optional = true) {\n    return this._getMetadataProperty(\"token_endpoint\", optional);\n  }\n  getCheckSessionIframe() {\n    return this._getMetadataProperty(\"check_session_iframe\", true);\n  }\n  getEndSessionEndpoint() {\n    return this._getMetadataProperty(\"end_session_endpoint\", true);\n  }\n  getRevocationEndpoint(optional = true) {\n    return this._getMetadataProperty(\"revocation_endpoint\", optional);\n  }\n  getKeysEndpoint(optional = true) {\n    return this._getMetadataProperty(\"jwks_uri\", optional);\n  }\n  async _getMetadataProperty(name, optional = false) {\n    const logger2 = this._logger.create(`_getMetadataProperty('${name}')`);\n    const metadata = await this.getMetadata();\n    logger2.debug(\"resolved\");\n    if (metadata[name] === void 0) {\n      if (optional === true) {\n        logger2.warn(\"Metadata does not contain optional property\");\n        return void 0;\n      }\n      logger2.throw(new Error(\"Metadata does not contain property \" + name));\n    }\n    return metadata[name];\n  }\n  async getSigningKeys() {\n    const logger2 = this._logger.create(\"getSigningKeys\");\n    if (this._signingKeys) {\n      logger2.debug(\"returning signingKeys from cache\");\n      return this._signingKeys;\n    }\n    const jwks_uri = await this.getKeysEndpoint(false);\n    logger2.debug(\"got jwks_uri\", jwks_uri);\n    const keySet = await this._jsonService.getJson(jwks_uri);\n    logger2.debug(\"got key set\", keySet);\n    if (!Array.isArray(keySet.keys)) {\n      logger2.throw(new Error(\"Missing keys on keyset\"));\n      throw null;\n    }\n    this._signingKeys = keySet.keys;\n    return this._signingKeys;\n  }\n};\n\n// src/WebStorageStateStore.ts\nvar WebStorageStateStore = class {\n  constructor({\n    prefix = \"oidc.\",\n    store = localStorage\n  } = {}) {\n    this._logger = new Logger(\"WebStorageStateStore\");\n    this._store = store;\n    this._prefix = prefix;\n  }\n  async set(key, value) {\n    this._logger.create(`set('${key}')`);\n    key = this._prefix + key;\n    await this._store.setItem(key, value);\n  }\n  async get(key) {\n    this._logger.create(`get('${key}')`);\n    key = this._prefix + key;\n    const item = await this._store.getItem(key);\n    return item;\n  }\n  async remove(key) {\n    this._logger.create(`remove('${key}')`);\n    key = this._prefix + key;\n    const item = await this._store.getItem(key);\n    await this._store.removeItem(key);\n    return item;\n  }\n  async getAllKeys() {\n    this._logger.create(\"getAllKeys\");\n    const len = await this._store.length;\n    const keys = [];\n    for (let index = 0; index < len; index++) {\n      const key = await this._store.key(index);\n      if (key && key.indexOf(this._prefix) === 0) {\n        keys.push(key.substr(this._prefix.length));\n      }\n    }\n    return keys;\n  }\n};\n\n// src/OidcClientSettings.ts\nvar DefaultResponseType = \"code\";\nvar DefaultScope = \"openid\";\nvar DefaultClientAuthentication = \"client_secret_post\";\nvar DefaultResponseMode = \"query\";\nvar DefaultStaleStateAgeInSeconds = 60 * 15;\nvar DefaultClockSkewInSeconds = 60 * 5;\nvar OidcClientSettingsStore = class {\n  constructor({\n    // metadata related\n    authority,\n    metadataUrl,\n    metadata,\n    signingKeys,\n    metadataSeed,\n    // client related\n    client_id,\n    client_secret,\n    response_type = DefaultResponseType,\n    scope = DefaultScope,\n    redirect_uri,\n    post_logout_redirect_uri,\n    client_authentication = DefaultClientAuthentication,\n    // optional protocol\n    prompt,\n    display,\n    max_age,\n    ui_locales,\n    acr_values,\n    resource,\n    response_mode = DefaultResponseMode,\n    // behavior flags\n    filterProtocolClaims = true,\n    loadUserInfo = false,\n    staleStateAgeInSeconds = DefaultStaleStateAgeInSeconds,\n    clockSkewInSeconds = DefaultClockSkewInSeconds,\n    userInfoJwtIssuer = \"OP\",\n    mergeClaims = false,\n    disablePKCE = false,\n    // other behavior\n    stateStore,\n    refreshTokenCredentials,\n    revokeTokenAdditionalContentTypes,\n    fetchRequestCredentials,\n    refreshTokenAllowedScope,\n    // extra\n    extraQueryParams = {},\n    extraTokenParams = {},\n    extraHeaders = {}\n  }) {\n    this.authority = authority;\n    if (metadataUrl) {\n      this.metadataUrl = metadataUrl;\n    } else {\n      this.metadataUrl = authority;\n      if (authority) {\n        if (!this.metadataUrl.endsWith(\"/\")) {\n          this.metadataUrl += \"/\";\n        }\n        this.metadataUrl += \".well-known/openid-configuration\";\n      }\n    }\n    this.metadata = metadata;\n    this.metadataSeed = metadataSeed;\n    this.signingKeys = signingKeys;\n    this.client_id = client_id;\n    this.client_secret = client_secret;\n    this.response_type = response_type;\n    this.scope = scope;\n    this.redirect_uri = redirect_uri;\n    this.post_logout_redirect_uri = post_logout_redirect_uri;\n    this.client_authentication = client_authentication;\n    this.prompt = prompt;\n    this.display = display;\n    this.max_age = max_age;\n    this.ui_locales = ui_locales;\n    this.acr_values = acr_values;\n    this.resource = resource;\n    this.response_mode = response_mode;\n    this.filterProtocolClaims = filterProtocolClaims != null ? filterProtocolClaims : true;\n    this.loadUserInfo = !!loadUserInfo;\n    this.staleStateAgeInSeconds = staleStateAgeInSeconds;\n    this.clockSkewInSeconds = clockSkewInSeconds;\n    this.userInfoJwtIssuer = userInfoJwtIssuer;\n    this.mergeClaims = !!mergeClaims;\n    this.disablePKCE = !!disablePKCE;\n    this.revokeTokenAdditionalContentTypes = revokeTokenAdditionalContentTypes;\n    if (fetchRequestCredentials && refreshTokenCredentials) {\n      console.warn(\"Both fetchRequestCredentials and refreshTokenCredentials is set. Only fetchRequestCredentials will be used.\");\n    }\n    this.fetchRequestCredentials = fetchRequestCredentials ? fetchRequestCredentials : refreshTokenCredentials ? refreshTokenCredentials : \"same-origin\";\n    if (stateStore) {\n      this.stateStore = stateStore;\n    } else {\n      const store = typeof window !== \"undefined\" ? window.localStorage : new InMemoryWebStorage();\n      this.stateStore = new WebStorageStateStore({ store });\n    }\n    this.refreshTokenAllowedScope = refreshTokenAllowedScope;\n    this.extraQueryParams = extraQueryParams;\n    this.extraTokenParams = extraTokenParams;\n    this.extraHeaders = extraHeaders;\n  }\n};\n\n// src/UserInfoService.ts\nvar UserInfoService = class {\n  constructor(_settings, _metadataService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._logger = new Logger(\"UserInfoService\");\n    this._getClaimsFromJwt = async (responseText) => {\n      const logger2 = this._logger.create(\"_getClaimsFromJwt\");\n      try {\n        const payload = JwtUtils.decode(responseText);\n        logger2.debug(\"JWT decoding successful\");\n        return payload;\n      } catch (err) {\n        logger2.error(\"Error parsing JWT response\");\n        throw err;\n      }\n    };\n    this._jsonService = new JsonService(\n      void 0,\n      this._getClaimsFromJwt,\n      this._settings.extraHeaders\n    );\n  }\n  async getClaims(token) {\n    const logger2 = this._logger.create(\"getClaims\");\n    if (!token) {\n      this._logger.throw(new Error(\"No token passed\"));\n    }\n    const url = await this._metadataService.getUserInfoEndpoint();\n    logger2.debug(\"got userinfo url\", url);\n    const claims = await this._jsonService.getJson(url, {\n      token,\n      credentials: this._settings.fetchRequestCredentials\n    });\n    logger2.debug(\"got claims\", claims);\n    return claims;\n  }\n};\n\n// src/TokenClient.ts\nvar TokenClient = class {\n  constructor(_settings, _metadataService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._logger = new Logger(\"TokenClient\");\n    this._jsonService = new JsonService(\n      this._settings.revokeTokenAdditionalContentTypes,\n      null,\n      this._settings.extraHeaders\n    );\n  }\n  /**\n   * Exchange code.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3\n   */\n  async exchangeCode({\n    grant_type = \"authorization_code\",\n    redirect_uri = this._settings.redirect_uri,\n    client_id = this._settings.client_id,\n    client_secret = this._settings.client_secret,\n    ...args\n  }) {\n    const logger2 = this._logger.create(\"exchangeCode\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    if (!redirect_uri) {\n      logger2.throw(new Error(\"A redirect_uri is required\"));\n    }\n    if (!args.code) {\n      logger2.throw(new Error(\"A code is required\"));\n    }\n    const params = new URLSearchParams({ grant_type, redirect_uri });\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    let basicAuth;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (!client_secret) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n    }\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, { body: params, basicAuth, initCredentials: this._settings.fetchRequestCredentials });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Exchange credentials.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.3.2\n   */\n  async exchangeCredentials({\n    grant_type = \"password\",\n    client_id = this._settings.client_id,\n    client_secret = this._settings.client_secret,\n    scope = this._settings.scope,\n    ...args\n  }) {\n    const logger2 = this._logger.create(\"exchangeCredentials\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    const params = new URLSearchParams({ grant_type, scope });\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    let basicAuth;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (!client_secret) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n    }\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, { body: params, basicAuth, initCredentials: this._settings.fetchRequestCredentials });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Exchange a refresh token.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-6\n   */\n  async exchangeRefreshToken({\n    grant_type = \"refresh_token\",\n    client_id = this._settings.client_id,\n    client_secret = this._settings.client_secret,\n    timeoutInSeconds,\n    ...args\n  }) {\n    const logger2 = this._logger.create(\"exchangeRefreshToken\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    if (!args.refresh_token) {\n      logger2.throw(new Error(\"A refresh_token is required\"));\n    }\n    const params = new URLSearchParams({ grant_type });\n    for (const [key, value] of Object.entries(args)) {\n      if (Array.isArray(value)) {\n        value.forEach((param) => params.append(key, param));\n      } else if (value != null) {\n        params.set(key, value);\n      }\n    }\n    let basicAuth;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (!client_secret) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n    }\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, { body: params, basicAuth, timeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Revoke an access or refresh token.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc7009#section-2.1\n   */\n  async revoke(args) {\n    var _a;\n    const logger2 = this._logger.create(\"revoke\");\n    if (!args.token) {\n      logger2.throw(new Error(\"A token is required\"));\n    }\n    const url = await this._metadataService.getRevocationEndpoint(false);\n    logger2.debug(`got revocation endpoint, revoking ${(_a = args.token_type_hint) != null ? _a : \"default token type\"}`);\n    const params = new URLSearchParams();\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    params.set(\"client_id\", this._settings.client_id);\n    if (this._settings.client_secret) {\n      params.set(\"client_secret\", this._settings.client_secret);\n    }\n    await this._jsonService.postForm(url, { body: params });\n    logger2.debug(\"got response\");\n  }\n};\n\n// src/ResponseValidator.ts\nvar ResponseValidator = class {\n  constructor(_settings, _metadataService, _claimsService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._claimsService = _claimsService;\n    this._logger = new Logger(\"ResponseValidator\");\n    this._userInfoService = new UserInfoService(this._settings, this._metadataService);\n    this._tokenClient = new TokenClient(this._settings, this._metadataService);\n  }\n  async validateSigninResponse(response, state) {\n    const logger2 = this._logger.create(\"validateSigninResponse\");\n    this._processSigninState(response, state);\n    logger2.debug(\"state processed\");\n    await this._processCode(response, state);\n    logger2.debug(\"code processed\");\n    if (response.isOpenId) {\n      this._validateIdTokenAttributes(response);\n    }\n    logger2.debug(\"tokens validated\");\n    await this._processClaims(response, state == null ? void 0 : state.skipUserInfo, response.isOpenId);\n    logger2.debug(\"claims processed\");\n  }\n  async validateCredentialsResponse(response, skipUserInfo) {\n    const logger2 = this._logger.create(\"validateCredentialsResponse\");\n    if (response.isOpenId && !!response.id_token) {\n      this._validateIdTokenAttributes(response);\n    }\n    logger2.debug(\"tokens validated\");\n    await this._processClaims(response, skipUserInfo, response.isOpenId);\n    logger2.debug(\"claims processed\");\n  }\n  async validateRefreshResponse(response, state) {\n    var _a, _b;\n    const logger2 = this._logger.create(\"validateRefreshResponse\");\n    response.userState = state.data;\n    (_a = response.session_state) != null ? _a : response.session_state = state.session_state;\n    (_b = response.scope) != null ? _b : response.scope = state.scope;\n    if (response.isOpenId && !!response.id_token) {\n      this._validateIdTokenAttributes(response, state.id_token);\n      logger2.debug(\"ID Token validated\");\n    }\n    if (!response.id_token) {\n      response.id_token = state.id_token;\n      response.profile = state.profile;\n    }\n    const hasIdToken = response.isOpenId && !!response.id_token;\n    await this._processClaims(response, false, hasIdToken);\n    logger2.debug(\"claims processed\");\n  }\n  validateSignoutResponse(response, state) {\n    const logger2 = this._logger.create(\"validateSignoutResponse\");\n    if (state.id !== response.state) {\n      logger2.throw(new Error(\"State does not match\"));\n    }\n    logger2.debug(\"state validated\");\n    response.userState = state.data;\n    if (response.error) {\n      logger2.warn(\"Response was error\", response.error);\n      throw new ErrorResponse(response);\n    }\n  }\n  _processSigninState(response, state) {\n    var _a;\n    const logger2 = this._logger.create(\"_processSigninState\");\n    if (state.id !== response.state) {\n      logger2.throw(new Error(\"State does not match\"));\n    }\n    if (!state.client_id) {\n      logger2.throw(new Error(\"No client_id on state\"));\n    }\n    if (!state.authority) {\n      logger2.throw(new Error(\"No authority on state\"));\n    }\n    if (this._settings.authority !== state.authority) {\n      logger2.throw(new Error(\"authority mismatch on settings vs. signin state\"));\n    }\n    if (this._settings.client_id && this._settings.client_id !== state.client_id) {\n      logger2.throw(new Error(\"client_id mismatch on settings vs. signin state\"));\n    }\n    logger2.debug(\"state validated\");\n    response.userState = state.data;\n    response.url_state = state.url_state;\n    (_a = response.scope) != null ? _a : response.scope = state.scope;\n    if (response.error) {\n      logger2.warn(\"Response was error\", response.error);\n      throw new ErrorResponse(response);\n    }\n    if (state.code_verifier && !response.code) {\n      logger2.throw(new Error(\"Expected code in response\"));\n    }\n  }\n  async _processClaims(response, skipUserInfo = false, validateSub = true) {\n    const logger2 = this._logger.create(\"_processClaims\");\n    response.profile = this._claimsService.filterProtocolClaims(response.profile);\n    if (skipUserInfo || !this._settings.loadUserInfo || !response.access_token) {\n      logger2.debug(\"not loading user info\");\n      return;\n    }\n    logger2.debug(\"loading user info\");\n    const claims = await this._userInfoService.getClaims(response.access_token);\n    logger2.debug(\"user info claims received from user info endpoint\");\n    if (validateSub && claims.sub !== response.profile.sub) {\n      logger2.throw(new Error(\"subject from UserInfo response does not match subject in ID Token\"));\n    }\n    response.profile = this._claimsService.mergeClaims(response.profile, this._claimsService.filterProtocolClaims(claims));\n    logger2.debug(\"user info claims received, updated profile:\", response.profile);\n  }\n  async _processCode(response, state) {\n    const logger2 = this._logger.create(\"_processCode\");\n    if (response.code) {\n      logger2.debug(\"Validating code\");\n      const tokenResponse = await this._tokenClient.exchangeCode({\n        client_id: state.client_id,\n        client_secret: state.client_secret,\n        code: response.code,\n        redirect_uri: state.redirect_uri,\n        code_verifier: state.code_verifier,\n        ...state.extraTokenParams\n      });\n      Object.assign(response, tokenResponse);\n    } else {\n      logger2.debug(\"No code to process\");\n    }\n  }\n  _validateIdTokenAttributes(response, existingToken) {\n    var _a;\n    const logger2 = this._logger.create(\"_validateIdTokenAttributes\");\n    logger2.debug(\"decoding ID Token JWT\");\n    const incoming = JwtUtils.decode((_a = response.id_token) != null ? _a : \"\");\n    if (!incoming.sub) {\n      logger2.throw(new Error(\"ID Token is missing a subject claim\"));\n    }\n    if (existingToken) {\n      const existing = JwtUtils.decode(existingToken);\n      if (incoming.sub !== existing.sub) {\n        logger2.throw(new Error(\"sub in id_token does not match current sub\"));\n      }\n      if (incoming.auth_time && incoming.auth_time !== existing.auth_time) {\n        logger2.throw(new Error(\"auth_time in id_token does not match original auth_time\"));\n      }\n      if (incoming.azp && incoming.azp !== existing.azp) {\n        logger2.throw(new Error(\"azp in id_token does not match original azp\"));\n      }\n      if (!incoming.azp && existing.azp) {\n        logger2.throw(new Error(\"azp not in id_token, but present in original id_token\"));\n      }\n    }\n    response.profile = incoming;\n  }\n};\n\n// src/State.ts\nvar State = class {\n  constructor(args) {\n    this.id = args.id || CryptoUtils.generateUUIDv4();\n    this.data = args.data;\n    if (args.created && args.created > 0) {\n      this.created = args.created;\n    } else {\n      this.created = Timer.getEpochTime();\n    }\n    this.request_type = args.request_type;\n    this.url_state = args.url_state;\n  }\n  toStorageString() {\n    new Logger(\"State\").create(\"toStorageString\");\n    return JSON.stringify({\n      id: this.id,\n      data: this.data,\n      created: this.created,\n      request_type: this.request_type,\n      url_state: this.url_state\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"State\", \"fromStorageString\");\n    return new State(JSON.parse(storageString));\n  }\n  static async clearStaleState(storage, age) {\n    const logger2 = Logger.createStatic(\"State\", \"clearStaleState\");\n    const cutoff = Timer.getEpochTime() - age;\n    const keys = await storage.getAllKeys();\n    logger2.debug(\"got keys\", keys);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const item = await storage.get(key);\n      let remove = false;\n      if (item) {\n        try {\n          const state = State.fromStorageString(item);\n          logger2.debug(\"got item from key:\", key, state.created);\n          if (state.created <= cutoff) {\n            remove = true;\n          }\n        } catch (err) {\n          logger2.error(\"Error parsing state for key:\", key, err);\n          remove = true;\n        }\n      } else {\n        logger2.debug(\"no item in storage for key:\", key);\n        remove = true;\n      }\n      if (remove) {\n        logger2.debug(\"removed item for key:\", key);\n        void storage.remove(key);\n      }\n    }\n  }\n};\n\n// src/SigninState.ts\nvar SigninState = class extends State {\n  constructor(args) {\n    super(args);\n    if (args.code_verifier === true) {\n      this.code_verifier = CryptoUtils.generateCodeVerifier();\n    } else if (args.code_verifier) {\n      this.code_verifier = args.code_verifier;\n    }\n    if (this.code_verifier) {\n      this.code_challenge = CryptoUtils.generateCodeChallenge(this.code_verifier);\n    }\n    this.authority = args.authority;\n    this.client_id = args.client_id;\n    this.redirect_uri = args.redirect_uri;\n    this.scope = args.scope;\n    this.client_secret = args.client_secret;\n    this.extraTokenParams = args.extraTokenParams;\n    this.response_mode = args.response_mode;\n    this.skipUserInfo = args.skipUserInfo;\n  }\n  toStorageString() {\n    new Logger(\"SigninState\").create(\"toStorageString\");\n    return JSON.stringify({\n      id: this.id,\n      data: this.data,\n      created: this.created,\n      request_type: this.request_type,\n      url_state: this.url_state,\n      code_verifier: this.code_verifier,\n      authority: this.authority,\n      client_id: this.client_id,\n      redirect_uri: this.redirect_uri,\n      scope: this.scope,\n      client_secret: this.client_secret,\n      extraTokenParams: this.extraTokenParams,\n      response_mode: this.response_mode,\n      skipUserInfo: this.skipUserInfo\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"SigninState\", \"fromStorageString\");\n    const data = JSON.parse(storageString);\n    return new SigninState(data);\n  }\n};\n\n// src/SigninRequest.ts\nvar SigninRequest = class {\n  constructor({\n    // mandatory\n    url,\n    authority,\n    client_id,\n    redirect_uri,\n    response_type,\n    scope,\n    // optional\n    state_data,\n    response_mode,\n    request_type,\n    client_secret,\n    nonce,\n    url_state,\n    resource,\n    skipUserInfo,\n    extraQueryParams,\n    extraTokenParams,\n    disablePKCE,\n    ...optionalParams\n  }) {\n    this._logger = new Logger(\"SigninRequest\");\n    if (!url) {\n      this._logger.error(\"ctor: No url passed\");\n      throw new Error(\"url\");\n    }\n    if (!client_id) {\n      this._logger.error(\"ctor: No client_id passed\");\n      throw new Error(\"client_id\");\n    }\n    if (!redirect_uri) {\n      this._logger.error(\"ctor: No redirect_uri passed\");\n      throw new Error(\"redirect_uri\");\n    }\n    if (!response_type) {\n      this._logger.error(\"ctor: No response_type passed\");\n      throw new Error(\"response_type\");\n    }\n    if (!scope) {\n      this._logger.error(\"ctor: No scope passed\");\n      throw new Error(\"scope\");\n    }\n    if (!authority) {\n      this._logger.error(\"ctor: No authority passed\");\n      throw new Error(\"authority\");\n    }\n    this.state = new SigninState({\n      data: state_data,\n      request_type,\n      url_state,\n      code_verifier: !disablePKCE,\n      client_id,\n      authority,\n      redirect_uri,\n      response_mode,\n      client_secret,\n      scope,\n      extraTokenParams,\n      skipUserInfo\n    });\n    const parsedUrl = new URL(url);\n    parsedUrl.searchParams.append(\"client_id\", client_id);\n    parsedUrl.searchParams.append(\"redirect_uri\", redirect_uri);\n    parsedUrl.searchParams.append(\"response_type\", response_type);\n    parsedUrl.searchParams.append(\"scope\", scope);\n    if (nonce) {\n      parsedUrl.searchParams.append(\"nonce\", nonce);\n    }\n    let state = this.state.id;\n    if (url_state) {\n      state = `${state}${URL_STATE_DELIMITER}${url_state}`;\n    }\n    parsedUrl.searchParams.append(\"state\", state);\n    if (this.state.code_challenge) {\n      parsedUrl.searchParams.append(\"code_challenge\", this.state.code_challenge);\n      parsedUrl.searchParams.append(\"code_challenge_method\", \"S256\");\n    }\n    if (resource) {\n      const resources = Array.isArray(resource) ? resource : [resource];\n      resources.forEach((r) => parsedUrl.searchParams.append(\"resource\", r));\n    }\n    for (const [key, value] of Object.entries({ response_mode, ...optionalParams, ...extraQueryParams })) {\n      if (value != null) {\n        parsedUrl.searchParams.append(key, value.toString());\n      }\n    }\n    this.url = parsedUrl.href;\n  }\n};\n\n// src/SigninResponse.ts\nvar OidcScope = \"openid\";\nvar SigninResponse = class {\n  constructor(params) {\n    /** @see {@link User.access_token} */\n    this.access_token = \"\";\n    /** @see {@link User.token_type} */\n    this.token_type = \"\";\n    /** @see {@link User.profile} */\n    this.profile = {};\n    this.state = params.get(\"state\");\n    this.session_state = params.get(\"session_state\");\n    if (this.state) {\n      const splitState = decodeURIComponent(this.state).split(URL_STATE_DELIMITER);\n      this.state = splitState[0];\n      if (splitState.length > 1) {\n        this.url_state = splitState.slice(1).join(URL_STATE_DELIMITER);\n      }\n    }\n    this.error = params.get(\"error\");\n    this.error_description = params.get(\"error_description\");\n    this.error_uri = params.get(\"error_uri\");\n    this.code = params.get(\"code\");\n  }\n  get expires_in() {\n    if (this.expires_at === void 0) {\n      return void 0;\n    }\n    return this.expires_at - Timer.getEpochTime();\n  }\n  set expires_in(value) {\n    if (typeof value === \"string\")\n      value = Number(value);\n    if (value !== void 0 && value >= 0) {\n      this.expires_at = Math.floor(value) + Timer.getEpochTime();\n    }\n  }\n  get isOpenId() {\n    var _a;\n    return ((_a = this.scope) == null ? void 0 : _a.split(\" \").includes(OidcScope)) || !!this.id_token;\n  }\n};\n\n// src/SignoutRequest.ts\nvar SignoutRequest = class {\n  constructor({\n    url,\n    state_data,\n    id_token_hint,\n    post_logout_redirect_uri,\n    extraQueryParams,\n    request_type,\n    client_id\n  }) {\n    this._logger = new Logger(\"SignoutRequest\");\n    if (!url) {\n      this._logger.error(\"ctor: No url passed\");\n      throw new Error(\"url\");\n    }\n    const parsedUrl = new URL(url);\n    if (id_token_hint) {\n      parsedUrl.searchParams.append(\"id_token_hint\", id_token_hint);\n    }\n    if (client_id) {\n      parsedUrl.searchParams.append(\"client_id\", client_id);\n    }\n    if (post_logout_redirect_uri) {\n      parsedUrl.searchParams.append(\"post_logout_redirect_uri\", post_logout_redirect_uri);\n      if (state_data) {\n        this.state = new State({ data: state_data, request_type });\n        parsedUrl.searchParams.append(\"state\", this.state.id);\n      }\n    }\n    for (const [key, value] of Object.entries({ ...extraQueryParams })) {\n      if (value != null) {\n        parsedUrl.searchParams.append(key, value.toString());\n      }\n    }\n    this.url = parsedUrl.href;\n  }\n};\n\n// src/SignoutResponse.ts\nvar SignoutResponse = class {\n  constructor(params) {\n    this.state = params.get(\"state\");\n    this.error = params.get(\"error\");\n    this.error_description = params.get(\"error_description\");\n    this.error_uri = params.get(\"error_uri\");\n  }\n};\n\n// src/ClaimsService.ts\nvar DefaultProtocolClaims = [\n  \"nbf\",\n  \"jti\",\n  \"auth_time\",\n  \"nonce\",\n  \"acr\",\n  \"amr\",\n  \"azp\",\n  \"at_hash\"\n  // https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken\n];\nvar InternalRequiredProtocolClaims = [\"sub\", \"iss\", \"aud\", \"exp\", \"iat\"];\nvar ClaimsService = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"ClaimsService\");\n  }\n  filterProtocolClaims(claims) {\n    const result = { ...claims };\n    if (this._settings.filterProtocolClaims) {\n      let protocolClaims;\n      if (Array.isArray(this._settings.filterProtocolClaims)) {\n        protocolClaims = this._settings.filterProtocolClaims;\n      } else {\n        protocolClaims = DefaultProtocolClaims;\n      }\n      for (const claim of protocolClaims) {\n        if (!InternalRequiredProtocolClaims.includes(claim)) {\n          delete result[claim];\n        }\n      }\n    }\n    return result;\n  }\n  mergeClaims(claims1, claims2) {\n    const result = { ...claims1 };\n    for (const [claim, values] of Object.entries(claims2)) {\n      for (const value of Array.isArray(values) ? values : [values]) {\n        const previousValue = result[claim];\n        if (previousValue === void 0) {\n          result[claim] = value;\n        } else if (Array.isArray(previousValue)) {\n          if (!previousValue.includes(value)) {\n            previousValue.push(value);\n          }\n        } else if (result[claim] !== value) {\n          if (typeof value === \"object\" && this._settings.mergeClaims) {\n            result[claim] = this.mergeClaims(previousValue, value);\n          } else {\n            result[claim] = [previousValue, value];\n          }\n        }\n      }\n    }\n    return result;\n  }\n};\n\n// src/OidcClient.ts\nvar OidcClient = class {\n  constructor(settings, metadataService) {\n    this._logger = new Logger(\"OidcClient\");\n    this.settings = settings instanceof OidcClientSettingsStore ? settings : new OidcClientSettingsStore(settings);\n    this.metadataService = metadataService != null ? metadataService : new MetadataService(this.settings);\n    this._claimsService = new ClaimsService(this.settings);\n    this._validator = new ResponseValidator(this.settings, this.metadataService, this._claimsService);\n    this._tokenClient = new TokenClient(this.settings, this.metadataService);\n  }\n  async createSigninRequest({\n    state,\n    request,\n    request_uri,\n    request_type,\n    id_token_hint,\n    login_hint,\n    skipUserInfo,\n    nonce,\n    url_state,\n    response_type = this.settings.response_type,\n    scope = this.settings.scope,\n    redirect_uri = this.settings.redirect_uri,\n    prompt = this.settings.prompt,\n    display = this.settings.display,\n    max_age = this.settings.max_age,\n    ui_locales = this.settings.ui_locales,\n    acr_values = this.settings.acr_values,\n    resource = this.settings.resource,\n    response_mode = this.settings.response_mode,\n    extraQueryParams = this.settings.extraQueryParams,\n    extraTokenParams = this.settings.extraTokenParams\n  }) {\n    const logger2 = this._logger.create(\"createSigninRequest\");\n    if (response_type !== \"code\") {\n      throw new Error(\"Only the Authorization Code flow (with PKCE) is supported\");\n    }\n    const url = await this.metadataService.getAuthorizationEndpoint();\n    logger2.debug(\"Received authorization endpoint\", url);\n    const signinRequest = new SigninRequest({\n      url,\n      authority: this.settings.authority,\n      client_id: this.settings.client_id,\n      redirect_uri,\n      response_type,\n      scope,\n      state_data: state,\n      url_state,\n      prompt,\n      display,\n      max_age,\n      ui_locales,\n      id_token_hint,\n      login_hint,\n      acr_values,\n      resource,\n      request,\n      request_uri,\n      extraQueryParams,\n      extraTokenParams,\n      request_type,\n      response_mode,\n      client_secret: this.settings.client_secret,\n      skipUserInfo,\n      nonce,\n      disablePKCE: this.settings.disablePKCE\n    });\n    await this.clearStaleState();\n    const signinState = signinRequest.state;\n    await this.settings.stateStore.set(signinState.id, signinState.toStorageString());\n    return signinRequest;\n  }\n  async readSigninResponseState(url, removeState = false) {\n    const logger2 = this._logger.create(\"readSigninResponseState\");\n    const response = new SigninResponse(UrlUtils.readParams(url, this.settings.response_mode));\n    if (!response.state) {\n      logger2.throw(new Error(\"No state in response\"));\n      throw null;\n    }\n    const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n    if (!storedStateString) {\n      logger2.throw(new Error(\"No matching state found in storage\"));\n      throw null;\n    }\n    const state = SigninState.fromStorageString(storedStateString);\n    return { state, response };\n  }\n  async processSigninResponse(url) {\n    const logger2 = this._logger.create(\"processSigninResponse\");\n    const { state, response } = await this.readSigninResponseState(url, true);\n    logger2.debug(\"received state from storage; validating response\");\n    await this._validator.validateSigninResponse(response, state);\n    return response;\n  }\n  async processResourceOwnerPasswordCredentials({\n    username,\n    password,\n    skipUserInfo = false,\n    extraTokenParams = {}\n  }) {\n    const tokenResponse = await this._tokenClient.exchangeCredentials({ username, password, ...extraTokenParams });\n    const signinResponse = new SigninResponse(new URLSearchParams());\n    Object.assign(signinResponse, tokenResponse);\n    await this._validator.validateCredentialsResponse(signinResponse, skipUserInfo);\n    return signinResponse;\n  }\n  async useRefreshToken({\n    state,\n    timeoutInSeconds\n  }) {\n    var _a;\n    const logger2 = this._logger.create(\"useRefreshToken\");\n    let scope;\n    if (this.settings.refreshTokenAllowedScope === void 0) {\n      scope = state.scope;\n    } else {\n      const allowableScopes = this.settings.refreshTokenAllowedScope.split(\" \");\n      const providedScopes = ((_a = state.scope) == null ? void 0 : _a.split(\" \")) || [];\n      scope = providedScopes.filter((s) => allowableScopes.includes(s)).join(\" \");\n    }\n    const result = await this._tokenClient.exchangeRefreshToken({\n      refresh_token: state.refresh_token,\n      resource: state.resource,\n      // provide the (possible filtered) scope list\n      scope,\n      timeoutInSeconds\n    });\n    const response = new SigninResponse(new URLSearchParams());\n    Object.assign(response, result);\n    logger2.debug(\"validating response\", response);\n    await this._validator.validateRefreshResponse(response, {\n      ...state,\n      // overide the scope in the state handed over to the validator\n      // so it can set the granted scope to the requested scope in case none is included in the response\n      scope\n    });\n    return response;\n  }\n  async createSignoutRequest({\n    state,\n    id_token_hint,\n    client_id,\n    request_type,\n    post_logout_redirect_uri = this.settings.post_logout_redirect_uri,\n    extraQueryParams = this.settings.extraQueryParams\n  } = {}) {\n    const logger2 = this._logger.create(\"createSignoutRequest\");\n    const url = await this.metadataService.getEndSessionEndpoint();\n    if (!url) {\n      logger2.throw(new Error(\"No end session endpoint\"));\n      throw null;\n    }\n    logger2.debug(\"Received end session endpoint\", url);\n    if (!client_id && post_logout_redirect_uri && !id_token_hint) {\n      client_id = this.settings.client_id;\n    }\n    const request = new SignoutRequest({\n      url,\n      id_token_hint,\n      client_id,\n      post_logout_redirect_uri,\n      state_data: state,\n      extraQueryParams,\n      request_type\n    });\n    await this.clearStaleState();\n    const signoutState = request.state;\n    if (signoutState) {\n      logger2.debug(\"Signout request has state to persist\");\n      await this.settings.stateStore.set(signoutState.id, signoutState.toStorageString());\n    }\n    return request;\n  }\n  async readSignoutResponseState(url, removeState = false) {\n    const logger2 = this._logger.create(\"readSignoutResponseState\");\n    const response = new SignoutResponse(UrlUtils.readParams(url, this.settings.response_mode));\n    if (!response.state) {\n      logger2.debug(\"No state in response\");\n      if (response.error) {\n        logger2.warn(\"Response was error:\", response.error);\n        throw new ErrorResponse(response);\n      }\n      return { state: void 0, response };\n    }\n    const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n    if (!storedStateString) {\n      logger2.throw(new Error(\"No matching state found in storage\"));\n      throw null;\n    }\n    const state = State.fromStorageString(storedStateString);\n    return { state, response };\n  }\n  async processSignoutResponse(url) {\n    const logger2 = this._logger.create(\"processSignoutResponse\");\n    const { state, response } = await this.readSignoutResponseState(url, true);\n    if (state) {\n      logger2.debug(\"Received state from storage; validating response\");\n      this._validator.validateSignoutResponse(response, state);\n    } else {\n      logger2.debug(\"No state from storage; skipping response validation\");\n    }\n    return response;\n  }\n  clearStaleState() {\n    this._logger.create(\"clearStaleState\");\n    return State.clearStaleState(this.settings.stateStore, this.settings.staleStateAgeInSeconds);\n  }\n  async revokeToken(token, type) {\n    this._logger.create(\"revokeToken\");\n    return await this._tokenClient.revoke({\n      token,\n      token_type_hint: type\n    });\n  }\n};\n\n// src/SessionMonitor.ts\nvar SessionMonitor = class {\n  constructor(_userManager) {\n    this._userManager = _userManager;\n    this._logger = new Logger(\"SessionMonitor\");\n    this._start = async (user) => {\n      const session_state = user.session_state;\n      if (!session_state) {\n        return;\n      }\n      const logger2 = this._logger.create(\"_start\");\n      if (user.profile) {\n        this._sub = user.profile.sub;\n        this._sid = user.profile.sid;\n        logger2.debug(\"session_state\", session_state, \", sub\", this._sub);\n      } else {\n        this._sub = void 0;\n        this._sid = void 0;\n        logger2.debug(\"session_state\", session_state, \", anonymous user\");\n      }\n      if (this._checkSessionIFrame) {\n        this._checkSessionIFrame.start(session_state);\n        return;\n      }\n      try {\n        const url = await this._userManager.metadataService.getCheckSessionIframe();\n        if (url) {\n          logger2.debug(\"initializing check session iframe\");\n          const client_id = this._userManager.settings.client_id;\n          const intervalInSeconds = this._userManager.settings.checkSessionIntervalInSeconds;\n          const stopOnError = this._userManager.settings.stopCheckSessionOnError;\n          const checkSessionIFrame = new CheckSessionIFrame(this._callback, client_id, url, intervalInSeconds, stopOnError);\n          await checkSessionIFrame.load();\n          this._checkSessionIFrame = checkSessionIFrame;\n          checkSessionIFrame.start(session_state);\n        } else {\n          logger2.warn(\"no check session iframe found in the metadata\");\n        }\n      } catch (err) {\n        logger2.error(\"Error from getCheckSessionIframe:\", err instanceof Error ? err.message : err);\n      }\n    };\n    this._stop = () => {\n      const logger2 = this._logger.create(\"_stop\");\n      this._sub = void 0;\n      this._sid = void 0;\n      if (this._checkSessionIFrame) {\n        this._checkSessionIFrame.stop();\n      }\n      if (this._userManager.settings.monitorAnonymousSession) {\n        const timerHandle = setInterval(async () => {\n          clearInterval(timerHandle);\n          try {\n            const session = await this._userManager.querySessionStatus();\n            if (session) {\n              const tmpUser = {\n                session_state: session.session_state,\n                profile: session.sub && session.sid ? {\n                  sub: session.sub,\n                  sid: session.sid\n                } : null\n              };\n              void this._start(tmpUser);\n            }\n          } catch (err) {\n            logger2.error(\"error from querySessionStatus\", err instanceof Error ? err.message : err);\n          }\n        }, 1e3);\n      }\n    };\n    this._callback = async () => {\n      const logger2 = this._logger.create(\"_callback\");\n      try {\n        const session = await this._userManager.querySessionStatus();\n        let raiseEvent = true;\n        if (session && this._checkSessionIFrame) {\n          if (session.sub === this._sub) {\n            raiseEvent = false;\n            this._checkSessionIFrame.start(session.session_state);\n            if (session.sid === this._sid) {\n              logger2.debug(\"same sub still logged in at OP, restarting check session iframe; session_state\", session.session_state);\n            } else {\n              logger2.debug(\"same sub still logged in at OP, session state has changed, restarting check session iframe; session_state\", session.session_state);\n              this._userManager.events._raiseUserSessionChanged();\n            }\n          } else {\n            logger2.debug(\"different subject signed into OP\", session.sub);\n          }\n        } else {\n          logger2.debug(\"subject no longer signed into OP\");\n        }\n        if (raiseEvent) {\n          if (this._sub) {\n            this._userManager.events._raiseUserSignedOut();\n          } else {\n            this._userManager.events._raiseUserSignedIn();\n          }\n        } else {\n          logger2.debug(\"no change in session detected, no event to raise\");\n        }\n      } catch (err) {\n        if (this._sub) {\n          logger2.debug(\"Error calling queryCurrentSigninSession; raising signed out event\", err);\n          this._userManager.events._raiseUserSignedOut();\n        }\n      }\n    };\n    if (!_userManager) {\n      this._logger.throw(new Error(\"No user manager passed\"));\n    }\n    this._userManager.events.addUserLoaded(this._start);\n    this._userManager.events.addUserUnloaded(this._stop);\n    this._init().catch((err) => {\n      this._logger.error(err);\n    });\n  }\n  async _init() {\n    this._logger.create(\"_init\");\n    const user = await this._userManager.getUser();\n    if (user) {\n      void this._start(user);\n    } else if (this._userManager.settings.monitorAnonymousSession) {\n      const session = await this._userManager.querySessionStatus();\n      if (session) {\n        const tmpUser = {\n          session_state: session.session_state,\n          profile: session.sub && session.sid ? {\n            sub: session.sub,\n            sid: session.sid\n          } : null\n        };\n        void this._start(tmpUser);\n      }\n    }\n  }\n};\n\n// src/User.ts\nvar User = class {\n  constructor(args) {\n    var _a;\n    this.id_token = args.id_token;\n    this.session_state = (_a = args.session_state) != null ? _a : null;\n    this.access_token = args.access_token;\n    this.refresh_token = args.refresh_token;\n    this.token_type = args.token_type;\n    this.scope = args.scope;\n    this.profile = args.profile;\n    this.expires_at = args.expires_at;\n    this.state = args.userState;\n    this.url_state = args.url_state;\n  }\n  /** Computed number of seconds the access token has remaining. */\n  get expires_in() {\n    if (this.expires_at === void 0) {\n      return void 0;\n    }\n    return this.expires_at - Timer.getEpochTime();\n  }\n  set expires_in(value) {\n    if (value !== void 0) {\n      this.expires_at = Math.floor(value) + Timer.getEpochTime();\n    }\n  }\n  /** Computed value indicating if the access token is expired. */\n  get expired() {\n    const expires_in = this.expires_in;\n    if (expires_in === void 0) {\n      return void 0;\n    }\n    return expires_in <= 0;\n  }\n  /** Array representing the parsed values from the `scope`. */\n  get scopes() {\n    var _a, _b;\n    return (_b = (_a = this.scope) == null ? void 0 : _a.split(\" \")) != null ? _b : [];\n  }\n  toStorageString() {\n    new Logger(\"User\").create(\"toStorageString\");\n    return JSON.stringify({\n      id_token: this.id_token,\n      session_state: this.session_state,\n      access_token: this.access_token,\n      refresh_token: this.refresh_token,\n      token_type: this.token_type,\n      scope: this.scope,\n      profile: this.profile,\n      expires_at: this.expires_at\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"User\", \"fromStorageString\");\n    return new User(JSON.parse(storageString));\n  }\n};\n\n// src/navigators/AbstractChildWindow.ts\nvar messageSource = \"oidc-client\";\nvar AbstractChildWindow = class {\n  constructor() {\n    this._abort = new Event(\"Window navigation aborted\");\n    this._disposeHandlers = /* @__PURE__ */ new Set();\n    this._window = null;\n  }\n  async navigate(params) {\n    const logger2 = this._logger.create(\"navigate\");\n    if (!this._window) {\n      throw new Error(\"Attempted to navigate on a disposed window\");\n    }\n    logger2.debug(\"setting URL in window\");\n    this._window.location.replace(params.url);\n    const { url, keepOpen } = await new Promise((resolve, reject) => {\n      const listener = (e) => {\n        var _a;\n        const data = e.data;\n        const origin = (_a = params.scriptOrigin) != null ? _a : window.location.origin;\n        if (e.origin !== origin || (data == null ? void 0 : data.source) !== messageSource) {\n          return;\n        }\n        try {\n          const state = UrlUtils.readParams(data.url, params.response_mode).get(\"state\");\n          if (!state) {\n            logger2.warn(\"no state found in response url\");\n          }\n          if (e.source !== this._window && state !== params.state) {\n            return;\n          }\n        } catch (err) {\n          this._dispose();\n          reject(new Error(\"Invalid response from window\"));\n        }\n        resolve(data);\n      };\n      window.addEventListener(\"message\", listener, false);\n      this._disposeHandlers.add(() => window.removeEventListener(\"message\", listener, false));\n      this._disposeHandlers.add(this._abort.addHandler((reason) => {\n        this._dispose();\n        reject(reason);\n      }));\n    });\n    logger2.debug(\"got response from window\");\n    this._dispose();\n    if (!keepOpen) {\n      this.close();\n    }\n    return { url };\n  }\n  _dispose() {\n    this._logger.create(\"_dispose\");\n    for (const dispose of this._disposeHandlers) {\n      dispose();\n    }\n    this._disposeHandlers.clear();\n  }\n  static _notifyParent(parent, url, keepOpen = false, targetOrigin = window.location.origin) {\n    parent.postMessage({\n      source: messageSource,\n      url,\n      keepOpen\n    }, targetOrigin);\n  }\n};\n\n// src/UserManagerSettings.ts\nvar DefaultPopupWindowFeatures = {\n  location: false,\n  toolbar: false,\n  height: 640,\n  closePopupWindowAfterInSeconds: -1\n};\nvar DefaultPopupTarget = \"_blank\";\nvar DefaultAccessTokenExpiringNotificationTimeInSeconds = 60;\nvar DefaultCheckSessionIntervalInSeconds = 2;\nvar DefaultSilentRequestTimeoutInSeconds = 10;\nvar UserManagerSettingsStore = class extends OidcClientSettingsStore {\n  constructor(args) {\n    const {\n      popup_redirect_uri = args.redirect_uri,\n      popup_post_logout_redirect_uri = args.post_logout_redirect_uri,\n      popupWindowFeatures = DefaultPopupWindowFeatures,\n      popupWindowTarget = DefaultPopupTarget,\n      redirectMethod = \"assign\",\n      redirectTarget = \"self\",\n      iframeNotifyParentOrigin = args.iframeNotifyParentOrigin,\n      iframeScriptOrigin = args.iframeScriptOrigin,\n      silent_redirect_uri = args.redirect_uri,\n      silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds,\n      automaticSilentRenew = true,\n      validateSubOnSilentRenew = true,\n      includeIdTokenInSilentRenew = false,\n      monitorSession = false,\n      monitorAnonymousSession = false,\n      checkSessionIntervalInSeconds = DefaultCheckSessionIntervalInSeconds,\n      query_status_response_type = \"code\",\n      stopCheckSessionOnError = true,\n      revokeTokenTypes = [\"access_token\", \"refresh_token\"],\n      revokeTokensOnSignout = false,\n      includeIdTokenInSilentSignout = false,\n      accessTokenExpiringNotificationTimeInSeconds = DefaultAccessTokenExpiringNotificationTimeInSeconds,\n      userStore\n    } = args;\n    super(args);\n    this.popup_redirect_uri = popup_redirect_uri;\n    this.popup_post_logout_redirect_uri = popup_post_logout_redirect_uri;\n    this.popupWindowFeatures = popupWindowFeatures;\n    this.popupWindowTarget = popupWindowTarget;\n    this.redirectMethod = redirectMethod;\n    this.redirectTarget = redirectTarget;\n    this.iframeNotifyParentOrigin = iframeNotifyParentOrigin;\n    this.iframeScriptOrigin = iframeScriptOrigin;\n    this.silent_redirect_uri = silent_redirect_uri;\n    this.silentRequestTimeoutInSeconds = silentRequestTimeoutInSeconds;\n    this.automaticSilentRenew = automaticSilentRenew;\n    this.validateSubOnSilentRenew = validateSubOnSilentRenew;\n    this.includeIdTokenInSilentRenew = includeIdTokenInSilentRenew;\n    this.monitorSession = monitorSession;\n    this.monitorAnonymousSession = monitorAnonymousSession;\n    this.checkSessionIntervalInSeconds = checkSessionIntervalInSeconds;\n    this.stopCheckSessionOnError = stopCheckSessionOnError;\n    this.query_status_response_type = query_status_response_type;\n    this.revokeTokenTypes = revokeTokenTypes;\n    this.revokeTokensOnSignout = revokeTokensOnSignout;\n    this.includeIdTokenInSilentSignout = includeIdTokenInSilentSignout;\n    this.accessTokenExpiringNotificationTimeInSeconds = accessTokenExpiringNotificationTimeInSeconds;\n    if (userStore) {\n      this.userStore = userStore;\n    } else {\n      const store = typeof window !== \"undefined\" ? window.sessionStorage : new InMemoryWebStorage();\n      this.userStore = new WebStorageStateStore({ store });\n    }\n  }\n};\n\n// src/navigators/IFrameWindow.ts\nvar IFrameWindow = class extends AbstractChildWindow {\n  constructor({\n    silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds\n  }) {\n    super();\n    this._logger = new Logger(\"IFrameWindow\");\n    this._timeoutInSeconds = silentRequestTimeoutInSeconds;\n    this._frame = IFrameWindow.createHiddenIframe();\n    this._window = this._frame.contentWindow;\n  }\n  static createHiddenIframe() {\n    const iframe = window.document.createElement(\"iframe\");\n    iframe.style.visibility = \"hidden\";\n    iframe.style.position = \"fixed\";\n    iframe.style.left = \"-1000px\";\n    iframe.style.top = \"0\";\n    iframe.width = \"0\";\n    iframe.height = \"0\";\n    window.document.body.appendChild(iframe);\n    return iframe;\n  }\n  async navigate(params) {\n    this._logger.debug(\"navigate: Using timeout of:\", this._timeoutInSeconds);\n    const timer = setTimeout(() => this._abort.raise(new ErrorTimeout(\"IFrame timed out without a response\")), this._timeoutInSeconds * 1e3);\n    this._disposeHandlers.add(() => clearTimeout(timer));\n    return await super.navigate(params);\n  }\n  close() {\n    var _a;\n    if (this._frame) {\n      if (this._frame.parentNode) {\n        this._frame.addEventListener(\"load\", (ev) => {\n          var _a2;\n          const frame = ev.target;\n          (_a2 = frame.parentNode) == null ? void 0 : _a2.removeChild(frame);\n          this._abort.raise(new Error(\"IFrame removed from DOM\"));\n        }, true);\n        (_a = this._frame.contentWindow) == null ? void 0 : _a.location.replace(\"about:blank\");\n      }\n      this._frame = null;\n    }\n    this._window = null;\n  }\n  static notifyParent(url, targetOrigin) {\n    return super._notifyParent(window.parent, url, false, targetOrigin);\n  }\n};\n\n// src/navigators/IFrameNavigator.ts\nvar IFrameNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"IFrameNavigator\");\n  }\n  async prepare({\n    silentRequestTimeoutInSeconds = this._settings.silentRequestTimeoutInSeconds\n  }) {\n    return new IFrameWindow({ silentRequestTimeoutInSeconds });\n  }\n  async callback(url) {\n    this._logger.create(\"callback\");\n    IFrameWindow.notifyParent(url, this._settings.iframeNotifyParentOrigin);\n  }\n};\n\n// src/navigators/PopupWindow.ts\nvar checkForPopupClosedInterval = 500;\nvar second = 1e3;\nvar PopupWindow = class extends AbstractChildWindow {\n  constructor({\n    popupWindowTarget = DefaultPopupTarget,\n    popupWindowFeatures = {}\n  }) {\n    super();\n    this._logger = new Logger(\"PopupWindow\");\n    const centeredPopup = PopupUtils.center({ ...DefaultPopupWindowFeatures, ...popupWindowFeatures });\n    this._window = window.open(void 0, popupWindowTarget, PopupUtils.serialize(centeredPopup));\n    if (popupWindowFeatures.closePopupWindowAfterInSeconds && popupWindowFeatures.closePopupWindowAfterInSeconds > 0) {\n      setTimeout(() => {\n        if (!this._window || typeof this._window.closed !== \"boolean\" || this._window.closed) {\n          this._abort.raise(new Error(\"Popup blocked by user\"));\n          return;\n        }\n        this.close();\n      }, popupWindowFeatures.closePopupWindowAfterInSeconds * second);\n    }\n  }\n  async navigate(params) {\n    var _a;\n    (_a = this._window) == null ? void 0 : _a.focus();\n    const popupClosedInterval = setInterval(() => {\n      if (!this._window || this._window.closed) {\n        this._abort.raise(new Error(\"Popup closed by user\"));\n      }\n    }, checkForPopupClosedInterval);\n    this._disposeHandlers.add(() => clearInterval(popupClosedInterval));\n    return await super.navigate(params);\n  }\n  close() {\n    if (this._window) {\n      if (!this._window.closed) {\n        this._window.close();\n        this._abort.raise(new Error(\"Popup closed\"));\n      }\n    }\n    this._window = null;\n  }\n  static notifyOpener(url, keepOpen) {\n    if (!window.opener) {\n      throw new Error(\"No window.opener. Can't complete notification.\");\n    }\n    return super._notifyParent(window.opener, url, keepOpen);\n  }\n};\n\n// src/navigators/PopupNavigator.ts\nvar PopupNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"PopupNavigator\");\n  }\n  async prepare({\n    popupWindowFeatures = this._settings.popupWindowFeatures,\n    popupWindowTarget = this._settings.popupWindowTarget\n  }) {\n    return new PopupWindow({ popupWindowFeatures, popupWindowTarget });\n  }\n  async callback(url, { keepOpen = false }) {\n    this._logger.create(\"callback\");\n    PopupWindow.notifyOpener(url, keepOpen);\n  }\n};\n\n// src/navigators/RedirectNavigator.ts\nvar RedirectNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"RedirectNavigator\");\n  }\n  async prepare({\n    redirectMethod = this._settings.redirectMethod,\n    redirectTarget = this._settings.redirectTarget\n  }) {\n    var _a;\n    this._logger.create(\"prepare\");\n    let targetWindow = window.self;\n    if (redirectTarget === \"top\") {\n      targetWindow = (_a = window.top) != null ? _a : window.self;\n    }\n    const redirect = targetWindow.location[redirectMethod].bind(targetWindow.location);\n    let abort;\n    return {\n      navigate: async (params) => {\n        this._logger.create(\"navigate\");\n        const promise = new Promise((resolve, reject) => {\n          abort = reject;\n        });\n        redirect(params.url);\n        return await promise;\n      },\n      close: () => {\n        this._logger.create(\"close\");\n        abort == null ? void 0 : abort(new Error(\"Redirect aborted\"));\n        targetWindow.stop();\n      }\n    };\n  }\n  async callback() {\n    return;\n  }\n};\n\n// src/UserManagerEvents.ts\nvar UserManagerEvents = class extends AccessTokenEvents {\n  constructor(settings) {\n    super({ expiringNotificationTimeInSeconds: settings.accessTokenExpiringNotificationTimeInSeconds });\n    this._logger = new Logger(\"UserManagerEvents\");\n    this._userLoaded = new Event(\"User loaded\");\n    this._userUnloaded = new Event(\"User unloaded\");\n    this._silentRenewError = new Event(\"Silent renew error\");\n    this._userSignedIn = new Event(\"User signed in\");\n    this._userSignedOut = new Event(\"User signed out\");\n    this._userSessionChanged = new Event(\"User session changed\");\n  }\n  load(user, raiseEvent = true) {\n    super.load(user);\n    if (raiseEvent) {\n      this._userLoaded.raise(user);\n    }\n  }\n  unload() {\n    super.unload();\n    this._userUnloaded.raise();\n  }\n  /**\n   * Add callback: Raised when a user session has been established (or re-established).\n   */\n  addUserLoaded(cb) {\n    return this._userLoaded.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when a user session has been established (or re-established).\n   */\n  removeUserLoaded(cb) {\n    return this._userLoaded.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised when a user session has been terminated.\n   */\n  addUserUnloaded(cb) {\n    return this._userUnloaded.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when a user session has been terminated.\n   */\n  removeUserUnloaded(cb) {\n    return this._userUnloaded.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised when the automatic silent renew has failed.\n   */\n  addSilentRenewError(cb) {\n    return this._silentRenewError.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the automatic silent renew has failed.\n   */\n  removeSilentRenewError(cb) {\n    return this._silentRenewError.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  _raiseSilentRenewError(e) {\n    this._silentRenewError.raise(e);\n  }\n  /**\n   * Add callback: Raised when the user is signed in (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSignedIn(cb) {\n    return this._userSignedIn.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user is signed in (when `monitorSession` is set).\n   */\n  removeUserSignedIn(cb) {\n    this._userSignedIn.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  _raiseUserSignedIn() {\n    this._userSignedIn.raise();\n  }\n  /**\n   * Add callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSignedOut(cb) {\n    return this._userSignedOut.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n   */\n  removeUserSignedOut(cb) {\n    this._userSignedOut.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  _raiseUserSignedOut() {\n    this._userSignedOut.raise();\n  }\n  /**\n   * Add callback: Raised when the user session changed (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSessionChanged(cb) {\n    return this._userSessionChanged.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user session changed (when `monitorSession` is set).\n   */\n  removeUserSessionChanged(cb) {\n    this._userSessionChanged.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  _raiseUserSessionChanged() {\n    this._userSessionChanged.raise();\n  }\n};\n\n// src/SilentRenewService.ts\nvar SilentRenewService = class {\n  constructor(_userManager) {\n    this._userManager = _userManager;\n    this._logger = new Logger(\"SilentRenewService\");\n    this._isStarted = false;\n    this._retryTimer = new Timer(\"Retry Silent Renew\");\n    this._tokenExpiring = async () => {\n      const logger2 = this._logger.create(\"_tokenExpiring\");\n      try {\n        await this._userManager.signinSilent();\n        logger2.debug(\"silent token renewal successful\");\n      } catch (err) {\n        if (err instanceof ErrorTimeout) {\n          logger2.warn(\"ErrorTimeout from signinSilent:\", err, \"retry in 5s\");\n          this._retryTimer.init(5);\n          return;\n        }\n        logger2.error(\"Error from signinSilent:\", err);\n        this._userManager.events._raiseSilentRenewError(err);\n      }\n    };\n  }\n  async start() {\n    const logger2 = this._logger.create(\"start\");\n    if (!this._isStarted) {\n      this._isStarted = true;\n      this._userManager.events.addAccessTokenExpiring(this._tokenExpiring);\n      this._retryTimer.addHandler(this._tokenExpiring);\n      try {\n        await this._userManager.getUser();\n      } catch (err) {\n        logger2.error(\"getUser error\", err);\n      }\n    }\n  }\n  stop() {\n    if (this._isStarted) {\n      this._retryTimer.cancel();\n      this._retryTimer.removeHandler(this._tokenExpiring);\n      this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring);\n      this._isStarted = false;\n    }\n  }\n};\n\n// src/RefreshState.ts\nvar RefreshState = class {\n  constructor(args, resource) {\n    this.refresh_token = args.refresh_token;\n    this.id_token = args.id_token;\n    this.session_state = args.session_state;\n    this.scope = args.scope;\n    this.profile = args.profile;\n    this.resource = resource;\n    this.data = args.state;\n  }\n};\n\n// src/UserManager.ts\nvar UserManager = class {\n  constructor(settings, redirectNavigator, popupNavigator, iframeNavigator) {\n    this._logger = new Logger(\"UserManager\");\n    this.settings = new UserManagerSettingsStore(settings);\n    this._client = new OidcClient(settings);\n    this._redirectNavigator = redirectNavigator != null ? redirectNavigator : new RedirectNavigator(this.settings);\n    this._popupNavigator = popupNavigator != null ? popupNavigator : new PopupNavigator(this.settings);\n    this._iframeNavigator = iframeNavigator != null ? iframeNavigator : new IFrameNavigator(this.settings);\n    this._events = new UserManagerEvents(this.settings);\n    this._silentRenewService = new SilentRenewService(this);\n    if (this.settings.automaticSilentRenew) {\n      this.startSilentRenew();\n    }\n    this._sessionMonitor = null;\n    if (this.settings.monitorSession) {\n      this._sessionMonitor = new SessionMonitor(this);\n    }\n  }\n  /** Returns an object used to register for events raised by the `UserManager`. */\n  get events() {\n    return this._events;\n  }\n  /** Returns an object used to access the metadata configuration of the OIDC provider. */\n  get metadataService() {\n    return this._client.metadataService;\n  }\n  /**\n   * Returns promise to load the `User` object for the currently authenticated user.\n   */\n  async getUser() {\n    const logger2 = this._logger.create(\"getUser\");\n    const user = await this._loadUser();\n    if (user) {\n      logger2.info(\"user loaded\");\n      this._events.load(user, false);\n      return user;\n    }\n    logger2.info(\"user not found in storage\");\n    return null;\n  }\n  /**\n   * Returns promise to remove from any storage the currently authenticated user.\n   */\n  async removeUser() {\n    const logger2 = this._logger.create(\"removeUser\");\n    await this.storeUser(null);\n    logger2.info(\"user removed from storage\");\n    this._events.unload();\n  }\n  /**\n   * Returns promise to trigger a redirect of the current window to the authorization endpoint.\n   */\n  async signinRedirect(args = {}) {\n    this._logger.create(\"signinRedirect\");\n    const {\n      redirectMethod,\n      ...requestArgs\n    } = args;\n    const handle = await this._redirectNavigator.prepare({ redirectMethod });\n    await this._signinStart({\n      request_type: \"si:r\",\n      ...requestArgs\n    }, handle);\n  }\n  /**\n   * Returns promise to process response from the authorization endpoint. The result of the promise is the authenticated `User`.\n   */\n  async signinRedirectCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signinRedirectCallback\");\n    const user = await this._signinEnd(url);\n    if (user.profile && user.profile.sub) {\n      logger2.info(\"success, signed in subject\", user.profile.sub);\n    } else {\n      logger2.info(\"no subject\");\n    }\n    return user;\n  }\n  /**\n   * Returns promise to process the signin with user/password. The result of the promise is the authenticated `User`.\n   *\n   * Throws an ErrorResponse in case of wrong authentication.\n   */\n  async signinResourceOwnerCredentials({\n    username,\n    password,\n    skipUserInfo = false\n  }) {\n    const logger2 = this._logger.create(\"signinResourceOwnerCredential\");\n    const signinResponse = await this._client.processResourceOwnerPasswordCredentials({ username, password, skipUserInfo, extraTokenParams: this.settings.extraTokenParams });\n    logger2.debug(\"got signin response\");\n    const user = await this._buildUser(signinResponse);\n    if (user.profile && user.profile.sub) {\n      logger2.info(\"success, signed in subject\", user.profile.sub);\n    } else {\n      logger2.info(\"no subject\");\n    }\n    return user;\n  }\n  /**\n   * Returns promise to trigger a request (via a popup window) to the authorization endpoint. The result of the promise is the authenticated `User`.\n   */\n  async signinPopup(args = {}) {\n    const logger2 = this._logger.create(\"signinPopup\");\n    const {\n      popupWindowFeatures,\n      popupWindowTarget,\n      ...requestArgs\n    } = args;\n    const url = this.settings.popup_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No popup_redirect_uri configured\"));\n    }\n    const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget });\n    const user = await this._signin({\n      request_type: \"si:p\",\n      redirect_uri: url,\n      display: \"popup\",\n      ...requestArgs\n    }, handle);\n    if (user) {\n      if (user.profile && user.profile.sub) {\n        logger2.info(\"success, signed in subject\", user.profile.sub);\n      } else {\n        logger2.info(\"no subject\");\n      }\n    }\n    return user;\n  }\n  /**\n   * Returns promise to notify the opening window of response from the authorization endpoint.\n   */\n  async signinPopupCallback(url = window.location.href, keepOpen = false) {\n    const logger2 = this._logger.create(\"signinPopupCallback\");\n    await this._popupNavigator.callback(url, { keepOpen });\n    logger2.info(\"success\");\n  }\n  /**\n   * Returns promise to trigger a silent request (via an iframe) to the authorization endpoint.\n   * The result of the promise is the authenticated `User`.\n   */\n  async signinSilent(args = {}) {\n    var _a;\n    const logger2 = this._logger.create(\"signinSilent\");\n    const {\n      silentRequestTimeoutInSeconds,\n      resource,\n      ...requestArgs\n    } = args;\n    let user = await this._loadUser();\n    if (user == null ? void 0 : user.refresh_token) {\n      logger2.debug(\"using refresh token\");\n      const state = new RefreshState(user, resource);\n      return await this._useRefreshToken(state);\n    }\n    const url = this.settings.silent_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No silent_redirect_uri configured\"));\n    }\n    let verifySub;\n    if (user && this.settings.validateSubOnSilentRenew) {\n      logger2.debug(\"subject prior to silent renew:\", user.profile.sub);\n      verifySub = user.profile.sub;\n    }\n    const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n    user = await this._signin({\n      request_type: \"si:s\",\n      redirect_uri: url,\n      prompt: \"none\",\n      id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,\n      ...requestArgs\n    }, handle, verifySub);\n    if (user) {\n      if ((_a = user.profile) == null ? void 0 : _a.sub) {\n        logger2.info(\"success, signed in subject\", user.profile.sub);\n      } else {\n        logger2.info(\"no subject\");\n      }\n    }\n    return user;\n  }\n  async _useRefreshToken(state) {\n    const response = await this._client.useRefreshToken({\n      state,\n      timeoutInSeconds: this.settings.silentRequestTimeoutInSeconds\n    });\n    const user = new User({ ...state, ...response });\n    await this.storeUser(user);\n    this._events.load(user);\n    return user;\n  }\n  /**\n   * Returns promise to notify the parent window of response from the authorization endpoint.\n   */\n  async signinSilentCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signinSilentCallback\");\n    await this._iframeNavigator.callback(url);\n    logger2.info(\"success\");\n  }\n  async signinCallback(url = window.location.href) {\n    const { state } = await this._client.readSigninResponseState(url);\n    switch (state.request_type) {\n      case \"si:r\":\n        return await this.signinRedirectCallback(url);\n      case \"si:p\":\n        return await this.signinPopupCallback(url);\n      case \"si:s\":\n        return await this.signinSilentCallback(url);\n      default:\n        throw new Error(\"invalid response_type in state\");\n    }\n  }\n  async signoutCallback(url = window.location.href, keepOpen = false) {\n    const { state } = await this._client.readSignoutResponseState(url);\n    if (!state) {\n      return void 0;\n    }\n    switch (state.request_type) {\n      case \"so:r\":\n        return await this.signoutRedirectCallback(url);\n      case \"so:p\":\n        await this.signoutPopupCallback(url, keepOpen);\n        break;\n      case \"so:s\":\n        await this.signoutSilentCallback(url);\n        break;\n      default:\n        throw new Error(\"invalid response_type in state\");\n    }\n    return void 0;\n  }\n  /**\n   * Returns promise to query OP for user's current signin status. Returns object with session_state and subject identifier.\n   */\n  async querySessionStatus(args = {}) {\n    const logger2 = this._logger.create(\"querySessionStatus\");\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    const url = this.settings.silent_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No silent_redirect_uri configured\"));\n    }\n    const user = await this._loadUser();\n    const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n    const navResponse = await this._signinStart({\n      request_type: \"si:s\",\n      // this acts like a signin silent\n      redirect_uri: url,\n      prompt: \"none\",\n      id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,\n      response_type: this.settings.query_status_response_type,\n      scope: \"openid\",\n      skipUserInfo: true,\n      ...requestArgs\n    }, handle);\n    try {\n      const signinResponse = await this._client.processSigninResponse(navResponse.url);\n      logger2.debug(\"got signin response\");\n      if (signinResponse.session_state && signinResponse.profile.sub) {\n        logger2.info(\"success for subject\", signinResponse.profile.sub);\n        return {\n          session_state: signinResponse.session_state,\n          sub: signinResponse.profile.sub,\n          sid: signinResponse.profile.sid\n        };\n      }\n      logger2.info(\"success, user not authenticated\");\n      return null;\n    } catch (err) {\n      if (this.settings.monitorAnonymousSession && err instanceof ErrorResponse) {\n        switch (err.error) {\n          case \"login_required\":\n          case \"consent_required\":\n          case \"interaction_required\":\n          case \"account_selection_required\":\n            logger2.info(\"success for anonymous user\");\n            return {\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              session_state: err.session_state\n            };\n        }\n      }\n      throw err;\n    }\n  }\n  async _signin(args, handle, verifySub) {\n    const navResponse = await this._signinStart(args, handle);\n    return await this._signinEnd(navResponse.url, verifySub);\n  }\n  async _signinStart(args, handle) {\n    const logger2 = this._logger.create(\"_signinStart\");\n    try {\n      const signinRequest = await this._client.createSigninRequest(args);\n      logger2.debug(\"got signin request\");\n      return await handle.navigate({\n        url: signinRequest.url,\n        state: signinRequest.state.id,\n        response_mode: signinRequest.state.response_mode,\n        scriptOrigin: this.settings.iframeScriptOrigin\n      });\n    } catch (err) {\n      logger2.debug(\"error after preparing navigator, closing navigator window\");\n      handle.close();\n      throw err;\n    }\n  }\n  async _signinEnd(url, verifySub) {\n    const logger2 = this._logger.create(\"_signinEnd\");\n    const signinResponse = await this._client.processSigninResponse(url);\n    logger2.debug(\"got signin response\");\n    const user = await this._buildUser(signinResponse, verifySub);\n    return user;\n  }\n  async _buildUser(signinResponse, verifySub) {\n    const logger2 = this._logger.create(\"_buildUser\");\n    const user = new User(signinResponse);\n    if (verifySub) {\n      if (verifySub !== user.profile.sub) {\n        logger2.debug(\"current user does not match user returned from signin. sub from signin:\", user.profile.sub);\n        throw new ErrorResponse({ ...signinResponse, error: \"login_required\" });\n      }\n      logger2.debug(\"current user matches user returned from signin\");\n    }\n    await this.storeUser(user);\n    logger2.debug(\"user stored\");\n    this._events.load(user);\n    return user;\n  }\n  /**\n   * Returns promise to trigger a redirect of the current window to the end session endpoint.\n   */\n  async signoutRedirect(args = {}) {\n    const logger2 = this._logger.create(\"signoutRedirect\");\n    const {\n      redirectMethod,\n      ...requestArgs\n    } = args;\n    const handle = await this._redirectNavigator.prepare({ redirectMethod });\n    await this._signoutStart({\n      request_type: \"so:r\",\n      post_logout_redirect_uri: this.settings.post_logout_redirect_uri,\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Returns promise to process response from the end session endpoint.\n   */\n  async signoutRedirectCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signoutRedirectCallback\");\n    const response = await this._signoutEnd(url);\n    logger2.info(\"success\");\n    return response;\n  }\n  /**\n   * Returns promise to trigger a redirect of a popup window window to the end session endpoint.\n   */\n  async signoutPopup(args = {}) {\n    const logger2 = this._logger.create(\"signoutPopup\");\n    const {\n      popupWindowFeatures,\n      popupWindowTarget,\n      ...requestArgs\n    } = args;\n    const url = this.settings.popup_post_logout_redirect_uri;\n    const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget });\n    await this._signout({\n      request_type: \"so:p\",\n      post_logout_redirect_uri: url,\n      // we're putting a dummy entry in here because we\n      // need a unique id from the state for notification\n      // to the parent window, which is necessary if we\n      // plan to return back to the client after signout\n      // and so we can close the popup after signout\n      state: url == null ? void 0 : {},\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Returns promise to process response from the end session endpoint from a popup window.\n   */\n  async signoutPopupCallback(url = window.location.href, keepOpen = false) {\n    const logger2 = this._logger.create(\"signoutPopupCallback\");\n    await this._popupNavigator.callback(url, { keepOpen });\n    logger2.info(\"success\");\n  }\n  async _signout(args, handle) {\n    const navResponse = await this._signoutStart(args, handle);\n    return await this._signoutEnd(navResponse.url);\n  }\n  async _signoutStart(args = {}, handle) {\n    var _a;\n    const logger2 = this._logger.create(\"_signoutStart\");\n    try {\n      const user = await this._loadUser();\n      logger2.debug(\"loaded current user from storage\");\n      if (this.settings.revokeTokensOnSignout) {\n        await this._revokeInternal(user);\n      }\n      const id_token = args.id_token_hint || user && user.id_token;\n      if (id_token) {\n        logger2.debug(\"setting id_token_hint in signout request\");\n        args.id_token_hint = id_token;\n      }\n      await this.removeUser();\n      logger2.debug(\"user removed, creating signout request\");\n      const signoutRequest = await this._client.createSignoutRequest(args);\n      logger2.debug(\"got signout request\");\n      return await handle.navigate({\n        url: signoutRequest.url,\n        state: (_a = signoutRequest.state) == null ? void 0 : _a.id,\n        scriptOrigin: this.settings.iframeScriptOrigin\n      });\n    } catch (err) {\n      logger2.debug(\"error after preparing navigator, closing navigator window\");\n      handle.close();\n      throw err;\n    }\n  }\n  async _signoutEnd(url) {\n    const logger2 = this._logger.create(\"_signoutEnd\");\n    const signoutResponse = await this._client.processSignoutResponse(url);\n    logger2.debug(\"got signout response\");\n    return signoutResponse;\n  }\n  /**\n   * Returns promise to trigger a silent request (via an iframe) to the end session endpoint.\n   */\n  async signoutSilent(args = {}) {\n    var _a;\n    const logger2 = this._logger.create(\"signoutSilent\");\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    const id_token_hint = this.settings.includeIdTokenInSilentSignout ? (_a = await this._loadUser()) == null ? void 0 : _a.id_token : void 0;\n    const url = this.settings.popup_post_logout_redirect_uri;\n    const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n    await this._signout({\n      request_type: \"so:s\",\n      post_logout_redirect_uri: url,\n      id_token_hint,\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Returns promise to notify the parent window of response from the end session endpoint.\n   */\n  async signoutSilentCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signoutSilentCallback\");\n    await this._iframeNavigator.callback(url);\n    logger2.info(\"success\");\n  }\n  async revokeTokens(types) {\n    const user = await this._loadUser();\n    await this._revokeInternal(user, types);\n  }\n  async _revokeInternal(user, types = this.settings.revokeTokenTypes) {\n    const logger2 = this._logger.create(\"_revokeInternal\");\n    if (!user)\n      return;\n    const typesPresent = types.filter((type) => typeof user[type] === \"string\");\n    if (!typesPresent.length) {\n      logger2.debug(\"no need to revoke due to no token(s)\");\n      return;\n    }\n    for (const type of typesPresent) {\n      await this._client.revokeToken(\n        user[type],\n        // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        type\n      );\n      logger2.info(`${type} revoked successfully`);\n      if (type !== \"access_token\") {\n        user[type] = null;\n      }\n    }\n    await this.storeUser(user);\n    logger2.debug(\"user stored\");\n    this._events.load(user);\n  }\n  /**\n   * Enables silent renew for the `UserManager`.\n   */\n  startSilentRenew() {\n    this._logger.create(\"startSilentRenew\");\n    void this._silentRenewService.start();\n  }\n  /**\n   * Disables silent renew for the `UserManager`.\n   */\n  stopSilentRenew() {\n    this._silentRenewService.stop();\n  }\n  get _userStoreKey() {\n    return `user:${this.settings.authority}:${this.settings.client_id}`;\n  }\n  async _loadUser() {\n    const logger2 = this._logger.create(\"_loadUser\");\n    const storageString = await this.settings.userStore.get(this._userStoreKey);\n    if (storageString) {\n      logger2.debug(\"user storageString loaded\");\n      return User.fromStorageString(storageString);\n    }\n    logger2.debug(\"no user storageString\");\n    return null;\n  }\n  async storeUser(user) {\n    const logger2 = this._logger.create(\"storeUser\");\n    if (user) {\n      logger2.debug(\"storing user\");\n      const storageString = user.toStorageString();\n      await this.settings.userStore.set(this._userStoreKey, storageString);\n    } else {\n      this._logger.debug(\"removing user\");\n      await this.settings.userStore.remove(this._userStoreKey);\n    }\n  }\n  /**\n   * Removes stale state entries in storage for incomplete authorize requests.\n   */\n  async clearStaleState() {\n    await this._client.clearStaleState();\n  }\n};\n\n// package.json\nvar version = \"2.4.1\";\n\n// src/Version.ts\nvar Version = version;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  AccessTokenEvents,\n  CheckSessionIFrame,\n  ErrorResponse,\n  ErrorTimeout,\n  InMemoryWebStorage,\n  Log,\n  Logger,\n  MetadataService,\n  OidcClient,\n  OidcClientSettingsStore,\n  SessionMonitor,\n  SigninResponse,\n  SigninState,\n  SignoutResponse,\n  State,\n  User,\n  UserManager,\n  UserManagerSettingsStore,\n  Version,\n  WebStorageStateStore\n});\n//# sourceMappingURL=oidc-client-ts.js.map\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nexport { ErrorResponse, ErrorTimeout } from \"./errors\";\nexport type { INavigator, IFrameWindowParams, IWindow, NavigateParams, NavigateResponse, PopupWindowParams, RedirectParams } from \"./navigators\";\nexport { Log, Logger } from \"./utils\";\nexport type { ILogger, PopupWindowFeatures } from \"./utils\";\nexport type { OidcAddressClaim, OidcStandardClaims, IdTokenClaims, JwtClaims } from \"./Claims\";\n\nexport { AccessTokenEvents } from \"./AccessTokenEvents\";\nexport type { AccessTokenCallback } from \"./AccessTokenEvents\";\nexport { CheckSessionIFrame } from \"./CheckSessionIFrame\";\nexport { InMemoryWebStorage } from \"./InMemoryWebStorage\";\nexport type { AsyncStorage } from \"./AsyncStorage\";\nexport { MetadataService } from \"./MetadataService\";\nexport * from \"./OidcClient\";\nexport { OidcClientSettingsStore } from \"./OidcClientSettings\";\nexport type { OidcClientSettings, SigningKey, ExtraHeader } from \"./OidcClientSettings\";\nexport type { OidcMetadata } from \"./OidcMetadata\";\nexport { SessionMonitor } from \"./SessionMonitor\";\nexport type { SessionStatus } from \"./SessionStatus\";\nexport type { SigninRequest, SigninRequestArgs } from \"./SigninRequest\";\nexport type { RefreshState } from \"./RefreshState\";\nexport { SigninResponse } from \"./SigninResponse\";\nexport { SigninState } from \"./SigninState\";\nexport type { SignoutRequest, SignoutRequestArgs } from \"./SignoutRequest\";\nexport { SignoutResponse } from \"./SignoutResponse\";\nexport { State } from \"./State\";\nexport type { StateStore } from \"./StateStore\";\nexport { User } from \"./User\";\nexport type { UserProfile } from \"./User\";\nexport * from \"./UserManager\";\nexport type {\n    UserManagerEvents,\n    SilentRenewErrorCallback,\n    UserLoadedCallback,\n    UserSessionChangedCallback,\n    UserSignedInCallback,\n    UserSignedOutCallback,\n    UserUnloadedCallback,\n} from \"./UserManagerEvents\";\nexport { UserManagerSettingsStore } from \"./UserManagerSettings\";\nexport type { UserManagerSettings } from \"./UserManagerSettings\";\nexport { Version } from \"./Version\";\nexport { WebStorageStateStore } from \"./WebStorageStateStore\";\n","import CryptoJS from \"crypto-js/core.js\";\nimport sha256 from \"crypto-js/sha256.js\";\nimport Base64 from \"crypto-js/enc-base64.js\";\nimport Utf8 from \"crypto-js/enc-utf8.js\";\n\nimport { Logger } from \"./Logger\";\n\nconst UUID_V4_TEMPLATE = \"10000000-1000-4000-8000-100000000000\";\n\n/**\n * @internal\n */\nexport class CryptoUtils {\n    private static _randomWord(): number {\n        return CryptoJS.lib.WordArray.random(1).words[0];\n    }\n\n    /**\n     * Generates RFC4122 version 4 guid\n     */\n    public static generateUUIDv4(): string {\n        const uuid = UUID_V4_TEMPLATE.replace(/[018]/g, c =>\n            (+c ^ CryptoUtils._randomWord() & 15 >> +c / 4).toString(16),\n        );\n        return uuid.replace(/-/g, \"\");\n    }\n\n    /**\n     * PKCE: Generate a code verifier\n     */\n    public static generateCodeVerifier(): string {\n        return CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4();\n    }\n\n    /**\n     * PKCE: Generate a code challenge\n     */\n    public static generateCodeChallenge(code_verifier: string): string {\n        try {\n            const hashed = sha256(code_verifier);\n            return Base64.stringify(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n        }\n        catch (err) {\n            Logger.error(\"CryptoUtils.generateCodeChallenge\", err);\n            throw err;\n        }\n    }\n\n    /**\n     * Generates a base64-encoded string for a basic auth header\n     */\n    public static generateBasicAuth(client_id: string, client_secret: string): string {\n        const basicAuth = Utf8.parse([client_id, client_secret].join(\":\"));\n        return Base64.stringify(basicAuth);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * Native interface\n *\n * @public\n */\nexport interface ILogger {\n    debug(...args: unknown[]): void;\n    info(...args: unknown[]): void;\n    warn(...args: unknown[]): void;\n    error(...args: unknown[]): void;\n}\n\nconst nopLogger: ILogger = {\n    debug: () => undefined,\n    info: () => undefined,\n    warn: () => undefined,\n    error: () => undefined,\n};\n\nlet level: number;\nlet logger: ILogger;\n\n/**\n * Log levels\n *\n * @public\n */\nexport enum Log {\n    NONE,\n    ERROR,\n    WARN,\n    INFO,\n    DEBUG\n}\n\n/**\n * Log manager\n *\n * @public\n */\nexport namespace Log { // eslint-disable-line @typescript-eslint/no-namespace\n    export function reset(): void {\n        level = Log.INFO;\n        logger = nopLogger;\n    }\n\n    export function setLevel(value: Log): void {\n        if (!(Log.NONE <= value && value <= Log.DEBUG)) {\n            throw new Error(\"Invalid log level\");\n        }\n        level = value;\n    }\n\n    export function setLogger(value: ILogger): void {\n        logger = value;\n    }\n}\n\n/**\n * Internal logger instance\n *\n * @public\n */\nexport class Logger {\n    private _method?: string;\n    public constructor(private _name: string) {}\n\n    /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n    public debug(...args: unknown[]): void {\n        if (level >= Log.DEBUG) {\n            logger.debug(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    public info(...args: unknown[]): void {\n        if (level >= Log.INFO) {\n            logger.info(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    public warn(...args: unknown[]): void {\n        if (level >= Log.WARN) {\n            logger.warn(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    public error(...args: unknown[]): void {\n        if (level >= Log.ERROR) {\n            logger.error(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n\n    public throw(err: Error): never {\n        this.error(err);\n        throw err;\n    }\n\n    public create(method: string): Logger {\n        const methodLogger: Logger = Object.create(this);\n        methodLogger._method = method;\n        methodLogger.debug(\"begin\");\n        return methodLogger;\n    }\n\n    public static createStatic(name: string, staticMethod: string): Logger {\n        const staticLogger = new Logger(`${name}.${staticMethod}`);\n        staticLogger.debug(\"begin\");\n        return staticLogger;\n    }\n\n    private static _format(name: string, method?: string) {\n        const prefix = `[${name}]`;\n        return method ? `${prefix} ${method}:` : prefix;\n    }\n\n    /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n    // helpers for static class methods\n    public static debug(name: string, ...args: unknown[]): void {\n        if (level >= Log.DEBUG) {\n            logger.debug(Logger._format(name), ...args);\n        }\n    }\n    public static info(name: string, ...args: unknown[]): void {\n        if (level >= Log.INFO) {\n            logger.info(Logger._format(name), ...args);\n        }\n    }\n    public static warn(name: string, ...args: unknown[]): void {\n        if (level >= Log.WARN) {\n            logger.warn(Logger._format(name), ...args);\n        }\n    }\n    public static error(name: string, ...args: unknown[]): void {\n        if (level >= Log.ERROR) {\n            logger.error(Logger._format(name), ...args);\n        }\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n}\n\nLog.reset();\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./Logger\";\n\n/**\n * @internal\n */\nexport type Callback<EventType extends unknown[]> = (...ev: EventType) => (Promise<void> | void);\n\n/**\n * @internal\n */\nexport class Event<EventType extends unknown[]> {\n    protected readonly _logger = new Logger(`Event('${this._name}')`);\n\n    private _callbacks: Array<Callback<EventType>> = [];\n\n    public constructor(protected readonly _name: string) {}\n\n    public addHandler(cb: Callback<EventType>): () => void {\n        this._callbacks.push(cb);\n        return () => this.removeHandler(cb);\n    }\n\n    public removeHandler(cb: Callback<EventType>): void {\n        const idx = this._callbacks.lastIndexOf(cb);\n        if (idx >= 0) {\n            this._callbacks.splice(idx, 1);\n        }\n    }\n\n    public raise(...ev: EventType): void {\n        this._logger.debug(\"raise:\", ...ev);\n        for (const cb of this._callbacks) {\n            void cb(...ev);\n        }\n    }\n}\n","import jwt_decode from \"jwt-decode\";\n\nimport { Logger } from \"./Logger\";\nimport type { JwtClaims } from \"../Claims\";\n\n/**\n * @internal\n */\nexport class JwtUtils {\n    // IMPORTANT: doesn't validate the token\n    public static decode(token: string): JwtClaims {\n        try {\n            return jwt_decode<JwtClaims>(token);\n        }\n        catch (err) {\n            Logger.error(\"JwtUtils.decode\", err);\n            throw err;\n        }\n    }\n}\n","/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/open#window_features\n *\n * @public\n */\nexport interface PopupWindowFeatures {\n    left?: number;\n    top?: number;\n    width?: number;\n    height?: number;\n    menubar?: boolean | string;\n    toolbar?: boolean | string;\n    location?: boolean | string;\n    status?: boolean | string;\n    resizable?: boolean | string;\n    scrollbars?: boolean | string;\n    /** Close popup window after time in seconds, by default it is -1. To enable this feature set value greater than 0 */\n    closePopupWindowAfterInSeconds?: number;\n\n    [k: string]: boolean | string | number | undefined;\n}\n\nexport class PopupUtils {\n    /**\n     * Populates a map of window features with a placement centered in front of\n     * the current window. If no explicit width is given, a default value is\n     * binned into [800, 720, 600, 480, 360] based on the current window's width.\n     */\n    static center({ ...features }: PopupWindowFeatures): PopupWindowFeatures {\n        if (features.width == null)\n            features.width = [800, 720, 600, 480].find(width => width <= window.outerWidth / 1.618) ?? 360;\n        features.left ??= Math.max(0, Math.round(window.screenX + (window.outerWidth - features.width) / 2));\n        if (features.height != null)\n            features.top ??= Math.max(0, Math.round(window.screenY + (window.outerHeight - features.height) / 2));\n        return features;\n    }\n\n    static serialize(features: PopupWindowFeatures): string {\n        return Object.entries(features)\n            .filter(([, value]) => value != null)\n            .map(([key, value]) => `${key}=${typeof value !== \"boolean\" ? value as string : value ? \"yes\" : \"no\"}`)\n            .join(\",\");\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Event } from \"./Event\";\nimport { Logger } from \"./Logger\";\n\n/**\n * @internal\n */\nexport class Timer extends Event<[void]> {\n    protected readonly _logger = new Logger(`Timer('${this._name}')`);\n    private _timerHandle: ReturnType<typeof setInterval> | null = null;\n    private _expiration = 0;\n\n    // get the time\n    public static getEpochTime(): number {\n        return Math.floor(Date.now() / 1000);\n    }\n\n    public init(durationInSeconds: number): void {\n        const logger = this._logger.create(\"init\");\n        durationInSeconds = Math.max(Math.floor(durationInSeconds), 1);\n        const expiration = Timer.getEpochTime() + durationInSeconds;\n        if (this.expiration === expiration && this._timerHandle) {\n            // no need to reinitialize to same expiration, so bail out\n            logger.debug(\"skipping since already initialized for expiration at\", this.expiration);\n            return;\n        }\n\n        this.cancel();\n\n        logger.debug(\"using duration\", durationInSeconds);\n        this._expiration = expiration;\n\n        // we're using a fairly short timer and then checking the expiration in the\n        // callback to handle scenarios where the browser device sleeps, and then\n        // the timers end up getting delayed.\n        const timerDurationInSeconds = Math.min(durationInSeconds, 5);\n        this._timerHandle = setInterval(this._callback, timerDurationInSeconds * 1000);\n    }\n\n    public get expiration(): number {\n        return this._expiration;\n    }\n\n    public cancel(): void {\n        this._logger.create(\"cancel\");\n        if (this._timerHandle) {\n            clearInterval(this._timerHandle);\n            this._timerHandle = null;\n        }\n    }\n\n    protected _callback = (): void => {\n        const diff = this._expiration - Timer.getEpochTime();\n        this._logger.debug(\"timer completes in\", diff);\n\n        if (this._expiration <= Timer.getEpochTime()) {\n            this.cancel();\n            super.raise();\n        }\n    };\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * @internal\n */\nexport class UrlUtils {\n    public static readParams(url: string, responseMode: \"query\" | \"fragment\" = \"query\"): URLSearchParams {\n        if (!url) throw new TypeError(\"Invalid URL\");\n        // the base URL is irrelevant, it's just here to support relative url arguments\n        const parsedUrl = new URL(url, \"http://127.0.0.1\");\n        const params = parsedUrl[responseMode === \"fragment\" ? \"hash\" : \"search\"];\n        return new URLSearchParams(params.slice(1));\n    }\n}\n\n/**\n * @internal\n */\nexport const URL_STATE_DELIMITER = \";\";","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\n\n/**\n * Error class thrown in case of an authentication error.\n *\n * See https://openid.net/specs/openid-connect-core-1_0.html#AuthError\n *\n * @public\n */\nexport class ErrorResponse extends Error {\n    /** Marker to detect class: \"ErrorResponse\" */\n    public readonly name: string = \"ErrorResponse\";\n\n    /** An error code string that can be used to classify the types of errors that occur and to respond to errors. */\n    public readonly error: string | null;\n    /** additional information that can help a developer identify the cause of the error.*/\n    public readonly error_description: string | null;\n    /**\n     * URI identifying a human-readable web page with information about the error, used to provide the client\n       developer with additional information about the error.\n    */\n    public readonly error_uri: string | null;\n\n    /** custom state data set during the initial signin request */\n    public state?: unknown;\n\n    public readonly session_state: string | null;\n\n    public url_state?: string;\n\n    public constructor(\n        args: {\n            error?: string | null; error_description?: string | null; error_uri?: string | null;\n            userState?: unknown; session_state?: string | null; url_state?: string;\n        },\n        /** The x-www-form-urlencoded request body sent to the authority server */\n        public readonly form?: URLSearchParams,\n    ) {\n        super(args.error_description || args.error || \"\");\n\n        if (!args.error) {\n            Logger.error(\"ErrorResponse\", \"No error passed\");\n            throw new Error(\"No error passed\");\n        }\n\n        this.error = args.error;\n        this.error_description = args.error_description ?? null;\n        this.error_uri = args.error_uri ?? null;\n\n        this.state = args.userState;\n        this.session_state = args.session_state ?? null;\n        this.url_state = args.url_state;\n    }\n}\n","// Copyright (C) 2021 AuthTS Contributors\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * Error class thrown in case of network timeouts (e.g IFrame time out).\n *\n * @public\n */\nexport class ErrorTimeout extends Error {\n    /** Marker to detect class: \"ErrorTimeout\" */\n    public readonly name: string = \"ErrorTimeout\";\n\n    public constructor(message?: string) {\n        super(message);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Timer } from \"./utils\";\nimport type { User } from \"./User\";\n\n/**\n * @public\n */\nexport type AccessTokenCallback = (...ev: unknown[]) => (Promise<void> | void);\n\n/**\n * @public\n */\nexport class AccessTokenEvents {\n    protected readonly _logger = new Logger(\"AccessTokenEvents\");\n\n    private readonly _expiringTimer = new Timer(\"Access token expiring\");\n    private readonly _expiredTimer = new Timer(\"Access token expired\");\n    private readonly _expiringNotificationTimeInSeconds: number;\n\n    public constructor(args: { expiringNotificationTimeInSeconds: number }) {\n        this._expiringNotificationTimeInSeconds = args.expiringNotificationTimeInSeconds;\n    }\n\n    public load(container: User): void {\n        const logger = this._logger.create(\"load\");\n        // only register events if there's an access token and it has an expiration\n        if (container.access_token && container.expires_in !== undefined) {\n            const duration = container.expires_in;\n            logger.debug(\"access token present, remaining duration:\", duration);\n\n            if (duration > 0) {\n                // only register expiring if we still have time\n                let expiring = duration - this._expiringNotificationTimeInSeconds;\n                if (expiring <= 0) {\n                    expiring = 1;\n                }\n\n                logger.debug(\"registering expiring timer, raising in\", expiring, \"seconds\");\n                this._expiringTimer.init(expiring);\n            }\n            else {\n                logger.debug(\"canceling existing expiring timer because we're past expiration.\");\n                this._expiringTimer.cancel();\n            }\n\n            // if it's negative, it will still fire\n            const expired = duration + 1;\n            logger.debug(\"registering expired timer, raising in\", expired, \"seconds\");\n            this._expiredTimer.init(expired);\n        }\n        else {\n            this._expiringTimer.cancel();\n            this._expiredTimer.cancel();\n        }\n    }\n\n    public unload(): void {\n        this._logger.debug(\"unload: canceling existing access token timers\");\n        this._expiringTimer.cancel();\n        this._expiredTimer.cancel();\n    }\n\n    /**\n     * Add callback: Raised prior to the access token expiring.\n     */\n    public addAccessTokenExpiring(cb: AccessTokenCallback): () => void {\n        return this._expiringTimer.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised prior to the access token expiring.\n     */\n    public removeAccessTokenExpiring(cb: AccessTokenCallback): void {\n        this._expiringTimer.removeHandler(cb);\n    }\n\n    /**\n     * Add callback: Raised after the access token has expired.\n     */\n    public addAccessTokenExpired(cb: AccessTokenCallback): () => void {\n        return this._expiredTimer.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised after the access token has expired.\n     */\n    public removeAccessTokenExpired(cb: AccessTokenCallback): void {\n        this._expiredTimer.removeHandler(cb);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\n\n/**\n * @internal\n */\nexport class CheckSessionIFrame {\n    private readonly _logger = new Logger(\"CheckSessionIFrame\");\n    private _frame_origin: string;\n    private _frame: HTMLIFrameElement;\n    private _timer: ReturnType<typeof setInterval> | null = null;\n    private _session_state: string | null = null;\n\n    public constructor(\n        private _callback: () => Promise<void>,\n        private _client_id: string,\n        url: string,\n        private _intervalInSeconds: number,\n        private _stopOnError: boolean,\n    ) {\n        const parsedUrl = new URL(url);\n        this._frame_origin = parsedUrl.origin;\n\n        this._frame = window.document.createElement(\"iframe\");\n\n        // shotgun approach\n        this._frame.style.visibility = \"hidden\";\n        this._frame.style.position = \"fixed\";\n        this._frame.style.left = \"-1000px\";\n        this._frame.style.top = \"0\";\n        this._frame.width = \"0\";\n        this._frame.height = \"0\";\n        this._frame.src = parsedUrl.href;\n    }\n\n    public load(): Promise<void> {\n        return new Promise<void>((resolve) => {\n            this._frame.onload = () => {\n                resolve();\n            };\n\n            window.document.body.appendChild(this._frame);\n            window.addEventListener(\"message\", this._message, false);\n        });\n    }\n\n    private _message = (e: MessageEvent<string>): void => {\n        if (e.origin === this._frame_origin &&\n            e.source === this._frame.contentWindow\n        ) {\n            if (e.data === \"error\") {\n                this._logger.error(\"error message from check session op iframe\");\n                if (this._stopOnError) {\n                    this.stop();\n                }\n            }\n            else if (e.data === \"changed\") {\n                this._logger.debug(\"changed message from check session op iframe\");\n                this.stop();\n                void this._callback();\n            }\n            else {\n                this._logger.debug(e.data + \" message from check session op iframe\");\n            }\n        }\n    };\n\n    public start(session_state: string): void {\n        if (this._session_state === session_state) {\n            return;\n        }\n\n        this._logger.create(\"start\");\n\n        this.stop();\n\n        this._session_state = session_state;\n\n        const send = () => {\n            if (!this._frame.contentWindow || !this._session_state) {\n                return;\n            }\n\n            this._frame.contentWindow.postMessage(this._client_id + \" \" + this._session_state, this._frame_origin);\n        };\n\n        // trigger now\n        send();\n\n        // and setup timer\n        this._timer = setInterval(send, this._intervalInSeconds * 1000);\n    }\n\n    public stop(): void {\n        this._logger.create(\"stop\");\n        this._session_state = null;\n\n        if (this._timer) {\n\n            clearInterval(this._timer);\n            this._timer = null;\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\n\n/**\n * @public\n */\nexport class InMemoryWebStorage implements Storage {\n    private readonly _logger = new Logger(\"InMemoryWebStorage\");\n    private _data: Record<string, string> = {};\n\n    public clear(): void {\n        this._logger.create(\"clear\");\n        this._data = {};\n    }\n\n    public getItem(key: string): string {\n        this._logger.create(`getItem('${key}')`);\n        return this._data[key];\n    }\n\n    public setItem(key: string, value: string): void {\n        this._logger.create(`setItem('${key}')`);\n        this._data[key] = value;\n    }\n\n    public removeItem(key: string): void {\n        this._logger.create(`removeItem('${key}')`);\n        delete this._data[key];\n    }\n\n    public get length(): number {\n        return Object.getOwnPropertyNames(this._data).length;\n    }\n\n    public key(index: number): string {\n        return Object.getOwnPropertyNames(this._data)[index];\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { ErrorResponse, ErrorTimeout } from \"./errors\";\nimport type { ExtraHeader } from \"./OidcClientSettings\";\nimport { Logger } from \"./utils\";\n\n/**\n * @internal\n */\nexport type JwtHandler = (text: string) => Promise<Record<string, unknown>>;\n\n/**\n * @internal\n */\nexport interface GetJsonOpts {\n    token?: string;\n    credentials?: RequestCredentials;\n}\n\n/**\n * @internal\n */\nexport interface PostFormOpts {\n    body: URLSearchParams;\n    basicAuth?: string;\n    timeoutInSeconds?: number;\n    initCredentials?: \"same-origin\" | \"include\" | \"omit\";\n}\n\n/**\n * @internal\n */\nexport class JsonService {\n    private readonly _logger = new Logger(\"JsonService\");\n\n    private _contentTypes: string[] = [];\n\n    public constructor(\n        additionalContentTypes: string[] = [],\n        private _jwtHandler: JwtHandler | null = null,\n        private _extraHeaders: Record<string, ExtraHeader> = {},\n    ) {\n        this._contentTypes.push(...additionalContentTypes, \"application/json\");\n        if (_jwtHandler) {\n            this._contentTypes.push(\"application/jwt\");\n        }\n    }\n\n    protected async fetchWithTimeout(input: RequestInfo, init: RequestInit & { timeoutInSeconds?: number } = {}) {\n        const { timeoutInSeconds, ...initFetch } = init;\n        if (!timeoutInSeconds) {\n            return await fetch(input, initFetch);\n        }\n\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), timeoutInSeconds * 1000);\n\n        try {\n            const response = await fetch(input, {\n                ...init,\n                signal: controller.signal,\n            });\n            return response;\n        }\n        catch (err) {\n            if (err instanceof DOMException && err.name === \"AbortError\") {\n                throw new ErrorTimeout(\"Network timed out\");\n            }\n            throw err;\n        }\n        finally {\n            clearTimeout(timeoutId);\n        }\n    }\n\n    public async getJson(url: string, {\n        token,\n        credentials,\n    }: GetJsonOpts = {}): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"getJson\");\n        const headers: HeadersInit = {\n            \"Accept\": this._contentTypes.join(\", \"),\n        };\n        if (token) {\n            logger.debug(\"token passed, setting Authorization header\");\n            headers[\"Authorization\"] = \"Bearer \" + token;\n        }\n\n        this.appendExtraHeaders(headers);\n\n        let response: Response;\n        try {\n            logger.debug(\"url:\", url);\n            response = await this.fetchWithTimeout(url, { method: \"GET\", headers, credentials });\n        }\n        catch (err) {\n            logger.error(\"Network Error\");\n            throw err;\n        }\n\n        logger.debug(\"HTTP response received, status\", response.status);\n        const contentType = response.headers.get(\"Content-Type\");\n        if (contentType && !this._contentTypes.find(item => contentType.startsWith(item))) {\n            logger.throw(new Error(`Invalid response Content-Type: ${(contentType ?? \"undefined\")}, from URL: ${url}`));\n        }\n        if (response.ok && this._jwtHandler && contentType?.startsWith(\"application/jwt\")) {\n            return await this._jwtHandler(await response.text());\n        }\n        let json: Record<string, unknown>;\n        try {\n            json = await response.json();\n        }\n        catch (err) {\n            logger.error(\"Error parsing JSON response\", err);\n            if (response.ok) throw err;\n            throw new Error(`${response.statusText} (${response.status})`);\n        }\n        if (!response.ok) {\n            logger.error(\"Error from server:\", json);\n            if (json.error) {\n                throw new ErrorResponse(json);\n            }\n            throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n        }\n        return json;\n    }\n\n    public async postForm(url: string, {\n        body,\n        basicAuth,\n        timeoutInSeconds,\n        initCredentials,\n    }: PostFormOpts): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"postForm\");\n        const headers: HeadersInit = {\n            \"Accept\": this._contentTypes.join(\", \"),\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n        };\n        if (basicAuth !== undefined) {\n            headers[\"Authorization\"] = \"Basic \" + basicAuth;\n        }\n\n        this.appendExtraHeaders(headers);\n\n        let response: Response;\n        try {\n            logger.debug(\"url:\", url);\n            response = await this.fetchWithTimeout(url, { method: \"POST\", headers, body, timeoutInSeconds, credentials: initCredentials });\n        }\n        catch (err) {\n            logger.error(\"Network error\");\n            throw err;\n        }\n\n        logger.debug(\"HTTP response received, status\", response.status);\n        const contentType = response.headers.get(\"Content-Type\");\n        if (contentType && !this._contentTypes.find(item => contentType.startsWith(item))) {\n            throw new Error(`Invalid response Content-Type: ${(contentType ?? \"undefined\")}, from URL: ${url}`);\n        }\n\n        const responseText = await response.text();\n\n        let json: Record<string, unknown> = {};\n        if (responseText) {\n            try {\n                json = JSON.parse(responseText);\n            }\n            catch (err) {\n                logger.error(\"Error parsing JSON response\", err);\n                if (response.ok) throw err;\n                throw new Error(`${response.statusText} (${response.status})`);\n            }\n        }\n\n        if (!response.ok) {\n            logger.error(\"Error from server:\", json);\n            if (json.error) {\n                throw new ErrorResponse(json, body);\n            }\n            throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n        }\n\n        return json;\n    }\n\n    private appendExtraHeaders(\n        headers: Record<string, string>,\n    ): void {\n        const logger = this._logger.create(\"appendExtraHeaders\");\n        const customKeys = Object.keys(this._extraHeaders);\n        const protectedHeaders = [\n            \"authorization\",\n            \"accept\",\n            \"content-type\",\n        ];\n        if (customKeys.length === 0) {\n            return;\n        }\n        customKeys.forEach((headerName) => {\n            if (protectedHeaders.includes(headerName.toLocaleLowerCase())) {\n                logger.warn(\"Protected header could not be overridden\", headerName, protectedHeaders);\n                return;\n            }\n            const content = (typeof this._extraHeaders[headerName] === \"function\") ?\n                (this._extraHeaders[headerName] as ()=>string)() :\n                this._extraHeaders[headerName];\n            if (content && content !== \"\") {\n                headers[headerName] = content as string;\n            }\n        });\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { JsonService } from \"./JsonService\";\nimport type { OidcClientSettingsStore, SigningKey } from \"./OidcClientSettings\";\nimport type { OidcMetadata } from \"./OidcMetadata\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata\n */\nexport class MetadataService {\n    private readonly _logger = new Logger(\"MetadataService\");\n    private readonly _jsonService;\n\n    // cache\n    private _metadataUrl: string;\n    private _signingKeys: SigningKey[] | null = null;\n    private _metadata: Partial<OidcMetadata> | null = null;\n    private _fetchRequestCredentials: RequestCredentials | undefined;\n\n    public constructor(private readonly _settings: OidcClientSettingsStore) {\n        this._metadataUrl = this._settings.metadataUrl;\n        this._jsonService = new JsonService(\n            [\"application/jwk-set+json\"],\n            null,\n            this._settings.extraHeaders,\n        );\n        if (this._settings.signingKeys) {\n            this._logger.debug(\"using signingKeys from settings\");\n            this._signingKeys = this._settings.signingKeys;\n        }\n\n        if (this._settings.metadata) {\n            this._logger.debug(\"using metadata from settings\");\n            this._metadata = this._settings.metadata;\n        }\n\n        if (this._settings.fetchRequestCredentials) {\n            this._logger.debug(\"using fetchRequestCredentials from settings\");\n            this._fetchRequestCredentials = this._settings.fetchRequestCredentials;\n        }\n    }\n\n    public resetSigningKeys(): void {\n        this._signingKeys = null;\n    }\n\n    public async getMetadata(): Promise<Partial<OidcMetadata>> {\n        const logger = this._logger.create(\"getMetadata\");\n        if (this._metadata) {\n            logger.debug(\"using cached values\");\n            return this._metadata;\n        }\n\n        if (!this._metadataUrl) {\n            logger.throw(new Error(\"No authority or metadataUrl configured on settings\"));\n            throw null;\n        }\n\n        logger.debug(\"getting metadata from\", this._metadataUrl);\n        const metadata = await this._jsonService.getJson(this._metadataUrl, { credentials: this._fetchRequestCredentials });\n\n        logger.debug(\"merging remote JSON with seed metadata\");\n        this._metadata = Object.assign({}, this._settings.metadataSeed, metadata);\n        return this._metadata;\n    }\n\n    public getIssuer(): Promise<string> {\n        return this._getMetadataProperty(\"issuer\") as Promise<string>;\n    }\n\n    public getAuthorizationEndpoint(): Promise<string> {\n        return this._getMetadataProperty(\"authorization_endpoint\") as Promise<string>;\n    }\n\n    public getUserInfoEndpoint(): Promise<string> {\n        return this._getMetadataProperty(\"userinfo_endpoint\") as Promise<string>;\n    }\n\n    public getTokenEndpoint(optional: false): Promise<string>;\n    public getTokenEndpoint(optional?: true): Promise<string | undefined>;\n    public getTokenEndpoint(optional = true): Promise<string | undefined> {\n        return this._getMetadataProperty(\"token_endpoint\", optional) as Promise<string | undefined>;\n    }\n\n    public getCheckSessionIframe(): Promise<string | undefined> {\n        return this._getMetadataProperty(\"check_session_iframe\", true) as Promise<string | undefined>;\n    }\n\n    public getEndSessionEndpoint(): Promise<string | undefined> {\n        return this._getMetadataProperty(\"end_session_endpoint\", true) as Promise<string | undefined>;\n    }\n\n    public getRevocationEndpoint(optional: false): Promise<string>;\n    public getRevocationEndpoint(optional?: true): Promise<string | undefined>;\n    public getRevocationEndpoint(optional = true): Promise<string | undefined> {\n        return this._getMetadataProperty(\"revocation_endpoint\", optional) as Promise<string | undefined>;\n    }\n\n    public getKeysEndpoint(optional: false): Promise<string>;\n    public getKeysEndpoint(optional?: true): Promise<string | undefined>;\n    public getKeysEndpoint(optional = true): Promise<string | undefined> {\n        return this._getMetadataProperty(\"jwks_uri\", optional) as Promise<string | undefined>;\n    }\n\n    protected async _getMetadataProperty(name: keyof OidcMetadata, optional=false): Promise<string | boolean | string[] | undefined> {\n        const logger = this._logger.create(`_getMetadataProperty('${name}')`);\n\n        const metadata = await this.getMetadata();\n        logger.debug(\"resolved\");\n\n        if (metadata[name] === undefined) {\n            if (optional === true) {\n                logger.warn(\"Metadata does not contain optional property\");\n                return undefined;\n            }\n\n            logger.throw(new Error(\"Metadata does not contain property \" + name));\n        }\n\n        return metadata[name];\n    }\n\n    public async getSigningKeys(): Promise<SigningKey[] | null> {\n        const logger = this._logger.create(\"getSigningKeys\");\n        if (this._signingKeys) {\n            logger.debug(\"returning signingKeys from cache\");\n            return this._signingKeys;\n        }\n\n        const jwks_uri = await this.getKeysEndpoint(false);\n        logger.debug(\"got jwks_uri\", jwks_uri);\n\n        const keySet = await this._jsonService.getJson(jwks_uri);\n        logger.debug(\"got key set\", keySet);\n\n        if (!Array.isArray(keySet.keys)) {\n            logger.throw(new Error(\"Missing keys on keyset\"));\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        this._signingKeys = keySet.keys;\n        return this._signingKeys;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport type { StateStore } from \"./StateStore\";\nimport type { AsyncStorage } from \"./AsyncStorage\";\n\n/**\n * @public\n */\nexport class WebStorageStateStore implements StateStore {\n    private readonly _logger = new Logger(\"WebStorageStateStore\");\n\n    private readonly _store: AsyncStorage | Storage;\n    private readonly _prefix: string;\n\n    public constructor({\n        prefix = \"oidc.\",\n        store = localStorage,\n    }: { prefix?: string; store?: AsyncStorage | Storage } = {}) {\n        this._store = store;\n        this._prefix = prefix;\n    }\n\n    public async set(key: string, value: string): Promise<void> {\n        this._logger.create(`set('${key}')`);\n\n        key = this._prefix + key;\n        await this._store.setItem(key, value);\n    }\n\n    public async get(key: string): Promise<string | null> {\n        this._logger.create(`get('${key}')`);\n\n        key = this._prefix + key;\n        const item = await this._store.getItem(key);\n        return item;\n    }\n\n    public async remove(key: string): Promise<string | null> {\n        this._logger.create(`remove('${key}')`);\n\n        key = this._prefix + key;\n        const item = await this._store.getItem(key);\n        await this._store.removeItem(key);\n        return item;\n    }\n\n    public async getAllKeys(): Promise<string[]> {\n        this._logger.create(\"getAllKeys\");\n        const len = await this._store.length;\n\n        const keys = [];\n        for (let index = 0; index < len; index++) {\n            const key = await this._store.key(index);\n            if (key && key.indexOf(this._prefix) === 0) {\n                keys.push(key.substr(this._prefix.length));\n            }\n        }\n        return keys;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { WebStorageStateStore } from \"./WebStorageStateStore\";\nimport type { OidcMetadata } from \"./OidcMetadata\";\nimport type { StateStore } from \"./StateStore\";\nimport { InMemoryWebStorage } from \"./InMemoryWebStorage\";\n\nconst DefaultResponseType = \"code\";\nconst DefaultScope = \"openid\";\nconst DefaultClientAuthentication = \"client_secret_post\";\nconst DefaultResponseMode = \"query\";\nconst DefaultStaleStateAgeInSeconds = 60 * 15;\nconst DefaultClockSkewInSeconds = 60 * 5;\n\n/**\n * @public\n */\nexport type SigningKey = Record<string, string | string[]>;\n\n/**\n * @public\n */\nexport type ExtraHeader = string | (() => string);\n\n/**\n * The settings used to configure the {@link OidcClient}.\n *\n * @public\n */\nexport interface OidcClientSettings {\n    /** The URL of the OIDC/OAuth2 provider */\n    authority: string;\n    metadataUrl?: string;\n    /** Provide metadata when authority server does not allow CORS on the metadata endpoint */\n    metadata?: Partial<OidcMetadata>;\n    /** Can be used to seed or add additional values to the results of the discovery request */\n    metadataSeed?: Partial<OidcMetadata>;\n    /** Provide signingKeys when authority server does not allow CORS on the jwks uri */\n    signingKeys?: SigningKey[];\n\n    /** Your client application's identifier as registered with the OIDC/OAuth2 */\n    client_id: string;\n    client_secret?: string;\n    /** The type of response desired from the OIDC/OAuth2 provider (default: \"code\") */\n    response_type?: string;\n    /** The scope being requested from the OIDC/OAuth2 provider (default: \"openid\") */\n    scope?: string;\n    /** The redirect URI of your client application to receive a response from the OIDC/OAuth2 provider */\n    redirect_uri: string;\n    /** The OIDC/OAuth2 post-logout redirect URI */\n    post_logout_redirect_uri?: string;\n\n    /**\n     * Client authentication method that is used to authenticate when using the token endpoint (default: \"client_secret_post\")\n     * - \"client_secret_basic\": using the HTTP Basic authentication scheme\n     * - \"client_secret_post\": including the client credentials in the request body\n     *\n     * See https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication\n     */\n    client_authentication?: \"client_secret_basic\" | \"client_secret_post\";\n\n    /** optional protocol param */\n    prompt?: string;\n    /** optional protocol param */\n    display?: string;\n    /** optional protocol param */\n    max_age?: number;\n    /** optional protocol param */\n    ui_locales?: string;\n    /** optional protocol param */\n    acr_values?: string;\n    /** optional protocol param */\n    resource?: string | string[];\n\n    /** optional protocol param (default: \"query\") */\n    response_mode?: \"query\" | \"fragment\";\n\n    /**\n     * Should optional OIDC protocol claims be removed from profile or specify the ones to be removed (default: true)\n     * When true, the following claims are removed by default: [\"nbf\", \"jti\", \"auth_time\", \"nonce\", \"acr\", \"amr\", \"azp\", \"at_hash\"]\n     * When specifying claims, the following claims are not allowed: [\"sub\", \"iss\", \"aud\", \"exp\", \"iat\"]\n    */\n    filterProtocolClaims?: boolean | string[];\n    /** Flag to control if additional identity data is loaded from the user info endpoint in order to populate the user's profile (default: false) */\n    loadUserInfo?: boolean;\n    /** Number (in seconds) indicating the age of state entries in storage for authorize requests that are considered abandoned and thus can be cleaned up (default: 900) */\n    staleStateAgeInSeconds?: number;\n\n    /** @deprecated Unused */\n    clockSkewInSeconds?: number;\n    /** @deprecated Unused */\n    userInfoJwtIssuer?: /*\"ANY\" | \"OP\" |*/ string;\n\n    /**\n     * Indicates if objects returned from the user info endpoint as claims (e.g. `address`) are merged into the claims from the id token as a single object.\n     * Otherwise, they are added to an array as distinct objects for the claim type. (default: false)\n     */\n    mergeClaims?: boolean;\n\n    /**\n     * Storage object used to persist interaction state (default: window.localStorage, InMemoryWebStorage iff no window).\n     * E.g. `stateStore: new WebStorageStateStore({ store: window.localStorage })`\n     */\n    stateStore?: StateStore;\n\n    /**\n     * An object containing additional query string parameters to be including in the authorization request.\n     * E.g, when using Azure AD to obtain an access token an additional resource parameter is required. extraQueryParams: `{resource:\"some_identifier\"}`\n     */\n    extraQueryParams?: Record<string, string | number | boolean>;\n\n    extraTokenParams?: Record<string, unknown>;\n\n    /**\n     * An object containing additional header to be including in request.\n     */\n    extraHeaders?: Record<string, ExtraHeader>;\n\n    /**\n     * @deprecated since version 2.1.0. Use fetchRequestCredentials instead.\n     */\n    refreshTokenCredentials?: \"same-origin\" | \"include\" | \"omit\";\n\n    /**\n     * Will check the content type header of the response of the revocation endpoint to match these passed values (default: [])\n     */\n    revokeTokenAdditionalContentTypes?: string[];\n    /**\n     * Will disable pkce validation, changing to true will not append to sign in request code_challenge and code_challenge_method. (default: false)\n     */\n    disablePKCE?: boolean;\n    /**\n     * Sets the credentials for fetch requests. (default: \"same-origin\")\n     * Use this if you need to send cookies to the OIDC/OAuth2 provider or if you are using a proxy that requires cookies\n     */\n    fetchRequestCredentials?: RequestCredentials;\n\n    /**\n     * Only scopes in this list will be passed in the token refresh request.\n     */\n    refreshTokenAllowedScope?: string | undefined;\n}\n\n/**\n * The settings with defaults applied of the {@link OidcClient}.\n * @see {@link OidcClientSettings}\n *\n * @public\n */\nexport class OidcClientSettingsStore {\n    // metadata\n    public readonly authority: string;\n    public readonly metadataUrl: string;\n    public readonly metadata: Partial<OidcMetadata> | undefined;\n    public readonly metadataSeed: Partial<OidcMetadata> | undefined;\n    public readonly signingKeys: SigningKey[] | undefined;\n\n    // client config\n    public readonly client_id: string;\n    public readonly client_secret: string | undefined;\n    public readonly response_type: string;\n    public readonly scope: string;\n    public readonly redirect_uri: string;\n    public readonly post_logout_redirect_uri: string | undefined;\n    public readonly client_authentication: \"client_secret_basic\" | \"client_secret_post\";\n\n    // optional protocol params\n    public readonly prompt: string | undefined;\n    public readonly display: string | undefined;\n    public readonly max_age: number | undefined;\n    public readonly ui_locales: string | undefined;\n    public readonly acr_values: string | undefined;\n    public readonly resource: string | string[] | undefined;\n    public readonly response_mode: \"query\" | \"fragment\";\n\n    // behavior flags\n    public readonly filterProtocolClaims: boolean | string[];\n    public readonly loadUserInfo: boolean;\n    public readonly staleStateAgeInSeconds: number;\n    public readonly clockSkewInSeconds: number;\n    public readonly userInfoJwtIssuer: /*\"ANY\" | \"OP\" |*/ string;\n    public readonly mergeClaims: boolean;\n\n    public readonly stateStore: StateStore;\n\n    // extra\n    public readonly extraQueryParams: Record<string, string | number | boolean>;\n    public readonly extraTokenParams: Record<string, unknown>;\n    public readonly extraHeaders: Record<string, ExtraHeader>;\n\n    public readonly revokeTokenAdditionalContentTypes?: string[];\n    public readonly fetchRequestCredentials: RequestCredentials;\n    public readonly refreshTokenAllowedScope: string | undefined;\n    public readonly disablePKCE: boolean;\n\n    public constructor({\n        // metadata related\n        authority, metadataUrl, metadata, signingKeys, metadataSeed,\n        // client related\n        client_id, client_secret, response_type = DefaultResponseType, scope = DefaultScope,\n        redirect_uri, post_logout_redirect_uri,\n        client_authentication = DefaultClientAuthentication,\n        // optional protocol\n        prompt, display, max_age, ui_locales, acr_values, resource, response_mode = DefaultResponseMode,\n        // behavior flags\n        filterProtocolClaims = true,\n        loadUserInfo = false,\n        staleStateAgeInSeconds = DefaultStaleStateAgeInSeconds,\n        clockSkewInSeconds = DefaultClockSkewInSeconds,\n        userInfoJwtIssuer = \"OP\",\n        mergeClaims = false,\n        disablePKCE = false,\n        // other behavior\n        stateStore,\n        refreshTokenCredentials,\n        revokeTokenAdditionalContentTypes,\n        fetchRequestCredentials,\n        refreshTokenAllowedScope,\n        // extra\n        extraQueryParams = {},\n        extraTokenParams = {},\n        extraHeaders = {},\n    }: OidcClientSettings) {\n\n        this.authority = authority;\n\n        if (metadataUrl) {\n            this.metadataUrl = metadataUrl;\n        } else {\n            this.metadataUrl = authority;\n            if (authority) {\n                if (!this.metadataUrl.endsWith(\"/\")) {\n                    this.metadataUrl += \"/\";\n                }\n                this.metadataUrl += \".well-known/openid-configuration\";\n            }\n        }\n\n        this.metadata = metadata;\n        this.metadataSeed = metadataSeed;\n        this.signingKeys = signingKeys;\n\n        this.client_id = client_id;\n        this.client_secret = client_secret;\n        this.response_type = response_type;\n        this.scope = scope;\n        this.redirect_uri = redirect_uri;\n        this.post_logout_redirect_uri = post_logout_redirect_uri;\n        this.client_authentication = client_authentication;\n\n        this.prompt = prompt;\n        this.display = display;\n        this.max_age = max_age;\n        this.ui_locales = ui_locales;\n        this.acr_values = acr_values;\n        this.resource = resource;\n        this.response_mode = response_mode;\n\n        this.filterProtocolClaims = filterProtocolClaims ?? true;\n        this.loadUserInfo = !!loadUserInfo;\n        this.staleStateAgeInSeconds = staleStateAgeInSeconds;\n        this.clockSkewInSeconds = clockSkewInSeconds;\n        this.userInfoJwtIssuer = userInfoJwtIssuer;\n        this.mergeClaims = !!mergeClaims;\n        this.disablePKCE = !!disablePKCE;\n        this.revokeTokenAdditionalContentTypes = revokeTokenAdditionalContentTypes;\n\n        if (fetchRequestCredentials && refreshTokenCredentials) {\n            console.warn(\"Both fetchRequestCredentials and refreshTokenCredentials is set. Only fetchRequestCredentials will be used.\");\n        }\n        this.fetchRequestCredentials = fetchRequestCredentials ? fetchRequestCredentials\n            : refreshTokenCredentials ? refreshTokenCredentials : \"same-origin\";\n\n        if (stateStore) {\n            this.stateStore = stateStore;\n        }\n        else {\n            const store = typeof window !== \"undefined\" ? window.localStorage : new InMemoryWebStorage();\n            this.stateStore = new WebStorageStateStore({ store });\n        }\n\n        this.refreshTokenAllowedScope = refreshTokenAllowedScope;\n\n        this.extraQueryParams = extraQueryParams;\n        this.extraTokenParams = extraTokenParams;\n        this.extraHeaders = extraHeaders;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, JwtUtils } from \"./utils\";\nimport { JsonService } from \"./JsonService\";\nimport type { MetadataService } from \"./MetadataService\";\nimport type { JwtClaims } from \"./Claims\";\nimport type { OidcClientSettingsStore } from \"./OidcClientSettings\";\n\n/**\n * @internal\n */\nexport class UserInfoService {\n    protected readonly _logger = new Logger(\"UserInfoService\");\n    private readonly _jsonService: JsonService;\n\n    public constructor(private readonly _settings: OidcClientSettingsStore,\n        private readonly _metadataService: MetadataService,\n    ) {\n        this._jsonService = new JsonService(\n            undefined,\n            this._getClaimsFromJwt,\n            this._settings.extraHeaders,\n        );\n    }\n\n    public async getClaims(token: string): Promise<JwtClaims> {\n        const logger = this._logger.create(\"getClaims\");\n        if (!token) {\n            this._logger.throw(new Error(\"No token passed\"));\n        }\n\n        const url = await this._metadataService.getUserInfoEndpoint();\n        logger.debug(\"got userinfo url\", url);\n\n        const claims = await this._jsonService.getJson(url, {\n            token,\n            credentials: this._settings.fetchRequestCredentials,\n        });\n        logger.debug(\"got claims\", claims);\n\n        return claims;\n    }\n\n    protected _getClaimsFromJwt = async (responseText: string): Promise<JwtClaims> => {\n        const logger = this._logger.create(\"_getClaimsFromJwt\");\n        try {\n            const payload = JwtUtils.decode(responseText);\n            logger.debug(\"JWT decoding successful\");\n\n            return payload;\n        } catch (err) {\n            logger.error(\"Error parsing JWT response\");\n            throw err;\n        }\n    };\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { CryptoUtils, Logger } from \"./utils\";\nimport { JsonService } from \"./JsonService\";\nimport type { MetadataService } from \"./MetadataService\";\nimport type { OidcClientSettingsStore } from \"./OidcClientSettings\";\n\n/**\n * @internal\n */\nexport interface ExchangeCodeArgs {\n    client_id?: string;\n    client_secret?: string;\n    redirect_uri?: string;\n\n    grant_type?: string;\n    code: string;\n    code_verifier?: string;\n}\n\n/**\n * @internal\n */\nexport interface ExchangeCredentialsArgs {\n    client_id?: string;\n    client_secret?: string;\n\n    grant_type?: string;\n    scope?: string;\n\n    username: string;\n    password: string;\n}\n\n/**\n * @internal\n */\nexport interface ExchangeRefreshTokenArgs {\n    client_id?: string;\n    client_secret?: string;\n\n    grant_type?: string;\n    refresh_token: string;\n    scope?: string;\n    resource?: string | string[];\n\n    timeoutInSeconds?: number;\n}\n\n/**\n * @internal\n */\nexport interface RevokeArgs {\n    token: string;\n    token_type_hint?: \"access_token\" | \"refresh_token\";\n}\n\n/**\n * @internal\n */\nexport class TokenClient {\n    private readonly _logger = new Logger(\"TokenClient\");\n    private readonly _jsonService;\n\n    public constructor(\n        private readonly _settings: OidcClientSettingsStore,\n        private readonly _metadataService: MetadataService,\n    ) {\n        this._jsonService = new JsonService(\n            this._settings.revokeTokenAdditionalContentTypes,\n            null,\n            this._settings.extraHeaders,\n        );\n    }\n\n    /**\n     * Exchange code.\n     *\n     * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3\n     */\n    public async exchangeCode({\n        grant_type = \"authorization_code\",\n        redirect_uri = this._settings.redirect_uri,\n        client_id = this._settings.client_id,\n        client_secret = this._settings.client_secret,\n        ...args\n    }: ExchangeCodeArgs): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"exchangeCode\");\n        if (!client_id) {\n            logger.throw(new Error(\"A client_id is required\"));\n        }\n        if (!redirect_uri) {\n            logger.throw(new Error(\"A redirect_uri is required\"));\n        }\n        if (!args.code) {\n            logger.throw(new Error(\"A code is required\"));\n        }\n\n        const params = new URLSearchParams({ grant_type, redirect_uri });\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n        let basicAuth: string | undefined;\n        switch (this._settings.client_authentication) {\n            case \"client_secret_basic\":\n                if (!client_secret) {\n                    logger.throw(new Error(\"A client_secret is required\"));\n                    throw null; // https://github.com/microsoft/TypeScript/issues/46972\n                }\n                basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) {\n                    params.append(\"client_secret\", client_secret);\n                }\n                break;\n        }\n\n        const url = await this._metadataService.getTokenEndpoint(false);\n        logger.debug(\"got token endpoint\");\n\n        const response = await this._jsonService.postForm(url, { body: params, basicAuth, initCredentials: this._settings.fetchRequestCredentials });\n        logger.debug(\"got response\");\n\n        return response;\n    }\n\n    /**\n     * Exchange credentials.\n     *\n     * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.3.2\n     */\n    public async exchangeCredentials({\n        grant_type = \"password\",\n        client_id = this._settings.client_id,\n        client_secret = this._settings.client_secret,\n        scope = this._settings.scope,\n        ...args\n    }: ExchangeCredentialsArgs): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"exchangeCredentials\");\n\n        if (!client_id) {\n            logger.throw(new Error(\"A client_id is required\"));\n        }\n\n        const params = new URLSearchParams({ grant_type, scope });\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n\n        let basicAuth: string | undefined;\n        switch (this._settings.client_authentication) {\n            case \"client_secret_basic\":\n                if (!client_secret) {\n                    logger.throw(new Error(\"A client_secret is required\"));\n                    throw null; // https://github.com/microsoft/TypeScript/issues/46972\n                }\n                basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) {\n                    params.append(\"client_secret\", client_secret);\n                }\n                break;\n        }\n\n        const url = await this._metadataService.getTokenEndpoint(false);\n        logger.debug(\"got token endpoint\");\n\n        const response = await this._jsonService.postForm(url, { body: params, basicAuth, initCredentials: this._settings.fetchRequestCredentials });\n        logger.debug(\"got response\");\n\n        return response;\n    }\n\n    /**\n     * Exchange a refresh token.\n     *\n     * @see https://www.rfc-editor.org/rfc/rfc6749#section-6\n     */\n    public async exchangeRefreshToken({\n        grant_type = \"refresh_token\",\n        client_id = this._settings.client_id,\n        client_secret = this._settings.client_secret,\n        timeoutInSeconds,\n        ...args\n    }: ExchangeRefreshTokenArgs): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"exchangeRefreshToken\");\n        if (!client_id) {\n            logger.throw(new Error(\"A client_id is required\"));\n        }\n        if (!args.refresh_token) {\n            logger.throw(new Error(\"A refresh_token is required\"));\n        }\n\n        const params = new URLSearchParams({ grant_type });\n        for (const [key, value] of Object.entries(args)) {\n            if (Array.isArray(value)) {\n                value.forEach(param => params.append(key, param));\n            }\n            else if (value != null) {\n                params.set(key, value);\n            }\n        }\n        let basicAuth: string | undefined;\n        switch (this._settings.client_authentication) {\n            case \"client_secret_basic\":\n                if (!client_secret) {\n                    logger.throw(new Error(\"A client_secret is required\"));\n                    throw null; // https://github.com/microsoft/TypeScript/issues/46972\n                }\n                basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) {\n                    params.append(\"client_secret\", client_secret);\n                }\n                break;\n        }\n\n        const url = await this._metadataService.getTokenEndpoint(false);\n        logger.debug(\"got token endpoint\");\n\n        const response = await this._jsonService.postForm(url, { body: params, basicAuth, timeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials });\n        logger.debug(\"got response\");\n\n        return response;\n    }\n\n    /**\n     * Revoke an access or refresh token.\n     *\n     * @see https://datatracker.ietf.org/doc/html/rfc7009#section-2.1\n     */\n    public async revoke(args: RevokeArgs): Promise<void> {\n        const logger = this._logger.create(\"revoke\");\n        if (!args.token) {\n            logger.throw(new Error(\"A token is required\"));\n        }\n\n        const url = await this._metadataService.getRevocationEndpoint(false);\n\n        logger.debug(`got revocation endpoint, revoking ${args.token_type_hint ?? \"default token type\"}`);\n\n        const params = new URLSearchParams();\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n        params.set(\"client_id\", this._settings.client_id);\n        if (this._settings.client_secret) {\n            params.set(\"client_secret\", this._settings.client_secret);\n        }\n\n        await this._jsonService.postForm(url, { body: params });\n        logger.debug(\"got response\");\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, JwtUtils } from \"./utils\";\nimport { ErrorResponse } from \"./errors\";\nimport type { MetadataService } from \"./MetadataService\";\nimport { UserInfoService } from \"./UserInfoService\";\nimport { TokenClient } from \"./TokenClient\";\nimport type { OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport type { SigninState } from \"./SigninState\";\nimport type { SigninResponse } from \"./SigninResponse\";\nimport type { State } from \"./State\";\nimport type { SignoutResponse } from \"./SignoutResponse\";\nimport type { UserProfile } from \"./User\";\nimport type { RefreshState } from \"./RefreshState\";\nimport type { IdTokenClaims } from \"./Claims\";\nimport type { ClaimsService } from \"./ClaimsService\";\n\n/**\n * @internal\n */\nexport class ResponseValidator {\n    protected readonly _logger = new Logger(\"ResponseValidator\");\n    protected readonly _userInfoService = new UserInfoService(this._settings, this._metadataService);\n    protected readonly _tokenClient = new TokenClient(this._settings, this._metadataService);\n\n    public constructor(\n        protected readonly _settings: OidcClientSettingsStore,\n        protected readonly _metadataService: MetadataService,\n        protected readonly _claimsService: ClaimsService,\n    ) {}\n\n    public async validateSigninResponse(response: SigninResponse, state: SigninState): Promise<void> {\n        const logger = this._logger.create(\"validateSigninResponse\");\n\n        this._processSigninState(response, state);\n        logger.debug(\"state processed\");\n\n        await this._processCode(response, state);\n        logger.debug(\"code processed\");\n\n        if (response.isOpenId) {\n            this._validateIdTokenAttributes(response);\n        }\n        logger.debug(\"tokens validated\");\n\n        await this._processClaims(response, state?.skipUserInfo, response.isOpenId);\n        logger.debug(\"claims processed\");\n    }\n\n    public async validateCredentialsResponse(response: SigninResponse, skipUserInfo: boolean): Promise<void> {\n        const logger = this._logger.create(\"validateCredentialsResponse\");\n\n        if (response.isOpenId && !!response.id_token) {\n            this._validateIdTokenAttributes(response);\n        }\n        logger.debug(\"tokens validated\");\n\n        await this._processClaims(response, skipUserInfo, response.isOpenId);\n        logger.debug(\"claims processed\");\n    }\n\n    public async validateRefreshResponse(response: SigninResponse, state: RefreshState): Promise<void> {\n        const logger = this._logger.create(\"validateRefreshResponse\");\n\n        response.userState = state.data;\n        // if there's no session_state on the response, copy over session_state from original request\n        response.session_state ??= state.session_state;\n        // if there's no scope on the response, then assume all scopes granted (per-spec) and copy over scopes from original request\n        response.scope ??= state.scope;\n\n        // OpenID Connect Core 1.0 says that id_token is optional in refresh response:\n        // https://openid.net/specs/openid-connect-core-1_0.html#RefreshTokenResponse\n        if (response.isOpenId && !!response.id_token) {\n            this._validateIdTokenAttributes(response, state.id_token);\n            logger.debug(\"ID Token validated\");\n        }\n\n        if (!response.id_token) {\n            // if there's no id_token on the response, copy over id_token from original request\n            response.id_token = state.id_token;\n            // and decoded part too\n            response.profile = state.profile;\n        }\n\n        const hasIdToken = response.isOpenId && !!response.id_token;\n        await this._processClaims(response, false, hasIdToken);\n        logger.debug(\"claims processed\");\n    }\n\n    public validateSignoutResponse(response: SignoutResponse, state: State): void {\n        const logger = this._logger.create(\"validateSignoutResponse\");\n        if (state.id !== response.state) {\n            logger.throw(new Error(\"State does not match\"));\n        }\n\n        // now that we know the state matches, take the stored data\n        // and set it into the response so callers can get their state\n        // this is important for both success & error outcomes\n        logger.debug(\"state validated\");\n        response.userState = state.data;\n\n        if (response.error) {\n            logger.warn(\"Response was error\", response.error);\n            throw new ErrorResponse(response);\n        }\n    }\n\n    protected _processSigninState(response: SigninResponse, state: SigninState): void {\n        const logger = this._logger.create(\"_processSigninState\");\n        if (state.id !== response.state) {\n            logger.throw(new Error(\"State does not match\"));\n        }\n\n        if (!state.client_id) {\n            logger.throw(new Error(\"No client_id on state\"));\n        }\n\n        if (!state.authority) {\n            logger.throw(new Error(\"No authority on state\"));\n        }\n\n        // ensure we're using the correct authority\n        if (this._settings.authority !== state.authority) {\n            logger.throw(new Error(\"authority mismatch on settings vs. signin state\"));\n        }\n        if (this._settings.client_id && this._settings.client_id !== state.client_id) {\n            logger.throw(new Error(\"client_id mismatch on settings vs. signin state\"));\n        }\n\n        // now that we know the state matches, take the stored data\n        // and set it into the response so callers can get their state\n        // this is important for both success & error outcomes\n        logger.debug(\"state validated\");\n        response.userState = state.data;\n        response.url_state = state.url_state;\n        // if there's no scope on the response, then assume all scopes granted (per-spec) and copy over scopes from original request\n        response.scope ??= state.scope;\n\n        if (response.error) {\n            logger.warn(\"Response was error\", response.error);\n            throw new ErrorResponse(response);\n        }\n\n        if (state.code_verifier && !response.code) {\n            logger.throw(new Error(\"Expected code in response\"));\n        }\n\n    }\n\n    protected async _processClaims(response: SigninResponse, skipUserInfo = false, validateSub = true): Promise<void> {\n        const logger = this._logger.create(\"_processClaims\");\n        response.profile = this._claimsService.filterProtocolClaims(response.profile);\n\n        if (skipUserInfo || !this._settings.loadUserInfo || !response.access_token) {\n            logger.debug(\"not loading user info\");\n            return;\n        }\n\n        logger.debug(\"loading user info\");\n        const claims = await this._userInfoService.getClaims(response.access_token);\n        logger.debug(\"user info claims received from user info endpoint\");\n\n        if (validateSub && claims.sub !== response.profile.sub) {\n            logger.throw(new Error(\"subject from UserInfo response does not match subject in ID Token\"));\n        }\n\n        response.profile = this._claimsService.mergeClaims(response.profile, this._claimsService.filterProtocolClaims(claims as IdTokenClaims));\n        logger.debug(\"user info claims received, updated profile:\", response.profile);\n    }\n\n    protected async _processCode(response: SigninResponse, state: SigninState): Promise<void> {\n        const logger = this._logger.create(\"_processCode\");\n        if (response.code) {\n            logger.debug(\"Validating code\");\n            const tokenResponse = await this._tokenClient.exchangeCode({\n                client_id: state.client_id,\n                client_secret: state.client_secret,\n                code: response.code,\n                redirect_uri: state.redirect_uri,\n                code_verifier: state.code_verifier,\n                ...state.extraTokenParams,\n            });\n            Object.assign(response, tokenResponse);\n        } else {\n            logger.debug(\"No code to process\");\n        }\n    }\n\n    protected _validateIdTokenAttributes(response: SigninResponse, existingToken?: string): void {\n        const logger = this._logger.create(\"_validateIdTokenAttributes\");\n\n        logger.debug(\"decoding ID Token JWT\");\n        const incoming = JwtUtils.decode(response.id_token ?? \"\");\n\n        if (!incoming.sub) {\n            logger.throw(new Error(\"ID Token is missing a subject claim\"));\n        }\n\n        if (existingToken) {\n            const existing = JwtUtils.decode(existingToken);\n            if (incoming.sub !== existing.sub) {\n                logger.throw(new Error(\"sub in id_token does not match current sub\"));\n            }\n            if (incoming.auth_time && incoming.auth_time !== existing.auth_time) {\n                logger.throw(new Error(\"auth_time in id_token does not match original auth_time\"));\n            }\n            if (incoming.azp && incoming.azp !== existing.azp) {\n                logger.throw(new Error(\"azp in id_token does not match original azp\"));\n            }\n            if (!incoming.azp && existing.azp) {\n                logger.throw(new Error(\"azp not in id_token, but present in original id_token\"));\n            }\n        }\n\n        response.profile = incoming as UserProfile;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, CryptoUtils, Timer } from \"./utils\";\nimport type { StateStore } from \"./StateStore\";\n\n/**\n * @public\n */\nexport class State {\n    public readonly id: string;\n    public readonly created: number;\n    public readonly request_type: string | undefined;\n    public readonly url_state: string | undefined;\n\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    public readonly data?: unknown;\n\n    public constructor(args: {\n        id?: string;\n        data?: unknown;\n        created?: number;\n        request_type?: string;\n        url_state?: string;\n    }) {\n        this.id = args.id || CryptoUtils.generateUUIDv4();\n        this.data = args.data;\n\n        if (args.created && args.created > 0) {\n            this.created = args.created;\n        }\n        else {\n            this.created = Timer.getEpochTime();\n        }\n        this.request_type = args.request_type;\n        this.url_state = args.url_state;\n    }\n\n    public toStorageString(): string {\n        new Logger(\"State\").create(\"toStorageString\");\n        return JSON.stringify({\n            id: this.id,\n            data: this.data,\n            created: this.created,\n            request_type: this.request_type,\n            url_state: this.url_state,\n        });\n    }\n\n    public static fromStorageString(storageString: string): State {\n        Logger.createStatic(\"State\", \"fromStorageString\");\n        return new State(JSON.parse(storageString));\n    }\n\n    public static async clearStaleState(storage: StateStore, age: number): Promise<void> {\n        const logger = Logger.createStatic(\"State\", \"clearStaleState\");\n        const cutoff = Timer.getEpochTime() - age;\n\n        const keys = await storage.getAllKeys();\n        logger.debug(\"got keys\", keys);\n\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            const item = await storage.get(key);\n            let remove = false;\n\n            if (item) {\n                try {\n                    const state = State.fromStorageString(item);\n\n                    logger.debug(\"got item from key:\", key, state.created);\n                    if (state.created <= cutoff) {\n                        remove = true;\n                    }\n                }\n                catch (err) {\n                    logger.error(\"Error parsing state for key:\", key, err);\n                    remove = true;\n                }\n            }\n            else {\n                logger.debug(\"no item in storage for key:\", key);\n                remove = true;\n            }\n\n            if (remove) {\n                logger.debug(\"removed item for key:\", key);\n                void storage.remove(key);\n            }\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, CryptoUtils } from \"./utils\";\nimport { State } from \"./State\";\n\n/**\n * @public\n */\nexport class SigninState extends State {\n    // isCode\n    /** The same code_verifier that was used to obtain the authorization_code via PKCE. */\n    public readonly code_verifier: string | undefined;\n    /** Used to secure authorization code grants via Proof Key for Code Exchange (PKCE). */\n    public readonly code_challenge: string | undefined;\n\n    // to ensure state still matches settings\n    /** @see {@link OidcClientSettings.authority} */\n    public readonly authority: string;\n    /** @see {@link OidcClientSettings.client_id} */\n    public readonly client_id: string;\n    /** @see {@link OidcClientSettings.redirect_uri} */\n    public readonly redirect_uri: string;\n    /** @see {@link OidcClientSettings.scope} */\n    public readonly scope: string;\n    /** @see {@link OidcClientSettings.client_secret} */\n    public readonly client_secret: string | undefined;\n    /** @see {@link OidcClientSettings.extraTokenParams} */\n    public readonly extraTokenParams: Record<string, unknown> | undefined;\n    /** @see {@link OidcClientSettings.response_mode} */\n    public readonly response_mode: \"query\" | \"fragment\" | undefined;\n\n    public readonly skipUserInfo: boolean | undefined;\n\n    public constructor(args: {\n        id?: string;\n        data?: unknown;\n        created?: number;\n        request_type?: string;\n        url_state?: string;\n\n        code_verifier?: string | boolean;\n        authority: string;\n        client_id: string;\n        redirect_uri: string;\n        scope: string;\n        client_secret?: string;\n        extraTokenParams?: Record<string, unknown>;\n        response_mode?: \"query\" | \"fragment\";\n        skipUserInfo?: boolean;\n    }) {\n        super(args);\n\n        if (args.code_verifier === true) {\n            this.code_verifier = CryptoUtils.generateCodeVerifier();\n        }\n        else if (args.code_verifier) {\n            this.code_verifier = args.code_verifier;\n        }\n\n        if (this.code_verifier) {\n            this.code_challenge = CryptoUtils.generateCodeChallenge(this.code_verifier);\n        }\n\n        this.authority = args.authority;\n        this.client_id = args.client_id;\n        this.redirect_uri = args.redirect_uri;\n        this.scope = args.scope;\n        this.client_secret = args.client_secret;\n        this.extraTokenParams = args.extraTokenParams;\n\n        this.response_mode = args.response_mode;\n        this.skipUserInfo = args.skipUserInfo;\n    }\n\n    public toStorageString(): string {\n        new Logger(\"SigninState\").create(\"toStorageString\");\n        return JSON.stringify({\n            id: this.id,\n            data: this.data,\n            created: this.created,\n            request_type: this.request_type,\n            url_state: this.url_state,\n\n            code_verifier: this.code_verifier,\n            authority: this.authority,\n            client_id: this.client_id,\n            redirect_uri: this.redirect_uri,\n            scope: this.scope,\n            client_secret: this.client_secret,\n            extraTokenParams : this.extraTokenParams,\n            response_mode: this.response_mode,\n            skipUserInfo: this.skipUserInfo,\n        });\n    }\n\n    public static fromStorageString(storageString: string): SigninState {\n        Logger.createStatic(\"SigninState\", \"fromStorageString\");\n        const data = JSON.parse(storageString);\n        return new SigninState(data);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, URL_STATE_DELIMITER } from \"./utils\";\nimport { SigninState } from \"./SigninState\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest\n */\nexport interface SigninRequestArgs {\n    // mandatory\n    url: string;\n    authority: string;\n    client_id: string;\n    redirect_uri: string;\n    response_type: string;\n    scope: string;\n\n    // optional\n    response_mode?: \"query\" | \"fragment\";\n    nonce?: string;\n    display?: string;\n    prompt?: string;\n    max_age?: number;\n    ui_locales?: string;\n    id_token_hint?: string;\n    login_hint?: string;\n    acr_values?: string;\n\n    // other\n    resource?: string | string[];\n    request?: string;\n    request_uri?: string;\n    request_type?: string;\n    extraQueryParams?: Record<string, string | number | boolean>;\n\n    // special\n    extraTokenParams?: Record<string, unknown>;\n    client_secret?: string;\n    skipUserInfo?: boolean;\n    disablePKCE?: boolean;\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state_data?: unknown;\n    url_state?: string;\n}\n\n/**\n * @public\n */\nexport class SigninRequest {\n    private readonly _logger = new Logger(\"SigninRequest\");\n\n    public readonly url: string;\n    public readonly state: SigninState;\n\n    public constructor({\n        // mandatory\n        url, authority, client_id, redirect_uri, response_type, scope,\n        // optional\n        state_data, response_mode, request_type, client_secret, nonce, url_state,\n        resource,\n        skipUserInfo,\n        extraQueryParams,\n        extraTokenParams,\n        disablePKCE,\n        ...optionalParams\n    }: SigninRequestArgs) {\n        if (!url) {\n            this._logger.error(\"ctor: No url passed\");\n            throw new Error(\"url\");\n        }\n        if (!client_id) {\n            this._logger.error(\"ctor: No client_id passed\");\n            throw new Error(\"client_id\");\n        }\n        if (!redirect_uri) {\n            this._logger.error(\"ctor: No redirect_uri passed\");\n            throw new Error(\"redirect_uri\");\n        }\n        if (!response_type) {\n            this._logger.error(\"ctor: No response_type passed\");\n            throw new Error(\"response_type\");\n        }\n        if (!scope) {\n            this._logger.error(\"ctor: No scope passed\");\n            throw new Error(\"scope\");\n        }\n        if (!authority) {\n            this._logger.error(\"ctor: No authority passed\");\n            throw new Error(\"authority\");\n        }\n\n        this.state = new SigninState({\n            data: state_data,\n            request_type,\n            url_state,\n            code_verifier: !disablePKCE,\n            client_id, authority, redirect_uri,\n            response_mode,\n            client_secret, scope, extraTokenParams,\n            skipUserInfo,\n        });\n\n        const parsedUrl = new URL(url);\n        parsedUrl.searchParams.append(\"client_id\", client_id);\n        parsedUrl.searchParams.append(\"redirect_uri\", redirect_uri);\n        parsedUrl.searchParams.append(\"response_type\", response_type);\n        parsedUrl.searchParams.append(\"scope\", scope);\n        if (nonce) {\n            parsedUrl.searchParams.append(\"nonce\", nonce);\n        }\n\n        let state = this.state.id;\n        if (url_state) {\n            state = `${state}${URL_STATE_DELIMITER}${url_state}`;\n        }\n        parsedUrl.searchParams.append(\"state\", state);\n        if (this.state.code_challenge) {\n            parsedUrl.searchParams.append(\"code_challenge\", this.state.code_challenge);\n            parsedUrl.searchParams.append(\"code_challenge_method\", \"S256\");\n        }\n\n        if (resource) {\n            // https://datatracker.ietf.org/doc/html/rfc8707\n            const resources = Array.isArray(resource) ? resource : [resource];\n            resources\n                .forEach(r => parsedUrl.searchParams.append(\"resource\", r));\n        }\n\n        for (const [key, value] of Object.entries({ response_mode, ...optionalParams, ...extraQueryParams })) {\n            if (value != null) {\n                parsedUrl.searchParams.append(key, value.toString());\n            }\n        }\n\n        this.url = parsedUrl.href;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Timer, URL_STATE_DELIMITER } from \"./utils\";\nimport type { UserProfile } from \"./User\";\n\nconst OidcScope = \"openid\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthResponse\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthError\n */\nexport class SigninResponse {\n    // props present in the initial callback response regardless of success\n    public readonly state: string | null;\n    /** @see {@link User.session_state} */\n    public session_state: string | null;\n\n    // error props\n    /** @see {@link ErrorResponse.error} */\n    public readonly error: string | null;\n    /** @see {@link ErrorResponse.error_description} */\n    public readonly error_description: string | null;\n    /** @see {@link ErrorResponse.error_uri} */\n    public readonly error_uri: string | null;\n\n    // success props\n    public readonly code: string | null;\n\n    // props set after validation\n    /** @see {@link User.id_token} */\n    public id_token?: string;\n    /** @see {@link User.access_token} */\n    public access_token = \"\";\n    /** @see {@link User.token_type} */\n    public token_type = \"\";\n    /** @see {@link User.refresh_token} */\n    public refresh_token?: string;\n    /** @see {@link User.scope} */\n    public scope?: string;\n    /** @see {@link User.expires_at} */\n    public expires_at?: number;\n\n    /** custom state data set during the initial signin request */\n    public userState: unknown;\n    public url_state?: string;\n\n    /** @see {@link User.profile} */\n    public profile: UserProfile = {} as UserProfile;\n\n    public constructor(params: URLSearchParams) {\n        this.state = params.get(\"state\");\n        this.session_state = params.get(\"session_state\");\n        if (this.state) {\n            const splitState = decodeURIComponent(this.state).split(URL_STATE_DELIMITER);\n            this.state = splitState[0];\n            if (splitState.length > 1) {\n                this.url_state = splitState.slice(1).join(URL_STATE_DELIMITER);\n            }\n        }\n\n        this.error = params.get(\"error\");\n        this.error_description = params.get(\"error_description\");\n        this.error_uri = params.get(\"error_uri\");\n\n        this.code = params.get(\"code\");\n    }\n\n    public get expires_in(): number | undefined {\n        if (this.expires_at === undefined) {\n            return undefined;\n        }\n        return this.expires_at - Timer.getEpochTime();\n    }\n    public set expires_in(value: number | undefined) {\n        // spec expects a number, but normalize here just in case\n        if (typeof value === \"string\") value = Number(value);\n        if (value !== undefined && value >= 0) {\n            this.expires_at = Math.floor(value) + Timer.getEpochTime();\n        }\n    }\n\n    public get isOpenId(): boolean {\n        return this.scope?.split(\" \").includes(OidcScope) || !!this.id_token;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { State } from \"./State\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-rpinitiated-1_0.html#RPLogout\n */\nexport interface SignoutRequestArgs {\n    // mandatory\n    url: string;\n\n    // optional\n    id_token_hint?: string;\n    client_id?: string;\n    post_logout_redirect_uri?: string;\n    extraQueryParams?: Record<string, string | number | boolean>;\n\n    // special\n    request_type?: string;\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state_data?: unknown;\n}\n\n/**\n * @public\n */\nexport class SignoutRequest {\n    private readonly _logger = new Logger(\"SignoutRequest\");\n\n    public readonly url: string;\n    public readonly state?: State;\n\n    public constructor({\n        url,\n        state_data, id_token_hint, post_logout_redirect_uri, extraQueryParams, request_type, client_id,\n    }: SignoutRequestArgs) {\n        if (!url) {\n            this._logger.error(\"ctor: No url passed\");\n            throw new Error(\"url\");\n        }\n\n        const parsedUrl = new URL(url);\n        if (id_token_hint) {\n            parsedUrl.searchParams.append(\"id_token_hint\", id_token_hint);\n        }\n        if (client_id) {\n            parsedUrl.searchParams.append(\"client_id\", client_id);\n        }\n\n        if (post_logout_redirect_uri) {\n            parsedUrl.searchParams.append(\"post_logout_redirect_uri\", post_logout_redirect_uri);\n\n            if (state_data) {\n                this.state = new State({ data: state_data, request_type });\n\n                parsedUrl.searchParams.append(\"state\", this.state.id);\n            }\n        }\n\n        for (const [key, value] of Object.entries({ ...extraQueryParams })) {\n            if (value != null) {\n                parsedUrl.searchParams.append(key, value.toString());\n            }\n        }\n\n        this.url = parsedUrl.href;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthError\n */\nexport class SignoutResponse {\n    public readonly state: string | null;\n\n    // error props\n    /** @see {@link ErrorResponse.error} */\n    public error: string | null;\n    /** @see {@link ErrorResponse.error_description} */\n    public error_description: string | null;\n    /** @see {@link ErrorResponse.error_uri} */\n    public error_uri: string | null;\n\n    /** custom state data set during the initial signin request */\n    public userState: unknown;\n\n    public constructor(params: URLSearchParams) {\n        this.state = params.get(\"state\");\n\n        this.error = params.get(\"error\");\n        this.error_description = params.get(\"error_description\");\n        this.error_uri = params.get(\"error_uri\");\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport type { JwtClaims } from \"./Claims\";\nimport type { OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport type { UserProfile } from \"./User\";\nimport { Logger } from \"./utils\";\n\n/**\n * Protocol claims that could be removed by default from profile.\n * Derived from the following sets of claims:\n * - {@link https://datatracker.ietf.org/doc/html/rfc7519.html#section-4.1}\n * - {@link https://openid.net/specs/openid-connect-core-1_0.html#IDToken}\n * - {@link https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken}\n *\n * @internal\n */\nconst DefaultProtocolClaims = [\n    \"nbf\",\n    \"jti\",\n    \"auth_time\",\n    \"nonce\",\n    \"acr\",\n    \"amr\",\n    \"azp\",\n    \"at_hash\", // https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken\n] as const;\n\n/**\n * Protocol claims that should never be removed from profile.\n * \"sub\" is needed internally and others should remain required as per the OIDC specs.\n *\n * @internal\n */\nconst InternalRequiredProtocolClaims = [\"sub\", \"iss\", \"aud\", \"exp\", \"iat\"];\n\n/**\n * @internal\n */\nexport class ClaimsService {\n    protected readonly _logger = new Logger(\"ClaimsService\");\n    public constructor(\n        protected readonly _settings: OidcClientSettingsStore,\n    ) {}\n\n    public filterProtocolClaims(claims: UserProfile): UserProfile {\n        const result = { ...claims };\n\n        if (this._settings.filterProtocolClaims) {\n            let protocolClaims;\n            if (Array.isArray(this._settings.filterProtocolClaims)) {\n                protocolClaims = this._settings.filterProtocolClaims;\n            } else {\n                protocolClaims = DefaultProtocolClaims;\n            }\n\n            for (const claim of protocolClaims) {\n                if (!InternalRequiredProtocolClaims.includes(claim)) {\n                    delete result[claim];\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public mergeClaims(claims1: UserProfile, claims2: JwtClaims): UserProfile {\n        const result = { ...claims1 };\n\n        for (const [claim, values] of Object.entries(claims2)) {\n            for (const value of Array.isArray(values) ? values : [values]) {\n                const previousValue = result[claim];\n                if (previousValue === undefined) {\n                    result[claim] = value;\n                }\n                else if (Array.isArray(previousValue)) {\n                    if (!previousValue.includes(value)) {\n                        previousValue.push(value);\n                    }\n                }\n                else if (result[claim] !== value) {\n                    if (typeof value === \"object\" && this._settings.mergeClaims) {\n                        result[claim] = this.mergeClaims(previousValue as UserProfile, value);\n                    }\n                    else {\n                        result[claim] = [previousValue, value];\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, UrlUtils } from \"./utils\";\nimport { ErrorResponse } from \"./errors\";\nimport { type OidcClientSettings, OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport { ResponseValidator } from \"./ResponseValidator\";\nimport { MetadataService } from \"./MetadataService\";\nimport type { RefreshState } from \"./RefreshState\";\nimport { SigninRequest, type SigninRequestArgs } from \"./SigninRequest\";\nimport { SigninResponse } from \"./SigninResponse\";\nimport { SignoutRequest, type SignoutRequestArgs } from \"./SignoutRequest\";\nimport { SignoutResponse } from \"./SignoutResponse\";\nimport { SigninState } from \"./SigninState\";\nimport { State } from \"./State\";\nimport { TokenClient } from \"./TokenClient\";\nimport { ClaimsService } from \"./ClaimsService\";\n\n/**\n * @public\n */\nexport interface CreateSigninRequestArgs\n    extends Omit<SigninRequestArgs, \"url\" | \"authority\" | \"client_id\" | \"redirect_uri\" | \"response_type\" | \"scope\" | \"state_data\"> {\n    redirect_uri?: string;\n    response_type?: string;\n    scope?: string;\n\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state?: unknown;\n}\n\n/**\n * @public\n */\nexport interface UseRefreshTokenArgs {\n    state: RefreshState;\n    timeoutInSeconds?: number;\n}\n\n/**\n * @public\n */\nexport type CreateSignoutRequestArgs = Omit<SignoutRequestArgs, \"url\" | \"state_data\"> & {\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state?: unknown;\n};\n\n/**\n * @public\n */\nexport type ProcessResourceOwnerPasswordCredentialsArgs = {\n    username: string;\n    password: string;\n    skipUserInfo?: boolean;\n    extraTokenParams?: Record<string, unknown>;\n};\n\n/**\n * Provides the raw OIDC/OAuth2 protocol support for the authorization endpoint and the end session endpoint in the\n * authorization server. It provides a bare-bones protocol implementation and is used by the UserManager class.\n * Only use this class if you simply want protocol support without the additional management features of the\n * UserManager class.\n *\n * @public\n */\nexport class OidcClient {\n    public readonly settings: OidcClientSettingsStore;\n    protected readonly _logger = new Logger(\"OidcClient\");\n\n    public readonly metadataService: MetadataService;\n    protected readonly _claimsService: ClaimsService;\n    protected readonly _validator: ResponseValidator;\n    protected readonly _tokenClient: TokenClient;\n\n    public constructor(settings: OidcClientSettings);\n    public constructor(settings: OidcClientSettingsStore, metadataService: MetadataService); \n    public constructor(settings: OidcClientSettings | OidcClientSettingsStore, metadataService?: MetadataService) {\n        this.settings = settings instanceof OidcClientSettingsStore ? settings : new OidcClientSettingsStore(settings);\n\n        this.metadataService = metadataService ?? new MetadataService(this.settings);\n        this._claimsService = new ClaimsService(this.settings);\n        this._validator = new ResponseValidator(this.settings, this.metadataService, this._claimsService);\n        this._tokenClient = new TokenClient(this.settings, this.metadataService);\n    }\n\n    public async createSigninRequest({\n        state,\n        request,\n        request_uri,\n        request_type,\n        id_token_hint,\n        login_hint,\n        skipUserInfo,\n        nonce,\n        url_state,\n        response_type = this.settings.response_type,\n        scope = this.settings.scope,\n        redirect_uri = this.settings.redirect_uri,\n        prompt = this.settings.prompt,\n        display = this.settings.display,\n        max_age = this.settings.max_age,\n        ui_locales = this.settings.ui_locales,\n        acr_values = this.settings.acr_values,\n        resource = this.settings.resource,\n        response_mode = this.settings.response_mode,\n        extraQueryParams = this.settings.extraQueryParams,\n        extraTokenParams = this.settings.extraTokenParams,\n    }: CreateSigninRequestArgs): Promise<SigninRequest> {\n        const logger = this._logger.create(\"createSigninRequest\");\n\n        if (response_type !== \"code\") {\n            throw new Error(\"Only the Authorization Code flow (with PKCE) is supported\");\n        }\n\n        const url = await this.metadataService.getAuthorizationEndpoint();\n        logger.debug(\"Received authorization endpoint\", url);\n\n        const signinRequest = new SigninRequest({\n            url,\n            authority: this.settings.authority,\n            client_id: this.settings.client_id,\n            redirect_uri,\n            response_type,\n            scope,\n            state_data: state,\n            url_state,\n            prompt, display, max_age, ui_locales, id_token_hint, login_hint, acr_values,\n            resource, request, request_uri, extraQueryParams, extraTokenParams, request_type, response_mode,\n            client_secret: this.settings.client_secret,\n            skipUserInfo,\n            nonce,\n            disablePKCE: this.settings.disablePKCE,\n        });\n\n        // house cleaning\n        await this.clearStaleState();\n\n        const signinState = signinRequest.state;\n        await this.settings.stateStore.set(signinState.id, signinState.toStorageString());\n        return signinRequest;\n    }\n\n    public async readSigninResponseState(url: string, removeState = false): Promise<{ state: SigninState; response: SigninResponse }> {\n        const logger = this._logger.create(\"readSigninResponseState\");\n\n        const response = new SigninResponse(UrlUtils.readParams(url, this.settings.response_mode));\n        if (!response.state) {\n            logger.throw(new Error(\"No state in response\"));\n            // need to throw within this function's body for type narrowing to work\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n        if (!storedStateString) {\n            logger.throw(new Error(\"No matching state found in storage\"));\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        const state = SigninState.fromStorageString(storedStateString);\n        return { state, response };\n    }\n\n    public async processSigninResponse(url: string): Promise<SigninResponse> {\n        const logger = this._logger.create(\"processSigninResponse\");\n\n        const { state, response } = await this.readSigninResponseState(url, true);\n        logger.debug(\"received state from storage; validating response\");\n        await this._validator.validateSigninResponse(response, state);\n        return response;\n    }\n\n    public async processResourceOwnerPasswordCredentials({\n        username,\n        password,\n        skipUserInfo = false,\n        extraTokenParams = {},\n    }: ProcessResourceOwnerPasswordCredentialsArgs): Promise<SigninResponse> {\n        const tokenResponse: Record<string, unknown> = await this._tokenClient.exchangeCredentials({ username, password, ...extraTokenParams });\n        const signinResponse: SigninResponse = new SigninResponse(new URLSearchParams());\n        Object.assign(signinResponse, tokenResponse);\n        await this._validator.validateCredentialsResponse(signinResponse, skipUserInfo);\n        return signinResponse;\n    }\n\n    public async useRefreshToken({\n        state,\n        timeoutInSeconds,\n    }: UseRefreshTokenArgs): Promise<SigninResponse> {\n        const logger = this._logger.create(\"useRefreshToken\");\n\n        // https://github.com/authts/oidc-client-ts/issues/695\n        // In some cases (e.g. AzureAD), not all granted scopes are allowed on token refresh requests.\n        // Therefore, we filter all granted scopes by a list of allowable scopes.\n        let scope;\n        if (this.settings.refreshTokenAllowedScope === undefined) {\n            scope = state.scope;\n        } else {\n            const allowableScopes = this.settings.refreshTokenAllowedScope.split(\" \");\n            const providedScopes = state.scope?.split(\" \") || [];\n\n            scope = providedScopes.filter(s => allowableScopes.includes(s)).join(\" \");\n        }\n\n        const result = await this._tokenClient.exchangeRefreshToken({\n            refresh_token: state.refresh_token,\n            resource: state.resource,\n            // provide the (possible filtered) scope list\n            scope,\n            timeoutInSeconds,\n        });\n        const response = new SigninResponse(new URLSearchParams());\n        Object.assign(response, result);\n        logger.debug(\"validating response\", response);\n        await this._validator.validateRefreshResponse(response, {\n            ...state,\n            // overide the scope in the state handed over to the validator\n            // so it can set the granted scope to the requested scope in case none is included in the response\n            scope,\n        });\n        return response;\n    }\n\n    public async createSignoutRequest({\n        state,\n        id_token_hint,\n        client_id,\n        request_type,\n        post_logout_redirect_uri = this.settings.post_logout_redirect_uri,\n        extraQueryParams = this.settings.extraQueryParams,\n    }: CreateSignoutRequestArgs = {}): Promise<SignoutRequest> {\n        const logger = this._logger.create(\"createSignoutRequest\");\n\n        const url = await this.metadataService.getEndSessionEndpoint();\n        if (!url) {\n            logger.throw(new Error(\"No end session endpoint\"));\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        logger.debug(\"Received end session endpoint\", url);\n\n        // specify the client identifier when post_logout_redirect_uri is used but id_token_hint is not\n        if (!client_id && post_logout_redirect_uri && !id_token_hint) {\n            client_id = this.settings.client_id;\n        }\n\n        const request = new SignoutRequest({\n            url,\n            id_token_hint,\n            client_id,\n            post_logout_redirect_uri,\n            state_data: state,\n            extraQueryParams,\n            request_type,\n        });\n\n        // house cleaning\n        await this.clearStaleState();\n\n        const signoutState = request.state;\n        if (signoutState) {\n            logger.debug(\"Signout request has state to persist\");\n            await this.settings.stateStore.set(signoutState.id, signoutState.toStorageString());\n        }\n\n        return request;\n    }\n\n    public async readSignoutResponseState(url: string, removeState = false): Promise<{ state: State | undefined; response: SignoutResponse }> {\n        const logger = this._logger.create(\"readSignoutResponseState\");\n\n        const response = new SignoutResponse(UrlUtils.readParams(url, this.settings.response_mode));\n        if (!response.state) {\n            logger.debug(\"No state in response\");\n\n            if (response.error) {\n                logger.warn(\"Response was error:\", response.error);\n                throw new ErrorResponse(response);\n            }\n\n            return { state: undefined, response };\n        }\n\n        const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n        if (!storedStateString) {\n            logger.throw(new Error(\"No matching state found in storage\"));\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        const state = State.fromStorageString(storedStateString);\n        return { state, response };\n    }\n\n    public async processSignoutResponse(url: string): Promise<SignoutResponse> {\n        const logger = this._logger.create(\"processSignoutResponse\");\n\n        const { state, response } = await this.readSignoutResponseState(url, true);\n        if (state) {\n            logger.debug(\"Received state from storage; validating response\");\n            this._validator.validateSignoutResponse(response, state);\n        } else {\n            logger.debug(\"No state from storage; skipping response validation\");\n        }\n\n        return response;\n    }\n\n    public clearStaleState(): Promise<void> {\n        this._logger.create(\"clearStaleState\");\n        return State.clearStaleState(this.settings.stateStore, this.settings.staleStateAgeInSeconds);\n    }\n\n    public async revokeToken(token: string, type?: \"access_token\" | \"refresh_token\"): Promise<void> {\n        this._logger.create(\"revokeToken\");\n        return await this._tokenClient.revoke({\n            token,\n            token_type_hint: type,\n        });\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { CheckSessionIFrame } from \"./CheckSessionIFrame\";\nimport type { UserManager } from \"./UserManager\";\nimport type { User } from \"./User\";\n\n/**\n * @public\n */\nexport class SessionMonitor {\n    private readonly _logger = new Logger(\"SessionMonitor\");\n\n    private _sub: string | undefined;\n    private _sid: string | undefined;\n    private _checkSessionIFrame?: CheckSessionIFrame;\n\n    public constructor(private readonly _userManager: UserManager) {\n        if (!_userManager) {\n            this._logger.throw(new Error(\"No user manager passed\"));\n        }\n\n        this._userManager.events.addUserLoaded(this._start);\n        this._userManager.events.addUserUnloaded(this._stop);\n\n        this._init().catch((err: unknown) => {\n            // catch to suppress errors since we're in a ctor\n            this._logger.error(err);\n        });\n    }\n\n    protected async _init(): Promise<void> {\n        this._logger.create(\"_init\");\n        const user = await this._userManager.getUser();\n        // doing this manually here since calling getUser\n        // doesn't trigger load event.\n        if (user) {\n            void this._start(user);\n        }\n        else if (this._userManager.settings.monitorAnonymousSession) {\n            const session = await this._userManager.querySessionStatus();\n            if (session) {\n                const tmpUser = {\n                    session_state: session.session_state,\n                    profile: session.sub && session.sid ? {\n                        sub: session.sub,\n                        sid: session.sid,\n                    } : null,\n                };\n                void this._start(tmpUser);\n            }\n        }\n    }\n\n    protected _start = async (\n        user: User | {\n            session_state: string;\n            profile: { sub: string; sid: string } | null;\n        },\n    ): Promise<void> => {\n        const session_state = user.session_state;\n        if (!session_state) {\n            return;\n        }\n        const logger = this._logger.create(\"_start\");\n\n        if (user.profile) {\n            this._sub = user.profile.sub;\n            this._sid = user.profile.sid;\n            logger.debug(\"session_state\", session_state, \", sub\", this._sub);\n        }\n        else {\n            this._sub = undefined;\n            this._sid = undefined;\n            logger.debug(\"session_state\", session_state, \", anonymous user\");\n        }\n\n        if (this._checkSessionIFrame) {\n            this._checkSessionIFrame.start(session_state);\n            return;\n        }\n\n        try {\n            const url = await this._userManager.metadataService.getCheckSessionIframe();\n            if (url) {\n                logger.debug(\"initializing check session iframe\");\n\n                const client_id = this._userManager.settings.client_id;\n                const intervalInSeconds = this._userManager.settings.checkSessionIntervalInSeconds;\n                const stopOnError = this._userManager.settings.stopCheckSessionOnError;\n\n                const checkSessionIFrame = new CheckSessionIFrame(this._callback, client_id, url, intervalInSeconds, stopOnError);\n                await checkSessionIFrame.load();\n                this._checkSessionIFrame = checkSessionIFrame;\n                checkSessionIFrame.start(session_state);\n            }\n            else {\n                logger.warn(\"no check session iframe found in the metadata\");\n            }\n        }\n        catch (err) {\n            // catch to suppress errors since we're in non-promise callback\n            logger.error(\"Error from getCheckSessionIframe:\", err instanceof Error ? err.message : err);\n        }\n    };\n\n    protected _stop = (): void => {\n        const logger = this._logger.create(\"_stop\");\n        this._sub = undefined;\n        this._sid = undefined;\n\n        if (this._checkSessionIFrame) {\n            this._checkSessionIFrame.stop();\n        }\n\n        if (this._userManager.settings.monitorAnonymousSession) {\n            // using a timer to delay re-initialization to avoid race conditions during signout\n            // TODO rewrite to use promise correctly\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            const timerHandle = setInterval(async () => {\n                clearInterval(timerHandle);\n\n                try {\n                    const session = await this._userManager.querySessionStatus();\n                    if (session) {\n                        const tmpUser = {\n                            session_state: session.session_state,\n                            profile: session.sub && session.sid ? {\n                                sub: session.sub,\n                                sid: session.sid,\n                            } : null,\n                        };\n                        void this._start(tmpUser);\n                    }\n                }\n                catch (err) {\n                    // catch to suppress errors since we're in a callback\n                    logger.error(\"error from querySessionStatus\", err instanceof Error ? err.message : err);\n                }\n            }, 1000);\n        }\n    };\n\n    protected _callback = async (): Promise<void> => {\n        const logger = this._logger.create(\"_callback\");\n        try {\n            const session = await this._userManager.querySessionStatus();\n            let raiseEvent = true;\n\n            if (session && this._checkSessionIFrame) {\n                if (session.sub === this._sub) {\n                    raiseEvent = false;\n                    this._checkSessionIFrame.start(session.session_state);\n\n                    if (session.sid === this._sid) {\n                        logger.debug(\"same sub still logged in at OP, restarting check session iframe; session_state\", session.session_state);\n                    }\n                    else {\n                        logger.debug(\"same sub still logged in at OP, session state has changed, restarting check session iframe; session_state\", session.session_state);\n                        this._userManager.events._raiseUserSessionChanged();\n                    }\n                }\n                else {\n                    logger.debug(\"different subject signed into OP\", session.sub);\n                }\n            }\n            else {\n                logger.debug(\"subject no longer signed into OP\");\n            }\n\n            if (raiseEvent) {\n                if (this._sub) {\n                    this._userManager.events._raiseUserSignedOut();\n                }\n                else {\n                    this._userManager.events._raiseUserSignedIn();\n                }\n            } else {\n                logger.debug(\"no change in session detected, no event to raise\");\n            }\n        }\n        catch (err) {\n            if (this._sub) {\n                logger.debug(\"Error calling queryCurrentSigninSession; raising signed out event\", err);\n                this._userManager.events._raiseUserSignedOut();\n            }\n        }\n    };\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Timer } from \"./utils\";\nimport type { IdTokenClaims } from \"./Claims\";\n\n/**\n * Holds claims represented by a combination of the `id_token` and the user info endpoint.\n * @public\n */\nexport type UserProfile = IdTokenClaims;\n\n/**\n * @public\n */\nexport class User {\n    /**\n     * A JSON Web Token (JWT). Only provided if `openid` scope was requested.\n     * The application can access the data decoded by using the `profile` property.\n     */\n    public id_token?: string;\n\n    /** The session state value returned from the OIDC provider. */\n    public session_state: string | null;\n\n    /**\n     * The requested access token returned from the OIDC provider. The application can use this token to\n     * authenticate itself to the secured resource.\n     */\n    public access_token: string;\n\n    /**\n     * An OAuth 2.0 refresh token. The app can use this token to acquire additional access tokens after the\n     * current access token expires. Refresh tokens are long-lived and can be used to maintain access to resources\n     * for extended periods of time.\n     */\n    public refresh_token?: string;\n\n    /** Typically \"Bearer\" */\n    public token_type: string;\n\n    /** The scopes that the requested access token is valid for. */\n    public scope?: string;\n\n    /** The claims represented by a combination of the `id_token` and the user info endpoint. */\n    public profile: UserProfile;\n\n    /** The expires at returned from the OIDC provider. */\n    public expires_at?: number;\n\n    /** custom state data set during the initial signin request */\n    public readonly state: unknown;\n    public readonly url_state?: string;\n\n    public constructor(args: {\n        id_token?: string;\n        session_state?: string | null;\n        access_token: string;\n        refresh_token?: string;\n        token_type: string;\n        scope?: string;\n        profile: UserProfile;\n        expires_at?: number;\n        userState?: unknown;\n        url_state?: string;\n    }) {\n        this.id_token = args.id_token;\n        this.session_state = args.session_state ?? null;\n        this.access_token = args.access_token;\n        this.refresh_token = args.refresh_token;\n\n        this.token_type = args.token_type;\n        this.scope = args.scope;\n        this.profile = args.profile;\n        this.expires_at = args.expires_at;\n        this.state = args.userState;\n        this.url_state = args.url_state;\n    }\n\n    /** Computed number of seconds the access token has remaining. */\n    public get expires_in(): number | undefined {\n        if (this.expires_at === undefined) {\n            return undefined;\n        }\n        return this.expires_at - Timer.getEpochTime();\n    }\n\n    public set expires_in(value: number | undefined) {\n        if (value !== undefined) {\n            this.expires_at = Math.floor(value) + Timer.getEpochTime();\n        }\n    }\n\n    /** Computed value indicating if the access token is expired. */\n    public get expired(): boolean | undefined {\n        const expires_in = this.expires_in;\n        if (expires_in === undefined) {\n            return undefined;\n        }\n        return expires_in <= 0;\n    }\n\n    /** Array representing the parsed values from the `scope`. */\n    public get scopes(): string[] {\n        return this.scope?.split(\" \") ?? [];\n    }\n\n    public toStorageString(): string {\n        new Logger(\"User\").create(\"toStorageString\");\n        return JSON.stringify({\n            id_token: this.id_token,\n            session_state: this.session_state,\n            access_token: this.access_token,\n            refresh_token: this.refresh_token,\n            token_type: this.token_type,\n            scope: this.scope,\n            profile: this.profile,\n            expires_at: this.expires_at,\n        });\n    }\n\n    public static fromStorageString(storageString: string): User {\n        Logger.createStatic(\"User\", \"fromStorageString\");\n        return new User(JSON.parse(storageString));\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Event, Logger, UrlUtils } from \"../utils\";\nimport type { IWindow, NavigateParams, NavigateResponse } from \"./IWindow\";\n\nconst messageSource = \"oidc-client\";\n\ninterface MessageData {\n    source: string;\n    url: string;\n    keepOpen: boolean;\n}\n\n/**\n * Window implementation which resolves via communication from a child window\n * via the `Window.postMessage()` interface.\n *\n * @internal\n */\nexport abstract class AbstractChildWindow implements IWindow {\n    protected abstract readonly _logger: Logger;\n    protected readonly _abort = new Event<[reason: Error]>(\"Window navigation aborted\");\n    protected readonly _disposeHandlers = new Set<() => void>();\n\n    protected _window: WindowProxy | null = null;\n\n    public async navigate(params: NavigateParams): Promise<NavigateResponse> {\n        const logger = this._logger.create(\"navigate\");\n        if (!this._window) {\n            throw new Error(\"Attempted to navigate on a disposed window\");\n        }\n\n        logger.debug(\"setting URL in window\");\n        this._window.location.replace(params.url);\n\n        const { url, keepOpen } = await new Promise<MessageData>((resolve, reject) => {\n            const listener = (e: MessageEvent) => {\n                const data: MessageData | undefined = e.data;\n                const origin = params.scriptOrigin ?? window.location.origin;\n                if (e.origin !== origin || data?.source !== messageSource) {\n                    // silently discard events not intended for us\n                    return;\n                }\n                try {\n                    const state = UrlUtils.readParams(data.url, params.response_mode).get(\"state\");\n                    if (!state) {\n                        logger.warn(\"no state found in response url\");\n                    }\n                    if (e.source !== this._window && state !== params.state) {\n                        // MessageEvent source is a relatively modern feature, we can't rely on it\n                        // so we also inspect the payload for a matching state key as an alternative\n                        return;\n                    }\n                }\n                catch (err) {\n                    this._dispose();\n                    reject(new Error(\"Invalid response from window\"));\n                }\n                resolve(data);\n            };\n            window.addEventListener(\"message\", listener, false);\n            this._disposeHandlers.add(() => window.removeEventListener(\"message\", listener, false));\n            this._disposeHandlers.add(this._abort.addHandler((reason) => {\n                this._dispose();\n                reject(reason);\n            }));\n        });\n        logger.debug(\"got response from window\");\n        this._dispose();\n\n        if (!keepOpen) {\n            this.close();\n        }\n\n        return { url };\n    }\n\n    public abstract close(): void;\n\n    private _dispose(): void {\n        this._logger.create(\"_dispose\");\n\n        for (const dispose of this._disposeHandlers) {\n            dispose();\n        }\n        this._disposeHandlers.clear();\n    }\n\n    protected static _notifyParent(parent: Window, url: string, keepOpen = false, targetOrigin = window.location.origin): void {\n        parent.postMessage({\n            source: messageSource,\n            url,\n            keepOpen,\n        } as MessageData, targetOrigin);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { type OidcClientSettings, OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport type { PopupWindowFeatures } from \"./utils/PopupUtils\";\nimport { WebStorageStateStore } from \"./WebStorageStateStore\";\nimport { InMemoryWebStorage } from \"./InMemoryWebStorage\";\n\nexport const DefaultPopupWindowFeatures: PopupWindowFeatures = {\n    location: false,\n    toolbar: false,\n    height: 640,\n    closePopupWindowAfterInSeconds: -1,\n};\nexport const DefaultPopupTarget = \"_blank\";\nconst DefaultAccessTokenExpiringNotificationTimeInSeconds = 60;\nconst DefaultCheckSessionIntervalInSeconds = 2;\nexport const DefaultSilentRequestTimeoutInSeconds = 10;\n\n/**\n * The settings used to configure the {@link UserManager}.\n *\n * @public\n */\nexport interface UserManagerSettings extends OidcClientSettings {\n    /** The URL for the page containing the call to signinPopupCallback to handle the callback from the OIDC/OAuth2 */\n    popup_redirect_uri?: string;\n    popup_post_logout_redirect_uri?: string;\n    /**\n     * The features parameter to window.open for the popup signin window. By default, the popup is\n     * placed centered in front of the window opener.\n     * (default: \\{ location: false, menubar: false, height: 640, closePopupWindowAfterInSeconds: -1 \\})\n     */\n    popupWindowFeatures?: PopupWindowFeatures;\n    /** The target parameter to window.open for the popup signin window (default: \"_blank\") */\n    popupWindowTarget?: string;\n    /** The methods window.location method used to redirect (default: \"assign\") */\n    redirectMethod?: \"replace\" | \"assign\";\n    /** The methods target window being redirected (default: \"self\") */\n    redirectTarget?: \"top\" | \"self\";\n\n    /** The target to pass while calling postMessage inside iframe for callback (default: window.location.origin) */\n    iframeNotifyParentOrigin?: string;\n\n    /** The script origin to check during 'message' callback execution while performing silent auth via iframe (default: window.location.origin) */\n    iframeScriptOrigin?: string;\n\n    /** The URL for the page containing the code handling the silent renew */\n    silent_redirect_uri?: string;\n    /** Number of seconds to wait for the silent renew to return before assuming it has failed or timed out (default: 10) */\n    silentRequestTimeoutInSeconds?: number;\n    /** Flag to indicate if there should be an automatic attempt to renew the access token prior to its expiration. The automatic renew attempt starts 1 minute before the access token expires (default: true) */\n    automaticSilentRenew?: boolean;\n    /** Flag to validate user.profile.sub in silent renew calls (default: true) */\n    validateSubOnSilentRenew?: boolean;\n    /** Flag to control if id_token is included as id_token_hint in silent renew calls (default: false) */\n    includeIdTokenInSilentRenew?: boolean;\n\n    /** Will raise events for when user has performed a signout at the OP (default: false) */\n    monitorSession?: boolean;\n    monitorAnonymousSession?: boolean;\n    /** Interval in seconds to check the user's session (default: 2) */\n    checkSessionIntervalInSeconds?: number;\n    query_status_response_type?: string;\n    stopCheckSessionOnError?: boolean;\n\n    /**\n     * The `token_type_hint`s to pass to the authority server by default (default: [\"access_token\", \"refresh_token\"])\n     *\n     * Token types will be revoked in the same order as they are given here.\n     */\n    revokeTokenTypes?: (\"access_token\" | \"refresh_token\")[];\n    /** Will invoke the revocation endpoint on signout if there is an access token for the user (default: false) */\n    revokeTokensOnSignout?: boolean;\n    /** Flag to control if id_token is included as id_token_hint in silent signout calls (default: false) */\n    includeIdTokenInSilentSignout?: boolean;\n\n    /** The number of seconds before an access token is to expire to raise the accessTokenExpiring event (default: 60) */\n    accessTokenExpiringNotificationTimeInSeconds?: number;\n\n    /**\n     * Storage object used to persist User for currently authenticated user (default: window.sessionStorage, InMemoryWebStorage iff no window).\n     *  E.g. `userStore: new WebStorageStateStore({ store: window.localStorage })`\n     */\n    userStore?: WebStorageStateStore;\n}\n\n/**\n * The settings with defaults applied of the {@link UserManager}.\n * @see {@link UserManagerSettings}\n *\n * @public\n */\nexport class UserManagerSettingsStore extends OidcClientSettingsStore {\n    public readonly popup_redirect_uri: string;\n    public readonly popup_post_logout_redirect_uri: string | undefined;\n    public readonly popupWindowFeatures: PopupWindowFeatures;\n    public readonly popupWindowTarget: string;\n    public readonly redirectMethod: \"replace\" | \"assign\";\n    public readonly redirectTarget: \"top\" | \"self\";\n\n    public readonly iframeNotifyParentOrigin: string | undefined;\n    public readonly iframeScriptOrigin: string | undefined;\n\n    public readonly silent_redirect_uri: string;\n    public readonly silentRequestTimeoutInSeconds: number;\n    public readonly automaticSilentRenew: boolean;\n    public readonly validateSubOnSilentRenew: boolean;\n    public readonly includeIdTokenInSilentRenew: boolean;\n\n    public readonly monitorSession: boolean;\n    public readonly monitorAnonymousSession: boolean;\n    public readonly checkSessionIntervalInSeconds: number;\n    public readonly query_status_response_type: string;\n    public readonly stopCheckSessionOnError: boolean;\n\n    public readonly revokeTokenTypes: (\"access_token\" | \"refresh_token\")[];\n    public readonly revokeTokensOnSignout: boolean;\n    public readonly includeIdTokenInSilentSignout: boolean;\n\n    public readonly accessTokenExpiringNotificationTimeInSeconds: number;\n\n    public readonly userStore: WebStorageStateStore;\n\n    public constructor(args: UserManagerSettings) {\n        const {\n            popup_redirect_uri = args.redirect_uri,\n            popup_post_logout_redirect_uri = args.post_logout_redirect_uri,\n            popupWindowFeatures = DefaultPopupWindowFeatures,\n            popupWindowTarget = DefaultPopupTarget,\n            redirectMethod = \"assign\",\n            redirectTarget = \"self\",\n\n            iframeNotifyParentOrigin = args.iframeNotifyParentOrigin,\n            iframeScriptOrigin = args.iframeScriptOrigin,\n\n            silent_redirect_uri = args.redirect_uri,\n            silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds,\n            automaticSilentRenew = true,\n            validateSubOnSilentRenew = true,\n            includeIdTokenInSilentRenew = false,\n\n            monitorSession = false,\n            monitorAnonymousSession = false,\n            checkSessionIntervalInSeconds = DefaultCheckSessionIntervalInSeconds,\n            query_status_response_type = \"code\",\n            stopCheckSessionOnError = true,\n\n            revokeTokenTypes = [\"access_token\", \"refresh_token\"],\n            revokeTokensOnSignout = false,\n            includeIdTokenInSilentSignout = false,\n\n            accessTokenExpiringNotificationTimeInSeconds = DefaultAccessTokenExpiringNotificationTimeInSeconds,\n\n            userStore,\n        } = args;\n\n        super(args);\n\n        this.popup_redirect_uri = popup_redirect_uri;\n        this.popup_post_logout_redirect_uri = popup_post_logout_redirect_uri;\n        this.popupWindowFeatures = popupWindowFeatures;\n        this.popupWindowTarget = popupWindowTarget;\n        this.redirectMethod = redirectMethod;\n        this.redirectTarget = redirectTarget;\n\n        this.iframeNotifyParentOrigin = iframeNotifyParentOrigin;\n        this.iframeScriptOrigin = iframeScriptOrigin;\n\n        this.silent_redirect_uri = silent_redirect_uri;\n        this.silentRequestTimeoutInSeconds = silentRequestTimeoutInSeconds;\n        this.automaticSilentRenew = automaticSilentRenew;\n        this.validateSubOnSilentRenew = validateSubOnSilentRenew;\n        this.includeIdTokenInSilentRenew = includeIdTokenInSilentRenew;\n\n        this.monitorSession = monitorSession;\n        this.monitorAnonymousSession = monitorAnonymousSession;\n        this.checkSessionIntervalInSeconds = checkSessionIntervalInSeconds;\n        this.stopCheckSessionOnError = stopCheckSessionOnError;\n        this.query_status_response_type = query_status_response_type;\n\n        this.revokeTokenTypes = revokeTokenTypes;\n        this.revokeTokensOnSignout = revokeTokensOnSignout;\n        this.includeIdTokenInSilentSignout = includeIdTokenInSilentSignout;\n\n        this.accessTokenExpiringNotificationTimeInSeconds = accessTokenExpiringNotificationTimeInSeconds;\n\n        if (userStore) {\n            this.userStore = userStore;\n        }\n        else {\n            const store = typeof window !== \"undefined\" ? window.sessionStorage : new InMemoryWebStorage();\n            this.userStore = new WebStorageStateStore({ store });\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport { ErrorTimeout } from \"../errors\";\nimport type { NavigateParams, NavigateResponse } from \"./IWindow\";\nimport { AbstractChildWindow } from \"./AbstractChildWindow\";\nimport { DefaultSilentRequestTimeoutInSeconds } from \"../UserManagerSettings\";\n\n/**\n * @public\n */\nexport interface IFrameWindowParams {\n    silentRequestTimeoutInSeconds?: number;\n}\n\n/**\n * @internal\n */\nexport class IFrameWindow extends AbstractChildWindow {\n    protected readonly _logger = new Logger(\"IFrameWindow\");\n    private _frame: HTMLIFrameElement | null;\n    private _timeoutInSeconds: number;\n\n    public constructor({\n        silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds,\n    }: IFrameWindowParams) {\n        super();\n        this._timeoutInSeconds = silentRequestTimeoutInSeconds;\n\n        this._frame = IFrameWindow.createHiddenIframe();\n        this._window = this._frame.contentWindow;\n    }\n\n    private static createHiddenIframe(): HTMLIFrameElement {\n        const iframe = window.document.createElement(\"iframe\");\n\n        // shotgun approach\n        iframe.style.visibility = \"hidden\";\n        iframe.style.position = \"fixed\";\n        iframe.style.left = \"-1000px\";\n        iframe.style.top = \"0\";\n        iframe.width = \"0\";\n        iframe.height = \"0\";\n\n        window.document.body.appendChild(iframe);\n        return iframe;\n    }\n\n    public async navigate(params: NavigateParams): Promise<NavigateResponse> {\n        this._logger.debug(\"navigate: Using timeout of:\", this._timeoutInSeconds);\n        const timer = setTimeout(() => this._abort.raise(new ErrorTimeout(\"IFrame timed out without a response\")), this._timeoutInSeconds * 1000);\n        this._disposeHandlers.add(() => clearTimeout(timer));\n\n        return await super.navigate(params);\n    }\n\n    public close(): void {\n        if (this._frame) {\n            if (this._frame.parentNode) {\n                this._frame.addEventListener(\"load\", (ev) => {\n                    const frame = ev.target as HTMLIFrameElement;\n                    frame.parentNode?.removeChild(frame);\n                    this._abort.raise(new Error(\"IFrame removed from DOM\"));\n                }, true);\n                this._frame.contentWindow?.location.replace(\"about:blank\");\n            }\n            this._frame = null;\n        }\n        this._window = null;\n    }\n\n    public static notifyParent(url: string, targetOrigin?: string): void {\n        return super._notifyParent(window.parent, url, false, targetOrigin);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport type { UserManagerSettingsStore } from \"../UserManagerSettings\";\nimport { IFrameWindow, type IFrameWindowParams } from \"./IFrameWindow\";\nimport type { INavigator } from \"./INavigator\";\n\n/**\n * @internal\n */\nexport class IFrameNavigator implements INavigator {\n    private readonly _logger = new Logger(\"IFrameNavigator\");\n\n    constructor(private _settings: UserManagerSettingsStore) {}\n\n    public async prepare({\n        silentRequestTimeoutInSeconds = this._settings.silentRequestTimeoutInSeconds,\n    }: IFrameWindowParams): Promise<IFrameWindow> {\n        return new IFrameWindow({ silentRequestTimeoutInSeconds });\n    }\n\n    public async callback(url: string): Promise<void> {\n        this._logger.create(\"callback\");\n        IFrameWindow.notifyParent(url, this._settings.iframeNotifyParentOrigin);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, PopupUtils, type PopupWindowFeatures } from \"../utils\";\nimport { DefaultPopupWindowFeatures, DefaultPopupTarget } from \"../UserManagerSettings\";\nimport { AbstractChildWindow } from \"./AbstractChildWindow\";\nimport type { NavigateParams, NavigateResponse } from \"./IWindow\";\n\nconst checkForPopupClosedInterval = 500;\nconst second = 1000;\n\n/**\n * @public\n */\nexport interface PopupWindowParams {\n    popupWindowFeatures?: PopupWindowFeatures;\n    popupWindowTarget?: string;\n}\n\n/**\n * @internal\n */\nexport class PopupWindow extends AbstractChildWindow {\n    protected readonly _logger = new Logger(\"PopupWindow\");\n\n    protected _window: WindowProxy | null;\n\n    public constructor({\n        popupWindowTarget = DefaultPopupTarget,\n        popupWindowFeatures = {},\n    }: PopupWindowParams) {\n        super();\n        const centeredPopup = PopupUtils.center({ ...DefaultPopupWindowFeatures, ...popupWindowFeatures });\n        this._window = window.open(undefined, popupWindowTarget, PopupUtils.serialize(centeredPopup));\n        if (popupWindowFeatures.closePopupWindowAfterInSeconds && popupWindowFeatures.closePopupWindowAfterInSeconds > 0) {\n            setTimeout(() => {\n                if (!this._window || typeof this._window.closed !== \"boolean\" || this._window.closed) {\n                    this._abort.raise(new Error(\"Popup blocked by user\"));\n                    return;\n                }\n\n                this.close();\n            }, popupWindowFeatures.closePopupWindowAfterInSeconds * second);\n        }\n    }\n\n    public async navigate(params: NavigateParams): Promise<NavigateResponse> {\n        this._window?.focus();\n\n        const popupClosedInterval = setInterval(() => {\n            if (!this._window || this._window.closed) {\n                this._abort.raise(new Error(\"Popup closed by user\"));\n            }\n        }, checkForPopupClosedInterval);\n        this._disposeHandlers.add(() => clearInterval(popupClosedInterval));\n\n        return await super.navigate(params);\n    }\n\n    public close(): void {\n        if (this._window) {\n            if (!this._window.closed) {\n                this._window.close();\n                this._abort.raise(new Error(\"Popup closed\"));\n            }\n        }\n        this._window = null;\n    }\n\n    public static notifyOpener(url: string, keepOpen: boolean): void {\n        if (!window.opener) {\n            throw new Error(\"No window.opener. Can't complete notification.\");\n        }\n        return super._notifyParent(window.opener, url, keepOpen);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport { PopupWindow, type PopupWindowParams } from \"./PopupWindow\";\nimport type { INavigator } from \"./INavigator\";\nimport type { UserManagerSettingsStore } from \"../UserManagerSettings\";\n\n/**\n * @internal\n */\nexport class PopupNavigator implements INavigator {\n    private readonly _logger = new Logger(\"PopupNavigator\");\n\n    constructor(private _settings: UserManagerSettingsStore) {}\n\n    public async prepare({\n        popupWindowFeatures = this._settings.popupWindowFeatures,\n        popupWindowTarget = this._settings.popupWindowTarget,\n    }: PopupWindowParams): Promise<PopupWindow> {\n        return new PopupWindow({ popupWindowFeatures, popupWindowTarget });\n    }\n\n    public async callback(url: string, { keepOpen = false }): Promise<void> {\n        this._logger.create(\"callback\");\n\n        PopupWindow.notifyOpener(url, keepOpen);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport type { UserManagerSettingsStore } from \"../UserManagerSettings\";\nimport type { INavigator } from \"./INavigator\";\nimport type { IWindow } from \"./IWindow\";\n\n/**\n * @public\n */\nexport interface RedirectParams {\n    redirectMethod?: \"replace\" | \"assign\";\n    redirectTarget?: \"top\" | \"self\";\n}\n\n/**\n * @internal\n */\nexport class RedirectNavigator implements INavigator {\n    private readonly _logger = new Logger(\"RedirectNavigator\");\n\n    constructor(private _settings: UserManagerSettingsStore) {}\n\n    public async prepare({\n        redirectMethod = this._settings.redirectMethod,\n        redirectTarget = this._settings.redirectTarget,\n    }: RedirectParams): Promise<IWindow> {\n        this._logger.create(\"prepare\");\n        let targetWindow = window.self as Window;\n\n        if (redirectTarget === \"top\") {\n            targetWindow = window.top ?? window.self;\n        }\n    \n        const redirect = targetWindow.location[redirectMethod].bind(targetWindow.location) as (url: string) => never;\n        let abort: (reason: Error) => void;\n        return {\n            navigate: async (params): Promise<never> => {\n                this._logger.create(\"navigate\");\n                // We use a promise that never resolves to block the caller\n                const promise = new Promise((resolve, reject) => {\n                    abort = reject;\n                });\n                redirect(params.url);\n                return await (promise as Promise<never>);\n            },\n            close: () => {\n                this._logger.create(\"close\");\n                abort?.(new Error(\"Redirect aborted\"));\n                targetWindow.stop();\n            },\n        };\n    }\n\n    public async callback(): Promise<void> {\n        return;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Event } from \"./utils\";\nimport { AccessTokenEvents } from \"./AccessTokenEvents\";\nimport type { UserManagerSettingsStore } from \"./UserManagerSettings\";\nimport type { User } from \"./User\";\n\n/**\n * @public\n */\nexport type UserLoadedCallback = (user: User) => Promise<void> | void;\n/**\n * @public\n */\nexport type UserUnloadedCallback = () => Promise<void> | void;\n/**\n * @public\n */\nexport type SilentRenewErrorCallback = (error: Error) => Promise<void> | void;\n/**\n * @public\n */\nexport type UserSignedInCallback = () => Promise<void> | void;\n/**\n * @public\n */\nexport type UserSignedOutCallback = () => Promise<void> | void;\n/**\n * @public\n */\nexport type UserSessionChangedCallback = () => Promise<void> | void;\n\n/**\n * @public\n */\nexport class UserManagerEvents extends AccessTokenEvents {\n    protected readonly _logger = new Logger(\"UserManagerEvents\");\n\n    private readonly _userLoaded = new Event<[User]>(\"User loaded\");\n    private readonly _userUnloaded = new Event<[]>(\"User unloaded\");\n    private readonly _silentRenewError = new Event<[Error]>(\"Silent renew error\");\n    private readonly _userSignedIn = new Event<[]>(\"User signed in\");\n    private readonly _userSignedOut = new Event<[]>(\"User signed out\");\n    private readonly _userSessionChanged = new Event<[]>(\"User session changed\");\n\n    public constructor(settings: UserManagerSettingsStore) {\n        super({ expiringNotificationTimeInSeconds: settings.accessTokenExpiringNotificationTimeInSeconds });\n    }\n\n    public load(user: User, raiseEvent=true): void {\n        super.load(user);\n        if (raiseEvent) {\n            this._userLoaded.raise(user);\n        }\n    }\n    public unload(): void {\n        super.unload();\n        this._userUnloaded.raise();\n    }\n\n    /**\n     * Add callback: Raised when a user session has been established (or re-established).\n     */\n    public addUserLoaded(cb: UserLoadedCallback): () => void {\n        return this._userLoaded.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when a user session has been established (or re-established).\n     */\n    public removeUserLoaded(cb: UserLoadedCallback): void {\n        return this._userLoaded.removeHandler(cb);\n    }\n\n    /**\n     * Add callback: Raised when a user session has been terminated.\n     */\n    public addUserUnloaded(cb: UserUnloadedCallback): () => void {\n        return this._userUnloaded.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when a user session has been terminated.\n     */\n    public removeUserUnloaded(cb: UserUnloadedCallback): void {\n        return this._userUnloaded.removeHandler(cb);\n    }\n\n    /**\n     * Add callback: Raised when the automatic silent renew has failed.\n     */\n    public addSilentRenewError(cb: SilentRenewErrorCallback): () => void {\n        return this._silentRenewError.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the automatic silent renew has failed.\n     */\n    public removeSilentRenewError(cb: SilentRenewErrorCallback): void {\n        return this._silentRenewError.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public _raiseSilentRenewError(e: Error): void {\n        this._silentRenewError.raise(e);\n    }\n\n    /**\n     * Add callback: Raised when the user is signed in (when `monitorSession` is set).\n     * @see {@link UserManagerSettings.monitorSession}\n     */\n    public addUserSignedIn(cb: UserSignedInCallback): () => void {\n        return this._userSignedIn.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the user is signed in (when `monitorSession` is set).\n     */\n    public removeUserSignedIn(cb: UserSignedInCallback): void {\n        this._userSignedIn.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public _raiseUserSignedIn(): void {\n        this._userSignedIn.raise();\n    }\n\n    /**\n     * Add callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n     * @see {@link UserManagerSettings.monitorSession}\n     */\n    public addUserSignedOut(cb: UserSignedOutCallback): () => void {\n        return this._userSignedOut.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n     */\n    public removeUserSignedOut(cb: UserSignedOutCallback): void {\n        this._userSignedOut.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public _raiseUserSignedOut(): void {\n        this._userSignedOut.raise();\n    }\n\n    /**\n     * Add callback: Raised when the user session changed (when `monitorSession` is set).\n     * @see {@link UserManagerSettings.monitorSession}\n     */\n    public addUserSessionChanged(cb: UserSessionChangedCallback): () => void {\n        return this._userSessionChanged.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the user session changed (when `monitorSession` is set).\n     */\n    public removeUserSessionChanged(cb: UserSessionChangedCallback): void {\n        this._userSessionChanged.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public _raiseUserSessionChanged(): void {\n        this._userSessionChanged.raise();\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Timer } from \"./utils\";\nimport { ErrorTimeout } from \"./errors\";\nimport type { UserManager } from \"./UserManager\";\nimport type { AccessTokenCallback } from \"./AccessTokenEvents\";\n\n/**\n * @internal\n */\nexport class SilentRenewService {\n    protected _logger = new Logger(\"SilentRenewService\");\n    private _isStarted = false;\n    private readonly _retryTimer = new Timer(\"Retry Silent Renew\");\n\n    public constructor(private _userManager: UserManager) {}\n\n    public async start(): Promise<void> {\n        const logger = this._logger.create(\"start\");\n        if (!this._isStarted) {\n            this._isStarted = true;\n            this._userManager.events.addAccessTokenExpiring(this._tokenExpiring);\n            this._retryTimer.addHandler(this._tokenExpiring);\n\n            // this will trigger loading of the user so the expiring events can be initialized\n            try {\n                await this._userManager.getUser();\n                // deliberate nop\n            }\n            catch (err) {\n                // catch to suppress errors since we're in a ctor\n                logger.error(\"getUser error\", err);\n            }\n        }\n    }\n\n    public stop(): void {\n        if (this._isStarted) {\n            this._retryTimer.cancel();\n            this._retryTimer.removeHandler(this._tokenExpiring);\n            this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring);\n            this._isStarted = false;\n        }\n    }\n\n    protected _tokenExpiring: AccessTokenCallback = async () => {\n        const logger = this._logger.create(\"_tokenExpiring\");\n        try {\n            await this._userManager.signinSilent();\n            logger.debug(\"silent token renewal successful\");\n        }\n        catch (err) {\n            if (err instanceof ErrorTimeout) {\n                // no response from authority server, e.g. IFrame timeout, ...\n                logger.warn(\"ErrorTimeout from signinSilent:\", err, \"retry in 5s\");\n                this._retryTimer.init(5);\n                return;\n            }\n\n            logger.error(\"Error from signinSilent:\", err);\n            this._userManager.events._raiseSilentRenewError(err as Error);\n        }\n    };\n}\n","// Copyright (C) AuthTS Contributors\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport type { UserProfile } from \"./User\";\n\n/**\n * Fake state store implementation necessary for validating refresh token requests.\n *\n * @public\n */\nexport class RefreshState {\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    public readonly data?: unknown;\n\n    public readonly refresh_token: string;\n    public readonly id_token?: string;\n    public readonly session_state: string | null;\n    public readonly scope?: string;\n    public readonly profile: UserProfile;\n    public readonly resource?: string | string[];\n\n    constructor(args: {\n        refresh_token: string;\n        id_token?: string;\n        session_state: string | null;\n        scope?: string;\n        profile: UserProfile;\n\n        state?: unknown;\n    }, resource?: string | string[]) {\n        this.refresh_token = args.refresh_token;\n        this.id_token = args.id_token;\n        this.session_state = args.session_state;\n        this.scope = args.scope;\n        this.profile = args.profile;\n        this.resource = resource;\n\n        this.data = args.state;\n\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { ErrorResponse } from \"./errors\";\nimport { type NavigateResponse, type PopupWindowParams, type IWindow, type IFrameWindowParams, type RedirectParams, RedirectNavigator, PopupNavigator, IFrameNavigator, type INavigator } from \"./navigators\";\nimport { OidcClient, type CreateSigninRequestArgs, type CreateSignoutRequestArgs, type ProcessResourceOwnerPasswordCredentialsArgs } from \"./OidcClient\";\nimport { type UserManagerSettings, UserManagerSettingsStore } from \"./UserManagerSettings\";\nimport { User } from \"./User\";\nimport { UserManagerEvents } from \"./UserManagerEvents\";\nimport { SilentRenewService } from \"./SilentRenewService\";\nimport { SessionMonitor } from \"./SessionMonitor\";\nimport type { SessionStatus } from \"./SessionStatus\";\nimport type { SignoutResponse } from \"./SignoutResponse\";\nimport type { MetadataService } from \"./MetadataService\";\nimport { RefreshState } from \"./RefreshState\";\nimport type { SigninResponse } from \"./SigninResponse\";\n\n/**\n * @public\n */\nexport type ExtraSigninRequestArgs = Pick<CreateSigninRequestArgs, \"nonce\" | \"extraQueryParams\" | \"extraTokenParams\" | \"state\" | \"redirect_uri\" | \"prompt\" | \"acr_values\" | \"login_hint\" | \"scope\" | \"max_age\" | \"ui_locales\" | \"resource\" | \"url_state\">;\n/**\n * @public\n */\nexport type ExtraSignoutRequestArgs = Pick<CreateSignoutRequestArgs, \"extraQueryParams\" | \"state\" | \"id_token_hint\" | \"post_logout_redirect_uri\">;\n\n/**\n * @public\n */\nexport type RevokeTokensTypes = UserManagerSettings[\"revokeTokenTypes\"];\n\n/**\n * @public\n */\nexport type SigninRedirectArgs = RedirectParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SigninPopupArgs = PopupWindowParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SigninSilentArgs = IFrameWindowParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SigninResourceOwnerCredentialsArgs = ProcessResourceOwnerPasswordCredentialsArgs;\n\n/**\n * @public\n */\nexport type QuerySessionStatusArgs = IFrameWindowParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SignoutRedirectArgs = RedirectParams & ExtraSignoutRequestArgs;\n\n/**\n * @public\n */\nexport type SignoutPopupArgs = PopupWindowParams & ExtraSignoutRequestArgs;\n\n/**\n * @public\n */\nexport type SignoutSilentArgs = IFrameWindowParams & ExtraSignoutRequestArgs;\n\n/**\n * Provides a higher level API for signing a user in, signing out, managing the user's claims returned from the OIDC provider,\n * and managing an access token returned from the OIDC/OAuth2 provider.\n *\n * @public\n */\nexport class UserManager {\n    /** Returns the settings used to configure the `UserManager`. */\n    public readonly settings: UserManagerSettingsStore;\n    protected readonly _logger = new Logger(\"UserManager\");\n\n    protected readonly _client: OidcClient;\n    protected readonly _redirectNavigator: INavigator;\n    protected readonly _popupNavigator: INavigator;\n    protected readonly _iframeNavigator: INavigator;\n    protected readonly _events: UserManagerEvents;\n    protected readonly _silentRenewService: SilentRenewService;\n    protected readonly _sessionMonitor: SessionMonitor | null;\n\n    public constructor(settings: UserManagerSettings, redirectNavigator?: INavigator, popupNavigator?: INavigator, iframeNavigator?: INavigator) {\n        this.settings = new UserManagerSettingsStore(settings);\n\n        this._client = new OidcClient(settings);\n\n        this._redirectNavigator = redirectNavigator ?? new RedirectNavigator(this.settings);\n        this._popupNavigator = popupNavigator ?? new PopupNavigator(this.settings);\n        this._iframeNavigator = iframeNavigator ?? new IFrameNavigator(this.settings);\n\n        this._events = new UserManagerEvents(this.settings);\n        this._silentRenewService = new SilentRenewService(this);\n\n        // order is important for the following properties; these services depend upon the events.\n        if (this.settings.automaticSilentRenew) {\n            this.startSilentRenew();\n        }\n\n        this._sessionMonitor = null;\n        if (this.settings.monitorSession) {\n            this._sessionMonitor = new SessionMonitor(this);\n        }\n\n    }\n\n    /** Returns an object used to register for events raised by the `UserManager`. */\n    public get events(): UserManagerEvents {\n        return this._events;\n    }\n\n    /** Returns an object used to access the metadata configuration of the OIDC provider. */\n    public get metadataService(): MetadataService {\n        return this._client.metadataService;\n    }\n\n    /**\n     * Returns promise to load the `User` object for the currently authenticated user.\n     */\n    public async getUser(): Promise<User | null> {\n        const logger = this._logger.create(\"getUser\");\n        const user = await this._loadUser();\n        if (user) {\n            logger.info(\"user loaded\");\n            this._events.load(user, false);\n            return user;\n        }\n\n        logger.info(\"user not found in storage\");\n        return null;\n    }\n\n    /**\n     * Returns promise to remove from any storage the currently authenticated user.\n     */\n    public async removeUser(): Promise<void> {\n        const logger = this._logger.create(\"removeUser\");\n        await this.storeUser(null);\n        logger.info(\"user removed from storage\");\n        this._events.unload();\n    }\n\n    /**\n     * Returns promise to trigger a redirect of the current window to the authorization endpoint.\n     */\n    public async signinRedirect(args: SigninRedirectArgs = {}): Promise<void> {\n        this._logger.create(\"signinRedirect\");\n        const {\n            redirectMethod,\n            ...requestArgs\n        } = args;\n        const handle = await this._redirectNavigator.prepare({ redirectMethod });\n        await this._signinStart({\n            request_type: \"si:r\",\n            ...requestArgs,\n        }, handle);\n    }\n\n    /**\n     * Returns promise to process response from the authorization endpoint. The result of the promise is the authenticated `User`.\n     */\n    public async signinRedirectCallback(url = window.location.href): Promise<User> {\n        const logger = this._logger.create(\"signinRedirectCallback\");\n        const user = await this._signinEnd(url);\n        if (user.profile && user.profile.sub) {\n            logger.info(\"success, signed in subject\", user.profile.sub);\n        }\n        else {\n            logger.info(\"no subject\");\n        }\n\n        return user;\n    }\n\n    /**\n     * Returns promise to process the signin with user/password. The result of the promise is the authenticated `User`.\n     *\n     * Throws an ErrorResponse in case of wrong authentication.\n     */\n    public async signinResourceOwnerCredentials({\n        username,\n        password,\n        skipUserInfo = false,\n    }: SigninResourceOwnerCredentialsArgs ) {\n        const logger = this._logger.create(\"signinResourceOwnerCredential\");\n\n        const signinResponse = await this._client.processResourceOwnerPasswordCredentials({ username, password, skipUserInfo, extraTokenParams: this.settings.extraTokenParams });\n        logger.debug(\"got signin response\");\n\n        const user = await this._buildUser(signinResponse);\n        if (user.profile && user.profile.sub) {\n            logger.info(\"success, signed in subject\", user.profile.sub);\n        } else {\n            logger.info(\"no subject\");\n        }\n        return user;\n    }\n\n    /**\n     * Returns promise to trigger a request (via a popup window) to the authorization endpoint. The result of the promise is the authenticated `User`.\n     */\n    public async signinPopup(args: SigninPopupArgs = {}): Promise<User> {\n        const logger = this._logger.create(\"signinPopup\");\n        const {\n            popupWindowFeatures,\n            popupWindowTarget,\n            ...requestArgs\n        } = args;\n        const url = this.settings.popup_redirect_uri;\n        if (!url) {\n            logger.throw(new Error(\"No popup_redirect_uri configured\"));\n        }\n\n        const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget });\n        const user = await this._signin({\n            request_type: \"si:p\",\n            redirect_uri: url,\n            display: \"popup\",\n            ...requestArgs,\n        }, handle);\n        if (user) {\n            if (user.profile && user.profile.sub) {\n                logger.info(\"success, signed in subject\", user.profile.sub);\n            }\n            else {\n                logger.info(\"no subject\");\n            }\n        }\n\n        return user;\n    }\n    /**\n     * Returns promise to notify the opening window of response from the authorization endpoint.\n     */\n    public async signinPopupCallback(url = window.location.href, keepOpen = false): Promise<void> {\n        const logger = this._logger.create(\"signinPopupCallback\");\n        await this._popupNavigator.callback(url, { keepOpen });\n        logger.info(\"success\");\n    }\n\n    /**\n     * Returns promise to trigger a silent request (via an iframe) to the authorization endpoint.\n     * The result of the promise is the authenticated `User`.\n     */\n    public async signinSilent(args: SigninSilentArgs = {}): Promise<User | null> {\n        const logger = this._logger.create(\"signinSilent\");\n        const {\n            silentRequestTimeoutInSeconds,\n            resource,\n            ...requestArgs\n        } = args;\n        // first determine if we have a refresh token, or need to use iframe\n        let user = await this._loadUser();\n        if (user?.refresh_token) {\n            logger.debug(\"using refresh token\");\n            const state = new RefreshState(user as Required<User>, resource);\n            return await this._useRefreshToken(state);\n        }\n\n        const url = this.settings.silent_redirect_uri;\n        if (!url) {\n            logger.throw(new Error(\"No silent_redirect_uri configured\"));\n        }\n\n        let verifySub: string | undefined;\n        if (user && this.settings.validateSubOnSilentRenew) {\n            logger.debug(\"subject prior to silent renew:\", user.profile.sub);\n            verifySub = user.profile.sub;\n        }\n\n        const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n        user = await this._signin({\n            request_type: \"si:s\",\n            redirect_uri: url,\n            prompt: \"none\",\n            id_token_hint: this.settings.includeIdTokenInSilentRenew ? user?.id_token : undefined,\n            ...requestArgs,\n        }, handle, verifySub);\n        if (user) {\n            if (user.profile?.sub) {\n                logger.info(\"success, signed in subject\", user.profile.sub);\n            }\n            else {\n                logger.info(\"no subject\");\n            }\n        }\n\n        return user;\n    }\n\n    protected async _useRefreshToken(state: RefreshState): Promise<User> {\n        const response = await this._client.useRefreshToken({\n            state,\n            timeoutInSeconds: this.settings.silentRequestTimeoutInSeconds,\n        });\n        const user = new User({ ...state, ...response });\n\n        await this.storeUser(user);\n        this._events.load(user);\n        return user;\n    }\n\n    /**\n     * Returns promise to notify the parent window of response from the authorization endpoint.\n     */\n    public async signinSilentCallback(url = window.location.href): Promise<void> {\n        const logger = this._logger.create(\"signinSilentCallback\");\n        await this._iframeNavigator.callback(url);\n        logger.info(\"success\");\n    }\n\n    public async signinCallback(url = window.location.href): Promise<User | void> {\n        const { state } = await this._client.readSigninResponseState(url);\n        switch (state.request_type) {\n            case \"si:r\":\n                return await this.signinRedirectCallback(url);\n            case \"si:p\":\n                return await this.signinPopupCallback(url);\n            case \"si:s\":\n                return await this.signinSilentCallback(url);\n            default:\n                throw new Error(\"invalid response_type in state\");\n        }\n    }\n\n    public async signoutCallback(url = window.location.href, keepOpen = false): Promise<SignoutResponse | void> {\n        const { state } = await this._client.readSignoutResponseState(url);\n        if (!state) {\n            return undefined;\n        }\n\n        switch (state.request_type) {\n            case \"so:r\":\n                return await this.signoutRedirectCallback(url);\n            case \"so:p\":\n                await this.signoutPopupCallback(url, keepOpen);\n                break;\n            case \"so:s\":\n                await this.signoutSilentCallback(url);\n                break;\n            default:\n                throw new Error(\"invalid response_type in state\");\n        }\n        return undefined;\n    }\n\n    /**\n     * Returns promise to query OP for user's current signin status. Returns object with session_state and subject identifier.\n     */\n    public async querySessionStatus(args: QuerySessionStatusArgs = {}): Promise<SessionStatus | null> {\n        const logger = this._logger.create(\"querySessionStatus\");\n        const {\n            silentRequestTimeoutInSeconds,\n            ...requestArgs\n        } = args;\n        const url = this.settings.silent_redirect_uri;\n        if (!url) {\n            logger.throw(new Error(\"No silent_redirect_uri configured\"));\n        }\n\n        const user = await this._loadUser();\n        const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n        const navResponse = await this._signinStart({\n            request_type: \"si:s\", // this acts like a signin silent\n            redirect_uri: url,\n            prompt: \"none\",\n            id_token_hint: this.settings.includeIdTokenInSilentRenew ? user?.id_token : undefined,\n            response_type: this.settings.query_status_response_type,\n            scope: \"openid\",\n            skipUserInfo: true,\n            ...requestArgs,\n        }, handle);\n        try {\n            const signinResponse = await this._client.processSigninResponse(navResponse.url);\n            logger.debug(\"got signin response\");\n\n            if (signinResponse.session_state && signinResponse.profile.sub) {\n                logger.info(\"success for subject\", signinResponse.profile.sub);\n                return {\n                    session_state: signinResponse.session_state,\n                    sub: signinResponse.profile.sub,\n                    sid: signinResponse.profile.sid,\n                };\n            }\n\n            logger.info(\"success, user not authenticated\");\n            return null;\n        }\n        catch (err) {\n            if (this.settings.monitorAnonymousSession && err instanceof ErrorResponse) {\n                switch (err.error) {\n                    case \"login_required\":\n                    case \"consent_required\":\n                    case \"interaction_required\":\n                    case \"account_selection_required\":\n                        logger.info(\"success for anonymous user\");\n                        return {\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            session_state: err.session_state!,\n                        };\n                }\n            }\n            throw err;\n        }\n    }\n\n    protected async _signin(args: CreateSigninRequestArgs, handle: IWindow, verifySub?: string): Promise<User> {\n        const navResponse = await this._signinStart(args, handle);\n        return await this._signinEnd(navResponse.url, verifySub);\n    }\n    protected async _signinStart(args: CreateSigninRequestArgs, handle: IWindow): Promise<NavigateResponse> {\n        const logger = this._logger.create(\"_signinStart\");\n\n        try {\n            const signinRequest = await this._client.createSigninRequest(args);\n            logger.debug(\"got signin request\");\n\n            return await handle.navigate({\n                url: signinRequest.url,\n                state: signinRequest.state.id,\n                response_mode: signinRequest.state.response_mode,\n                scriptOrigin: this.settings.iframeScriptOrigin,\n            });\n        }\n        catch (err) {\n            logger.debug(\"error after preparing navigator, closing navigator window\");\n            handle.close();\n            throw err;\n        }\n    }\n    protected async _signinEnd(url: string, verifySub?: string): Promise<User> {\n        const logger = this._logger.create(\"_signinEnd\");\n        const signinResponse = await this._client.processSigninResponse(url);\n        logger.debug(\"got signin response\");\n\n        const user = await this._buildUser(signinResponse, verifySub);\n        return user;\n    }\n\n    protected async _buildUser(signinResponse: SigninResponse, verifySub?: string) {\n        const logger = this._logger.create(\"_buildUser\");\n        const user = new User(signinResponse);\n        if (verifySub) {\n            if (verifySub !== user.profile.sub) {\n                logger.debug(\"current user does not match user returned from signin. sub from signin:\", user.profile.sub);\n                throw new ErrorResponse({ ...signinResponse, error: \"login_required\" });\n            }\n            logger.debug(\"current user matches user returned from signin\");\n        }\n\n        await this.storeUser(user);\n        logger.debug(\"user stored\");\n        this._events.load(user);\n\n        return user;\n    }\n\n    /**\n     * Returns promise to trigger a redirect of the current window to the end session endpoint.\n     */\n    public async signoutRedirect(args: SignoutRedirectArgs = {}): Promise<void> {\n        const logger = this._logger.create(\"signoutRedirect\");\n        const {\n            redirectMethod,\n            ...requestArgs\n        } = args;\n        const handle = await this._redirectNavigator.prepare({ redirectMethod });\n        await this._signoutStart({\n            request_type: \"so:r\",\n            post_logout_redirect_uri: this.settings.post_logout_redirect_uri,\n            ...requestArgs,\n        }, handle);\n        logger.info(\"success\");\n    }\n\n    /**\n     * Returns promise to process response from the end session endpoint.\n     */\n    public async signoutRedirectCallback(url = window.location.href): Promise<SignoutResponse> {\n        const logger = this._logger.create(\"signoutRedirectCallback\");\n        const response = await this._signoutEnd(url);\n        logger.info(\"success\");\n        return response;\n    }\n\n    /**\n     * Returns promise to trigger a redirect of a popup window window to the end session endpoint.\n     */\n    public async signoutPopup(args: SignoutPopupArgs = {}): Promise<void> {\n        const logger = this._logger.create(\"signoutPopup\");\n        const {\n            popupWindowFeatures,\n            popupWindowTarget,\n            ...requestArgs\n        } = args;\n        const url = this.settings.popup_post_logout_redirect_uri;\n\n        const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget });\n        await this._signout({\n            request_type: \"so:p\",\n            post_logout_redirect_uri: url,\n            // we're putting a dummy entry in here because we\n            // need a unique id from the state for notification\n            // to the parent window, which is necessary if we\n            // plan to return back to the client after signout\n            // and so we can close the popup after signout\n            state: url == null ? undefined : {},\n            ...requestArgs,\n        }, handle);\n        logger.info(\"success\");\n    }\n\n    /**\n     * Returns promise to process response from the end session endpoint from a popup window.\n     */\n    public async signoutPopupCallback(url = window.location.href, keepOpen = false): Promise<void> {\n        const logger = this._logger.create(\"signoutPopupCallback\");\n        await this._popupNavigator.callback(url, { keepOpen });\n        logger.info(\"success\");\n    }\n\n    protected async _signout(args: CreateSignoutRequestArgs, handle: IWindow): Promise<SignoutResponse> {\n        const navResponse = await this._signoutStart(args, handle);\n        return await this._signoutEnd(navResponse.url);\n    }\n    protected async _signoutStart(args: CreateSignoutRequestArgs = {}, handle: IWindow): Promise<NavigateResponse> {\n        const logger = this._logger.create(\"_signoutStart\");\n\n        try {\n            const user = await this._loadUser();\n            logger.debug(\"loaded current user from storage\");\n\n            if (this.settings.revokeTokensOnSignout) {\n                await this._revokeInternal(user);\n            }\n\n            const id_token = args.id_token_hint || user && user.id_token;\n            if (id_token) {\n                logger.debug(\"setting id_token_hint in signout request\");\n                args.id_token_hint = id_token;\n            }\n\n            await this.removeUser();\n            logger.debug(\"user removed, creating signout request\");\n\n            const signoutRequest = await this._client.createSignoutRequest(args);\n            logger.debug(\"got signout request\");\n\n            return await handle.navigate({\n                url: signoutRequest.url,\n                state: signoutRequest.state?.id,\n                scriptOrigin: this.settings.iframeScriptOrigin,\n            });\n        }\n        catch (err) {\n            logger.debug(\"error after preparing navigator, closing navigator window\");\n            handle.close();\n            throw err;\n        }\n    }\n    protected async _signoutEnd(url: string): Promise<SignoutResponse> {\n        const logger = this._logger.create(\"_signoutEnd\");\n        const signoutResponse = await this._client.processSignoutResponse(url);\n        logger.debug(\"got signout response\");\n\n        return signoutResponse;\n    }\n\n    /**\n     * Returns promise to trigger a silent request (via an iframe) to the end session endpoint.\n     */\n    public async signoutSilent(args: SignoutSilentArgs = {}): Promise<void> {\n        const logger = this._logger.create(\"signoutSilent\");\n        const {\n            silentRequestTimeoutInSeconds,\n            ...requestArgs\n        } = args;\n\n        const id_token_hint = this.settings.includeIdTokenInSilentSignout\n            ? (await this._loadUser())?.id_token\n            : undefined;\n\n        const url = this.settings.popup_post_logout_redirect_uri;\n        const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n        await this._signout({\n            request_type: \"so:s\",\n            post_logout_redirect_uri: url,\n            id_token_hint: id_token_hint,\n            ...requestArgs,\n        }, handle);\n\n        logger.info(\"success\");\n    }\n\n    /**\n     * Returns promise to notify the parent window of response from the end session endpoint.\n     */\n    public async signoutSilentCallback(url = window.location.href): Promise<void> {\n        const logger = this._logger.create(\"signoutSilentCallback\");\n        await this._iframeNavigator.callback(url);\n        logger.info(\"success\");\n    }\n\n    public async revokeTokens(types?: RevokeTokensTypes): Promise<void> {\n        const user = await this._loadUser();\n        await this._revokeInternal(user, types);\n    }\n\n    protected async _revokeInternal(user: User | null, types = this.settings.revokeTokenTypes): Promise<void> {\n        const logger = this._logger.create(\"_revokeInternal\");\n        if (!user) return;\n\n        const typesPresent = types.filter(type => typeof user[type] === \"string\");\n\n        if (!typesPresent.length) {\n            logger.debug(\"no need to revoke due to no token(s)\");\n            return;\n        }\n\n        // don't Promise.all, order matters\n        for (const type of typesPresent) {\n            await this._client.revokeToken(\n                user[type]!, // eslint-disable-line @typescript-eslint/no-non-null-assertion\n                type,\n            );\n            logger.info(`${type} revoked successfully`);\n            if (type !== \"access_token\") {\n                user[type] = null as never;\n            }\n        }\n\n        await this.storeUser(user);\n        logger.debug(\"user stored\");\n        this._events.load(user);\n    }\n\n    /**\n     * Enables silent renew for the `UserManager`.\n     */\n    public startSilentRenew(): void {\n        this._logger.create(\"startSilentRenew\");\n        void this._silentRenewService.start();\n    }\n\n    /**\n     * Disables silent renew for the `UserManager`.\n     */\n    public stopSilentRenew(): void {\n        this._silentRenewService.stop();\n    }\n\n    protected get _userStoreKey(): string {\n        return `user:${this.settings.authority}:${this.settings.client_id}`;\n    }\n\n    protected async _loadUser(): Promise<User | null> {\n        const logger = this._logger.create(\"_loadUser\");\n        const storageString = await this.settings.userStore.get(this._userStoreKey);\n        if (storageString) {\n            logger.debug(\"user storageString loaded\");\n            return User.fromStorageString(storageString);\n        }\n\n        logger.debug(\"no user storageString\");\n        return null;\n    }\n\n    public async storeUser(user: User | null): Promise<void> {\n        const logger = this._logger.create(\"storeUser\");\n        if (user) {\n            logger.debug(\"storing user\");\n            const storageString = user.toStorageString();\n            await this.settings.userStore.set(this._userStoreKey, storageString);\n        }\n        else {\n            this._logger.debug(\"removing user\");\n            await this.settings.userStore.remove(this._userStoreKey);\n        }\n    }\n\n    /**\n     * Removes stale state entries in storage for incomplete authorize requests.\n     */\n    public async clearStaleState(): Promise<void> {\n        await this._client.clearStaleState();\n    }\n}\n","{\n  \"name\": \"oidc-client-ts\",\n  \"version\": \"2.4.1\",\n  \"description\": \"OpenID Connect (OIDC) & OAuth2 client library\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com:authts/oidc-client-ts.git\"\n  },\n  \"homepage\": \"https://github.com/authts/oidc-client-ts#readme\",\n  \"license\": \"Apache-2.0\",\n  \"main\": \"dist/umd/oidc-client-ts.js\",\n  \"types\": \"dist/types/oidc-client-ts.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/types/oidc-client-ts.d.ts\",\n      \"import\": \"./dist/esm/oidc-client-ts.js\",\n      \"require\": \"./dist/umd/oidc-client-ts.js\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"keywords\": [\n    \"authentication\",\n    \"oauth2\",\n    \"oidc\",\n    \"openid\",\n    \"OpenID Connect\"\n  ],\n  \"scripts\": {\n    \"build\": \"node scripts/build.js && npm run build-types\",\n    \"build-types\": \"tsc -p tsconfig.build.json && api-extractor run\",\n    \"clean\": \"git clean -fdX dist lib *.tsbuildinfo\",\n    \"prepack\": \"npm run build\",\n    \"test\": \"tsc && jest\",\n    \"typedoc\": \"typedoc\",\n    \"lint\": \"eslint --max-warnings=0 --cache .\",\n    \"prepare\": \"husky install\"\n  },\n  \"dependencies\": {\n    \"crypto-js\": \"^4.2.0\",\n    \"jwt-decode\": \"^3.1.2\"\n  },\n  \"devDependencies\": {\n    \"@microsoft/api-extractor\": \"^7.35.0\",\n    \"@testing-library/jest-dom\": \"^6.0.0\",\n    \"@types/crypto-js\": \"^4.1.3\",\n    \"@types/jest\": \"^29.2.3\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.4.1\",\n    \"@typescript-eslint/parser\": \"^6.4.1\",\n    \"esbuild\": \"^0.17.0\",\n    \"eslint\": \"^8.5.0\",\n    \"eslint-plugin-testing-library\": \"^6.0.0\",\n    \"http-proxy-middleware\": \"^2.0.1\",\n    \"husky\": \"^8.0.1\",\n    \"jest\": \"^29.3.1\",\n    \"jest-environment-jsdom\": \"^29.3.1\",\n    \"jest-mock\": \"^29.3.1\",\n    \"lint-staged\": \"^15.0.1\",\n    \"ts-jest\": \"^29.0.3\",\n    \"typedoc\": \"^0.25.0\",\n    \"typescript\": \"~5.0.4\",\n    \"yn\": \"^5.0.0\"\n  },\n  \"engines\": {\n    \"node\": \">=12.13.0\"\n  },\n  \"lint-staged\": {\n    \"*.{js,jsx,ts,tsx}\": \"eslint --cache --fix\"\n  }\n}\n","// @ts-expect-error avoid enabling resolveJsonModule to keep build process simple\nimport { version } from \"../package.json\";\n\n/**\n * @public\n */\nexport const Version: string = version;\n","const apiUrl = process.env.API_URL || 'http://localhost:8080';\n\nexport async function getUserFragments(user) {\n  const response = await fetch(`${apiUrl}/v1/fragments`, {\n    headers: user.authorizationHeaders(),\n  });\n  if (!response.ok) {\n    throw new Error(`Failed to get fragments: ${response.status}`);\n  }\n  return await response.json();\n}"],"names":["Log2","$631c75f8a3fcffe9$var$level","$631c75f8a3fcffe9$var$logger","$parcel$global","globalThis","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","CryptoJS","Math1","undefined","window","crypto","self","msCrypto","cryptoSecureRandomInt","getRandomValues","Uint32Array","randomBytes","readInt32LE","create","F","obj","subtype","prototype","C","C_lib","lib","Base","extend","overrides","mixIn","hasOwnProperty","$super","apply","arguments","instance","properties","propertyName","toString","clone","WordArray","words","sigBytes","length","encoder","Hex","stringify","concat","wordArray","thisWords","thatWords","thisSigBytes","thatSigBytes","clamp","i","thatByte","j","ceil","slice","random","nBytes","push","C_enc","enc","hexChars","bite","join","parse","hexStr","hexStrLength","parseInt","substr","Latin1","latin1Chars","String","fromCharCode","latin1Str","latin1StrLength","charCodeAt","Utf8","decodeURIComponent","escape","utf8Str","unescape","encodeURIComponent","BufferedBlockAlgorithm","reset","_data","_nDataBytes","_append","data","_process","doFlush","processedWords","dataWords","dataSigBytes","blockSize","nBlocksReady","nWordsReady","max","_minBufferSize","nBytesReady","min","offset","_doProcessBlock","splice","Hasher","cfg","_doReset","update","messageUpdate","finalize","_doFinalize","_createHelper","hasher","message","_createHmacHelper","key","C_algo","HMAC","algo","Math","H","K","getFractionalBits","nPrime","isPrime","sqrtN","sqrt","factor","pow","W","SHA256","_hash","M","a","b","c","d","f","g","h","gamma0x","gamma0","gamma1x","gamma1","ch","maj","sigma0","t1","t2","nBitsTotal","nBitsLeft","floor","HmacSHA256","Base64","map","_map","base64Chars","triplet","byte1","byte2","charAt","paddingChar","base64Str","base64StrLength","reverseMap","_reverseMap","paddingIndex","indexOf","bitsCombined","bits1","$1eeac253570f845a$var$e","value","$1eeac253570f845a$export$b9721ef022f71a68","$1eeac253570f845a$export$2e2bcd8739ae039","name","$1eeac253570f845a$var$r","atob","bind","r","t","replace","o","header","JSON","$1eeac253570f845a$var$t","toUpperCase","split","$631c75f8a3fcffe9$exports","$631c75f8a3fcffe9$var$__create","$631c75f8a3fcffe9$var$__defProp","$631c75f8a3fcffe9$var$__getOwnPropDesc","getOwnPropertyDescriptor","$631c75f8a3fcffe9$var$__getOwnPropNames","getOwnPropertyNames","$631c75f8a3fcffe9$var$__getProtoOf","getPrototypeOf","$631c75f8a3fcffe9$var$__hasOwnProp","$631c75f8a3fcffe9$var$__copyProps","to","from","except","desc","$631c75f8a3fcffe9$var$__toESM","mod","isNodeMode","target","__esModule","$631c75f8a3fcffe9$var$src_exports","all","AccessTokenEvents","$631c75f8a3fcffe9$var$AccessTokenEvents","CheckSessionIFrame","$631c75f8a3fcffe9$var$CheckSessionIFrame","ErrorResponse","$631c75f8a3fcffe9$var$ErrorResponse","ErrorTimeout","$631c75f8a3fcffe9$var$ErrorTimeout","InMemoryWebStorage","$631c75f8a3fcffe9$var$InMemoryWebStorage","Log","$631c75f8a3fcffe9$var$Log","Logger","$631c75f8a3fcffe9$var$Logger","MetadataService","$631c75f8a3fcffe9$var$MetadataService","OidcClient","$631c75f8a3fcffe9$var$OidcClient","OidcClientSettingsStore","$631c75f8a3fcffe9$var$OidcClientSettingsStore","SessionMonitor","$631c75f8a3fcffe9$var$SessionMonitor","SigninResponse","$631c75f8a3fcffe9$var$SigninResponse","SigninState","$631c75f8a3fcffe9$var$SigninState","SignoutResponse","$631c75f8a3fcffe9$var$SignoutResponse","State","$631c75f8a3fcffe9$var$State","User","$631c75f8a3fcffe9$var$User","UserManager","$631c75f8a3fcffe9$var$UserManager","UserManagerSettingsStore","$631c75f8a3fcffe9$var$UserManagerSettingsStore","Version","$631c75f8a3fcffe9$var$Version","WebStorageStateStore","$631c75f8a3fcffe9$var$WebStorageStateStore","$631c75f8a3fcffe9$var$import_core","$631c75f8a3fcffe9$var$import_sha256","$631c75f8a3fcffe9$var$import_enc_base64","$631c75f8a3fcffe9$var$import_enc_utf8","$631c75f8a3fcffe9$var$nopLogger","debug","info","warn","error","setLevel","setLogger","_name","args","_format","_method","throw","method","methodLogger","createStatic","staticMethod","staticLogger","prefix","$631c75f8a3fcffe9$var$CryptoUtils","_randomWord","default","generateUUIDv4","uuid","$631c75f8a3fcffe9$var$UUID_V4_TEMPLATE","generateCodeVerifier","generateCodeChallenge","code_verifier","hashed","generateBasicAuth","client_id","client_secret","basicAuth","$631c75f8a3fcffe9$var$Event","_logger","_callbacks","addHandler","cb","removeHandler","idx","lastIndexOf","raise","ev","$631c75f8a3fcffe9$var$import_jwt_decode","$631c75f8a3fcffe9$var$JwtUtils","decode","token","$631c75f8a3fcffe9$var$PopupUtils","center","features","_a","width","find","outerWidth","left","round","screenX","height","top","screenY","outerHeight","serialize","entries","filter","$631c75f8a3fcffe9$var$Timer","_timerHandle","_expiration","_callback","diff","getEpochTime","cancel","Date","now","durationInSeconds","logger2","expiration","timerDurationInSeconds","setInterval","clearInterval","$631c75f8a3fcffe9$var$UrlUtils","readParams","url","responseMode","TypeError","URLSearchParams","params","parsedUrl","URL","form","_b","_c","error_description","error_uri","state","userState","session_state","url_state","_expiringTimer","_expiredTimer","_expiringNotificationTimeInSeconds","expiringNotificationTimeInSeconds","load","container","access_token","expires_in","duration","expiring","expired","unload","addAccessTokenExpiring","removeAccessTokenExpiring","addAccessTokenExpired","removeAccessTokenExpired","_client_id","_intervalInSeconds","_stopOnError","_timer","_session_state","_message","origin","_frame_origin","source","_frame","contentWindow","stop","document","createElement","style","visibility","position","src","href","Promise","resolve","onload","body","appendChild","addEventListener","start","send","postMessage","clear","getItem","setItem","removeItem","index","$631c75f8a3fcffe9$var$JsonService","additionalContentTypes","_jwtHandler","_extraHeaders","_contentTypes","fetchWithTimeout","input","timeoutInSeconds","initFetch","fetch","controller","AbortController","timeoutId","setTimeout","abort","signal","DOMException","clearTimeout","getJson","credentials","response","json","headers","appendExtraHeaders","status","contentType","item","startsWith","ok","text","statusText","postForm","initCredentials","responseText","customKeys","keys","protectedHeaders","forEach","headerName","includes","toLocaleLowerCase","content","_settings","_signingKeys","_metadata","_metadataUrl","metadataUrl","_jsonService","extraHeaders","signingKeys","metadata","fetchRequestCredentials","_fetchRequestCredentials","resetSigningKeys","getMetadata","assign","metadataSeed","getIssuer","_getMetadataProperty","getAuthorizationEndpoint","getUserInfoEndpoint","getTokenEndpoint","optional","getCheckSessionIframe","getEndSessionEndpoint","getRevocationEndpoint","getKeysEndpoint","getSigningKeys","jwks_uri","keySet","Array","isArray","store","localStorage","_store","_prefix","remove","getAllKeys","len","authority","response_type","scope","redirect_uri","post_logout_redirect_uri","client_authentication","prompt","display","max_age","ui_locales","acr_values","resource","response_mode","filterProtocolClaims","loadUserInfo","staleStateAgeInSeconds","clockSkewInSeconds","userInfoJwtIssuer","mergeClaims","disablePKCE","stateStore","refreshTokenCredentials","revokeTokenAdditionalContentTypes","refreshTokenAllowedScope","extraQueryParams","extraTokenParams","endsWith","console","$631c75f8a3fcffe9$var$UserInfoService","_metadataService","_getClaimsFromJwt","payload","getClaims","claims","$631c75f8a3fcffe9$var$TokenClient","exchangeCode","grant_type","append","exchangeCredentials","exchangeRefreshToken","refresh_token","param","revoke","token_type_hint","$631c75f8a3fcffe9$var$ResponseValidator","_claimsService","_userInfoService","_tokenClient","validateSigninResponse","_processSigninState","_processCode","isOpenId","_validateIdTokenAttributes","_processClaims","skipUserInfo","validateCredentialsResponse","id_token","validateRefreshResponse","profile","hasIdToken","validateSignoutResponse","validateSub","sub","tokenResponse","existingToken","incoming","existing","auth_time","azp","created","request_type","toStorageString","fromStorageString","storageString","clearStaleState","storage","age","cutoff","code_challenge","$631c75f8a3fcffe9$var$SigninRequest","state_data","nonce","optionalParams","searchParams","resources","token_type","splitState","expires_at","Number","$631c75f8a3fcffe9$var$SignoutRequest","id_token_hint","$631c75f8a3fcffe9$var$DefaultProtocolClaims","$631c75f8a3fcffe9$var$InternalRequiredProtocolClaims","$631c75f8a3fcffe9$var$ClaimsService","result","claim","claims1","claims2","values","previousValue","settings","metadataService","_validator","createSigninRequest","request","request_uri","login_hint","signinRequest","signinState","readSigninResponseState","removeState","storedStateString","processSigninResponse","processResourceOwnerPasswordCredentials","username","password","signinResponse","useRefreshToken","allowableScopes","providedScopes","createSignoutRequest","signoutState","readSignoutResponseState","processSignoutResponse","revokeToken","type","_userManager","_start","user","_sub","_sid","sid","_checkSessionIFrame","intervalInSeconds","checkSessionIntervalInSeconds","stopOnError","stopCheckSessionOnError","checkSessionIFrame","_stop","monitorAnonymousSession","timerHandle","session","querySessionStatus","tmpUser","raiseEvent","events","_raiseUserSessionChanged","_raiseUserSignedOut","_raiseUserSignedIn","addUserLoaded","addUserUnloaded","_init","catch","getUser","scopes","$631c75f8a3fcffe9$var$messageSource","$631c75f8a3fcffe9$var$AbstractChildWindow","_abort","_disposeHandlers","Set","_window","navigate","location","keepOpen","reject","listener","scriptOrigin","_dispose","add","removeEventListener","reason","close","dispose","_notifyParent","parent","targetOrigin","$631c75f8a3fcffe9$var$DefaultPopupWindowFeatures","toolbar","closePopupWindowAfterInSeconds","$631c75f8a3fcffe9$var$DefaultPopupTarget","popup_redirect_uri","popup_post_logout_redirect_uri","popupWindowFeatures","popupWindowTarget","redirectMethod","redirectTarget","iframeNotifyParentOrigin","iframeScriptOrigin","silent_redirect_uri","silentRequestTimeoutInSeconds","automaticSilentRenew","validateSubOnSilentRenew","includeIdTokenInSilentRenew","monitorSession","query_status_response_type","revokeTokenTypes","revokeTokensOnSignout","includeIdTokenInSilentSignout","accessTokenExpiringNotificationTimeInSeconds","userStore","sessionStorage","$631c75f8a3fcffe9$var$IFrameWindow","_timeoutInSeconds","createHiddenIframe","iframe","timer","parentNode","_a2","frame","removeChild","notifyParent","$631c75f8a3fcffe9$var$IFrameNavigator","prepare","callback","$631c75f8a3fcffe9$var$PopupWindow","centeredPopup","open","closed","focus","popupClosedInterval","notifyOpener","opener","$631c75f8a3fcffe9$var$PopupNavigator","$631c75f8a3fcffe9$var$RedirectNavigator","targetWindow","redirect","promise","$631c75f8a3fcffe9$var$UserManagerEvents","_userLoaded","_userUnloaded","_silentRenewError","_userSignedIn","_userSignedOut","_userSessionChanged","removeUserLoaded","removeUserUnloaded","addSilentRenewError","removeSilentRenewError","_raiseSilentRenewError","addUserSignedIn","removeUserSignedIn","addUserSignedOut","removeUserSignedOut","addUserSessionChanged","removeUserSessionChanged","$631c75f8a3fcffe9$var$SilentRenewService","_isStarted","_retryTimer","_tokenExpiring","signinSilent","$631c75f8a3fcffe9$var$RefreshState","redirectNavigator","popupNavigator","iframeNavigator","_client","_redirectNavigator","_popupNavigator","_iframeNavigator","_events","_silentRenewService","startSilentRenew","_sessionMonitor","_loadUser","removeUser","storeUser","signinRedirect","requestArgs","handle","_signinStart","signinRedirectCallback","_signinEnd","signinResourceOwnerCredentials","_buildUser","signinPopup","_signin","signinPopupCallback","verifySub","_useRefreshToken","signinSilentCallback","signinCallback","signoutCallback","signoutRedirectCallback","signoutPopupCallback","signoutSilentCallback","navResponse","signoutRedirect","_signoutStart","_signoutEnd","signoutPopup","_signout","_revokeInternal","signoutRequest","signoutResponse","signoutSilent","revokeTokens","types","typesPresent","stopSilentRenew","_userStoreKey","$7bc1e5a75795e44f$export$cc5a9a3851cbd70d","$7bc1e5a75795e44f$export$9670d83f11d4b64a","$7bc1e5a75795e44f$export$b0ac3a1c242cb1ea","logoutUrl","$7bc1e5a75795e44f$var$formatUser","log","preferred_username","email","idToken","accessToken","authorizationHeaders","Authorization","$7bc1e5a75795e44f$export$7cbf767827cd68ba","search","history","replaceState","title","pathname","$96e14f2a7c3555e4$export$4517903f0097c2bd","userSection","querySelector","loginBtn","innerHTML","logoutBtn","fragments","InvalidCharacterError","this","str","bs","buffer","bc","output","m","p","b64DecodeUnicode","InvalidTokenError","options","pos","base64_url_decode","sha256","jwt_decode","logger"],"version":3,"file":"fragments-ui.e5b7f26e.js.map"}